//
// Project: clibjs
// Created by bajdcc
//

#include <array>
#include "cjstypes.h"

namespace clib {
    namespace types {

        const char *lexer_string(lexer_t t) {
            static std::array<const char *, LEXER_END> p = {
                "NONE",
                "NUMBER",
                "ID",
                "REGEX",
                "STRING",
                "SPACE",
                "NEWLINE",
                "COMMENT",
                "END",
                "RULE_START",
                "RULE_NO_LINE",
                "RULE_LINE",
                "RULE_RBRACE",
                "RULE_EOF",
                "RULE_END",
                "KEYWORD_START",
                "K_NEW",
                "K_VAR",
                "K_LET",
                "K_FUNCTION",
                "K_IF",
                "K_ELSE",
                "K_FOR",
                "K_WHILE",
                "K_IN",
                "K_DO",
                "K_BREAK",
                "K_CONTINUE",
                "K_RETURN",
                "K_SWITCH",
                "K_DEFAULT",
                "K_CASE",
                "K_NULL",
                "K_TRUE",
                "K_FALSE",
                "K_INSTANCEOF",
                "K_TYPEOF",
                "K_VOID",
                "K_DELETE",
                "K_CLASS",
                "K_THIS",
                "K_SUPER",
                "K_WITH",
                "K_TRY",
                "K_THROW",
                "K_CATCH",
                "K_FINALLY",
                "K_DEBUGGER",
                "KEYWORD_END",
                "OPERATOR_START",
                "T_ADD",
                "T_SUB",
                "T_MUL",
                "T_DIV",
                "T_MOD",
                "T_POWER",
                "T_INC",
                "T_DEC",
                "T_ASSIGN",
                "T_ASSIGN_ADD",
                "T_ASSIGN_SUB",
                "T_ASSIGN_MUL",
                "T_ASSIGN_DIV",
                "T_ASSIGN_MOD",
                "T_ASSIGN_LSHIFT",
                "T_ASSIGN_RSHIFT",
                "T_ASSIGN_URSHIFT",
                "T_ASSIGN_AND",
                "T_ASSIGN_OR",
                "T_ASSIGN_XOR",
                "T_ASSIGN_POWER",
                "T_LESS",
                "T_LESS_EQUAL",
                "T_GREATER",
                "T_GREATER_EQUAL",
                "T_EQUAL",
                "T_FEQUAL",
                "T_NOT_EQUAL",
                "T_FNOT_EQUAL",
                "T_LOG_NOT",
                "T_LOG_AND",
                "T_LOG_OR",
                "T_BIT_NOT",
                "T_BIT_AND",
                "T_BIT_OR",
                "T_BIT_XOR",
                "T_DOT",
                "T_COMMA",
                "T_SEMI",
                "T_COLON",
                "T_QUERY",
                "T_LSHIFT",
                "T_RSHIFT",
                "T_URSHIFT",
                "T_LPARAN",
                "T_RPARAN",
                "T_LSQUARE",
                "T_RSQUARE",
                "T_LBRACE",
                "T_RBRACE",
                "T_COALESCE",
                "T_SHARP",
                "T_ELLIPSIS",
                "T_ARROW",
                "OPERATOR_END",
            };
            return p.at(t);
        }

        const char *coll_string(coll_t t) {
            static std::array<const char *, COLL_END> p = {
                "Program",
                "SourceElement",
                "Statement",
                "Block",
                "StatementList",
                "VariableStatement",
                "VariableDeclarationList",
                "VariableDeclaration",
                "EmptyStatement",
                "ExpressionStatement",
                "IfStatement",
                "IterationStatement",
                "DoStatement",
                "WhileStatement",
                "ForStatement",
                "ForInStatement",
                "ContinueStatement",
                "BreakStatement",
                "ReturnStatement",
                "WithStatement",
                "SwitchStatement",
                "CaseBlock",
                "CaseClauses",
                "CaseClause",
                "DefaultClause",
                "LabelledStatement",
                "ThrowStatement",
                "TryStatement",
                "CatchProduction",
                "FinallyProduction",
                "DebuggerStatement",
                "FunctionDeclaration",
                "ClassDeclaration",
                "ClassTail",
                "ClassElement",
                "ClassElements",
                "MethodDefinition",
                "FormalParameterList",
                "FormalParameterArg",
                "FunctionBody",
                "SourceElements",
                "ArrayLiteral",
                "ElementList",
                "ArrayElement",
                "ObjectLiteral",
                "PropertyAssignment",
                "PropertyAssignments",
                "PropertyName",
                "Arguments",
                "Argument",
                "ExpressionSequence",
                "SingleExpression",
                "Assignable",
                "AnonymousFunction",
                "ArrowFunctionParameters",
                "ArrowFunctionBody",
                "Literal",
                "NumericLiteral",
                "IdentifierName",
                "ReservedWord",
                "Keyword",
                "Eos",
                "PropertyExpressionAssignment",
                "ComputedPropertyExpressionAssignment",
                "PropertyShorthand",
                "FunctionDecl",
                "AnoymousFunctionDecl",
                "ArrowFunction",
                "FunctionExpression",
                "ClassExpression",
                "MemberIndexExpression",
                "MemberDotExpression",
                "ArgumentsExpression",
                "NewExpression",
                "PostIncrementExpression",
                "PostDecreaseExpression",
                "PostfixExpression",
                "DeleteExpression",
                "VoidExpression",
                "TypeofExpression",
                "PreIncrementExpression",
                "PreDecreaseExpression",
                "UnaryPlusExpression",
                "UnaryMinusExpression",
                "BitNotExpression",
                "NotExpression",
                "PowerExpression",
                "MultiplicativeExpression",
                "AdditiveExpression",
                "CoalesceExpression",
                "BitShiftExpression",
                "RelationalExpression",
                "InstanceofExpression",
                "InExpression",
                "EqualityExpression",
                "BitAndExpression",
                "BitXOrExpression",
                "BitOrExpression",
                "LogicalAndExpression",
                "LogicalOrExpression",
                "TernaryExpression",
                "AssignmentExpression",
                "AssignmentOperatorExpression",
                "ThisExpression",
                "IdentifierExpression",
                "SuperExpression",
                "LiteralExpression",
                "ArrayLiteralExpression",
                "ObjectLiteralExpression",
                "ParenthesizedExpression",
            };
            return p.at(t);
        }

        const char *ast_string(ast_t t) {
            static std::array<const char *, AST_END> p = {
                "root",
                "collection",
                "keyword",
                "operator",
                "literal",
                "string",
                "regex",
                "number",
                "rule",
            };
            return p.at(t);
        }
    }

    cexception::cexception(const std::string &msg) noexcept : msg(msg) {}

    std::string cexception::message() const {
        return msg;
    }
}