==== RULE ====
additiveExpression => [ additiveExpression ( 'T_ADD' | 'T_SUB' ) ] multiplicativeExpression
anonymousFunction => ( functionDecl | anoymousFunctionDecl | arrowFunction )
anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
argument => [ argument ('T_COMMA') ] [ ('T_ELLIPSIS') ] ( singleExpression | #ID# )
arguments => ('T_LPARAN') [ argument ] ('T_RPARAN')
argumentsExpression => [ argumentsExpression ] arguments
arrayElement => [ 'T_ELLIPSIS' ] singleExpression
arrayLiteral => ('T_LSQUARE') [ elementList ] ('T_RSQUARE')
arrayLiteralExpression => arrayLiteral
arrowFunction => arrowFunctionParameters ('T_ARROW') arrowFunctionBody
arrowFunctionBody => ( singleExpression | 'T_LBRACE' [ functionBody ] 'T_RBRACE' )
arrowFunctionParameters => ( #ID# | ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') )
assignable => ( #ID# | arrayLiteral | objectLiteral )
assignmentExpression => [ assignmentExpression 'T_ASSIGN' ] assignmentOperatorExpression
assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
bitAndExpression => [ bitAndExpression 'T_BIT_AND' ] equalityExpression
bitNotExpression => ( 'T_BIT_NOT' bitNotExpression | unaryMinusExpression )
bitOrExpression => [ bitOrExpression 'T_BIT_OR' ] bitXOrExpression
bitShiftExpression => [ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression
bitXOrExpression => [ bitXOrExpression 'T_BIT_XOR' ] bitAndExpression
block => ('T_LBRACE') [ statementList ] ('T_RBRACE')
breakStatement => K_BREAK [ #ID# ] [ eos ]
caseBlock => ('T_LBRACE') [ caseClauses ] [ defaultClause [ caseClauses ] ] ('T_RBRACE')
caseClause => K_CASE expressionSequence 'T_COLON' [ statementList ]
caseClauses => caseClause [ caseClauses ]
catchProduction => K_CATCH [ ('T_LPARAN') [ assignable ] ('T_RPARAN') ] block
classDeclaration => K_CLASS #ID# classTail
classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' singleExpression )
classElements => [ classElements ('T_COMMA') ] classElement
classExpression => K_CLASS (#ID#) classTail
classTail => ('T_LBRACE') classElements ('T_RBRACE')
coalesceExpression => [ coalesceExpression 'T_COALESCE' ] additiveExpression
computedPropertyExpressionAssignment => ('T_LPARAN') singleExpression ('T_RPARAN') ('T_COLON') singleExpression
continueStatement => K_CONTINUE [ #ID# ] [ eos ]
debuggerStatement => K_DEBUGGER [ eos ]
declaration => ( variableStatement | classDeclaration | functionDeclaration )
defaultClause => K_DEFAULT 'T_COLON' [ statementList ]
deleteExpression => ( K_DELETE deleteExpression | newExpression )
doStatement => K_DO statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
elementList => [ elementList ('T_COMMA') ] arrayElement
emptyStatement => 'T_SEMI'
eos => ( 'T_SEMI' | #END# )
equalityExpression => [ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression
expressionSequence => [ expressionSequence ('T_COMMA') ] singleExpression
expressionStatement => expressionSequence [ eos ]
finallyProduction => K_FINALLY block
forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement
forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
formalParameterArg => assignable
formalParameterList => [ formalParameterList ('T_COMMA') ] assignable
functionBody => [ functionBody ] sourceElements
functionDecl => functionDeclaration
functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
functionExpression => ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
identifierExpression => #ID#
identifierName => ( #ID# | reservedWord )
ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement ]
inExpression => [ inExpression K_IN ] instanceofExpression
instanceofExpression => [ instanceofExpression K_INSTANCEOF ] relationalExpression
iterationStatement => ( doStatement | whileStatement | forStatement | forInStatement )
keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
labelledStatement => #ID# 'T_COLON' statement
literal => ( K_NULL | K_TRUE | K_FALSE | #STRING# | #REGEX# | #NUMBER# )
literalExpression => literal
logicalAndExpression => [ logicalAndExpression 'T_LOG_AND' ] bitOrExpression
logicalOrExpression => [ logicalOrExpression 'T_LOG_OR' ] logicalAndExpression
memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' [ 'T_SHARP' ] identifierName
memberIndexExpression => [ memberIndexExpression ] 'T_LSQUARE' expressionSequence 'T_RSQUARE'
methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
multiplicativeExpression => [ multiplicativeExpression ( 'T_MUL' | 'T_DIV' | 'T_MOD' ) ] powerExpression
newExpression => ( K_NEW singleExpression [ arguments ] | postfixExpression )
notExpression => ( 'T_LOG_NOT' notExpression | bitNotExpression )
numericLiteral => #NUMBER#
objectLiteral => ('T_LBRACE') [ propertyAssignments ] [ ('T_COMMA') ] ('T_RBRACE')
objectLiteralExpression => objectLiteral
parenthesizedExpression => ('T_LPARAN') expressionSequence ('T_RPARAN')
postDecreaseExpression => [ postDecreaseExpression ] 'T_DEC'
postIncrementExpression => [ postIncrementExpression ] 'T_INC'
postfixExpression => ( postfixExpression ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )
powerExpression => [ powerExpression 'T_POWER' ] notExpression
preDecreaseExpression => ( 'T_DEC' preDecreaseExpression | preIncrementExpression )
preIncrementExpression => ( 'T_INC' preIncrementExpression | typeofExpression )
program => sourceElements
propertyAssignment => ( propertyExpressionAssignment | computedPropertyExpressionAssignment | propertyShorthand )
propertyAssignments => [ propertyAssignments ('T_COMMA') ] propertyAssignment
propertyExpressionAssignment => propertyName ('T_COLON') singleExpression
propertyName => ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') )
propertyShorthand => [ 'T_ELLIPSIS' ] singleExpression
relationalExpression => [ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression
reservedWord => ( keyword | K_TRUE | K_FALSE )
returnStatement => K_RETURN [ expressionSequence ] [ eos ]
singleExpression => [ singleExpression ('T_COMMA') ] assignmentExpression
sourceElement => statement
sourceElements => [ sourceElements ] statement
statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
statementList => [ statementList ] statement
superExpression => K_SUPER
switchStatement => K_SWITCH ('T_LPARAN') expressionSequence ('T_RPARAN') caseBlock
ternaryExpression => logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' singleExpression ]
thisExpression => K_THIS
throwStatement => K_THROW expressionSequence [ eos ]
tryStatement => K_TRY block ( catchProduction [ finallyProduction ] | finallyProduction )
typeofExpression => ( K_TYPEOF typeofExpression | voidExpression )
unaryMinusExpression => ( 'T_SUB' unaryMinusExpression | unaryPlusExpression )
unaryPlusExpression => ( 'T_ADD' unaryPlusExpression | preDecreaseExpression )
variableDeclaration => assignable [ 'T_ASSIGN' singleExpression ]
variableDeclarationList => [ variableDeclarationList ('T_COMMA') ] variableDeclaration
variableStatement => K_VAR variableDeclarationList [ eos ]
voidExpression => ( K_VOID voidExpression | deleteExpression )
whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement
withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement
==== NGA  ====
** Rule: additiveExpression => [ additiveExpression ( 'T_ADD' | 'T_SUB' ) ] multiplicativeExpression
-- Tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF K_NEW K_VOID #NUMBER# 'T_LBRACE' K_DELETE K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER #STRING# K_FALSE 
-- First-set tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_TYPEOF K_NEW K_THIS #NUMBER# 'T_LBRACE' K_TRUE 'T_LPARAN' K_VOID #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER K_DELETE #STRING# K_FALSE 
-- First-set rules: multiplicativeExpression additiveExpression 
Status #0 - additiveExpression => [ @ additiveExpression ( 'T_ADD' | 'T_SUB' ) ] multiplicativeExpression
  To #1:  additiveExpression
  To #2:  multiplicativeExpression
Status #1 - additiveExpression => [ additiveExpression @ ( 'T_ADD' | 'T_SUB' ) ] multiplicativeExpression
  To #3:  'T_SUB'
  To #4:  'T_ADD'
Status #2 [FINAL] - additiveExpression => [ additiveExpression ( 'T_ADD' | 'T_SUB' ) ] multiplicativeExpression @
Status #3 - additiveExpression => [ additiveExpression ( 'T_ADD' | 'T_SUB' @ ) ] multiplicativeExpression
  To #2:  multiplicativeExpression
Status #4 - additiveExpression => [ additiveExpression ( 'T_ADD' @ | 'T_SUB' ) ] multiplicativeExpression
  To #2:  multiplicativeExpression

** Rule: anonymousFunction => ( functionDecl | anoymousFunctionDecl | arrowFunction )
-- Tokens: 'T_LPARAN' #ID# K_FUNCTION 
-- First-set tokens: K_FUNCTION #ID# 'T_LPARAN' 
-- First-set rules: arrowFunction anoymousFunctionDecl functionDecl 
Status #0 - anonymousFunction => @ ( functionDecl | anoymousFunctionDecl | arrowFunction )
  To #1:  arrowFunction
  To #2:  functionDecl
  To #3:  anoymousFunctionDecl
Status #1 [FINAL] - anonymousFunction => ( functionDecl | anoymousFunctionDecl | arrowFunction @ )
Status #2 [FINAL] - anonymousFunction => ( functionDecl @ | anoymousFunctionDecl | arrowFunction )
Status #3 [FINAL] - anonymousFunction => ( functionDecl | anoymousFunctionDecl @ | arrowFunction )

** Rule: anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
-- Tokens: K_FUNCTION 
-- First-set tokens: K_FUNCTION 
-- First-set rules: 
Status #0 - anoymousFunctionDecl => @ K_FUNCTION ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
  To #1:  K_FUNCTION
Status #1 - anoymousFunctionDecl => K_FUNCTION @ ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
  To #2:  ('T_LPARAN')
Status #2 - anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') @ [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
  To #3:  ('T_RPARAN')
  To #4:  formalParameterList
Status #3 - anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') @ ('T_LBRACE') [ functionBody ] ('T_RBRACE')
  To #5:  ('T_LBRACE')
Status #4 - anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') [ formalParameterList @ ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
  To #3:  ('T_RPARAN')
Status #5 - anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') @ [ functionBody ] ('T_RBRACE')
  To #6:  ('T_RBRACE')
  To #7:  functionBody
Status #6 [FINAL] - anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE') @
Status #7 - anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody @ ] ('T_RBRACE')
  To #6:  ('T_RBRACE')

** Rule: argument => [ argument ('T_COMMA') ] [ ('T_ELLIPSIS') ] ( singleExpression | #ID# )
-- Tokens: #ID# 'T_LSQUARE' 'T_ELLIPSIS' 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF K_NEW K_VOID #NUMBER# 'T_LBRACE' K_DELETE K_TRUE 'T_LPARAN' #REGEX# K_CLASS K_SUPER #STRING# K_FALSE 
-- First-set tokens: 'T_LSQUARE' 'T_ELLIPSIS' 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_TYPEOF K_NEW #ID# K_VOID K_THIS #NUMBER# 'T_LBRACE' K_TRUE 'T_LPARAN' #REGEX# K_CLASS K_SUPER K_DELETE #STRING# K_FALSE 
-- First-set rules: singleExpression argument 
Status #0 - argument => [ @ argument ('T_COMMA') ] [ ('T_ELLIPSIS') ] ( singleExpression | #ID# )
  To #1:  argument
  To #2:  ('T_ELLIPSIS')
  To #3:  singleExpression
  To #4:  #ID#
Status #1 - argument => [ argument @ ('T_COMMA') ] [ ('T_ELLIPSIS') ] ( singleExpression | #ID# )
  To #5:  ('T_COMMA')
Status #2 - argument => [ argument ('T_COMMA') ] [ ('T_ELLIPSIS') @ ] ( singleExpression | #ID# )
  To #4:  #ID#
  To #3:  singleExpression
Status #3 [FINAL] - argument => [ argument ('T_COMMA') ] [ ('T_ELLIPSIS') ] ( singleExpression @ | #ID# )
Status #4 [FINAL] - argument => [ argument ('T_COMMA') ] [ ('T_ELLIPSIS') ] ( singleExpression | #ID# @ )
Status #5 - argument => [ argument ('T_COMMA') @ ] [ ('T_ELLIPSIS') ] ( singleExpression | #ID# )
  To #4:  #ID#
  To #2:  ('T_ELLIPSIS')
  To #3:  singleExpression

** Rule: arguments => ('T_LPARAN') [ argument ] ('T_RPARAN')
-- Tokens: 'T_LPARAN' 
-- First-set tokens: 'T_LPARAN' 
-- First-set rules: 
Status #0 - arguments => @ ('T_LPARAN') [ argument ] ('T_RPARAN')
  To #1:  ('T_LPARAN')
Status #1 - arguments => ('T_LPARAN') @ [ argument ] ('T_RPARAN')
  To #2:  ('T_RPARAN')
  To #3:  argument
Status #2 [FINAL] - arguments => ('T_LPARAN') [ argument ] ('T_RPARAN') @
Status #3 - arguments => ('T_LPARAN') [ argument @ ] ('T_RPARAN')
  To #2:  ('T_RPARAN')

** Rule: argumentsExpression => [ argumentsExpression ] arguments
-- Tokens: 'T_LPARAN' 
-- First-set tokens: 'T_LPARAN' 
-- First-set rules: arguments argumentsExpression 
Status #0 - argumentsExpression => [ @ argumentsExpression ] arguments
  To #1:  argumentsExpression
  To #2:  arguments
Status #1 - argumentsExpression => [ argumentsExpression @ ] arguments
  To #2:  arguments
Status #2 [FINAL] - argumentsExpression => [ argumentsExpression ] arguments @

** Rule: arrayElement => [ 'T_ELLIPSIS' ] singleExpression
-- Tokens: 'T_ELLIPSIS' 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF K_NEW K_VOID #NUMBER# 'T_LBRACE' K_DELETE K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER #STRING# K_FALSE 
-- First-set tokens: K_FALSE #STRING# K_SUPER K_CLASS #REGEX# 'T_LSQUARE' #ID# 'T_LPARAN' K_TRUE K_DELETE 'T_LBRACE' #NUMBER# K_VOID K_NEW K_TYPEOF K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 'T_ELLIPSIS' 
-- First-set rules: singleExpression 
Status #0 - arrayElement => [ @ 'T_ELLIPSIS' ] singleExpression
  To #1:  'T_ELLIPSIS'
  To #2:  singleExpression
Status #1 - arrayElement => [ 'T_ELLIPSIS' @ ] singleExpression
  To #2:  singleExpression
Status #2 [FINAL] - arrayElement => [ 'T_ELLIPSIS' ] singleExpression @

** Rule: arrayLiteral => ('T_LSQUARE') [ elementList ] ('T_RSQUARE')
-- Tokens: 'T_LSQUARE' 
-- First-set tokens: 'T_LSQUARE' 
-- First-set rules: 
Status #0 - arrayLiteral => @ ('T_LSQUARE') [ elementList ] ('T_RSQUARE')
  To #1:  ('T_LSQUARE')
Status #1 - arrayLiteral => ('T_LSQUARE') @ [ elementList ] ('T_RSQUARE')
  To #2:  ('T_RSQUARE')
  To #3:  elementList
Status #2 [FINAL] - arrayLiteral => ('T_LSQUARE') [ elementList ] ('T_RSQUARE') @
Status #3 - arrayLiteral => ('T_LSQUARE') [ elementList @ ] ('T_RSQUARE')
  To #2:  ('T_RSQUARE')

** Rule: arrayLiteralExpression => arrayLiteral
-- Tokens: 'T_LSQUARE' 
-- First-set tokens: 'T_LSQUARE' 
-- First-set rules: arrayLiteral 
Status #0 - arrayLiteralExpression => @ arrayLiteral
  To #1:  arrayLiteral
Status #1 [FINAL] - arrayLiteralExpression => arrayLiteral @

** Rule: arrowFunction => arrowFunctionParameters ('T_ARROW') arrowFunctionBody
-- Tokens: #ID# 'T_LPARAN' 
-- First-set tokens: 'T_LPARAN' #ID# 
-- First-set rules: arrowFunctionParameters 
Status #0 - arrowFunction => @ arrowFunctionParameters ('T_ARROW') arrowFunctionBody
  To #1:  arrowFunctionParameters
Status #1 - arrowFunction => arrowFunctionParameters @ ('T_ARROW') arrowFunctionBody
  To #2:  ('T_ARROW')
Status #2 - arrowFunction => arrowFunctionParameters ('T_ARROW') @ arrowFunctionBody
  To #3:  arrowFunctionBody
Status #3 [FINAL] - arrowFunction => arrowFunctionParameters ('T_ARROW') arrowFunctionBody @

** Rule: arrowFunctionBody => ( singleExpression | 'T_LBRACE' [ functionBody ] 'T_RBRACE' )
-- Tokens: 'T_LBRACE' 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF K_NEW K_VOID #NUMBER# K_DELETE K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER #STRING# K_FALSE 
-- First-set tokens: K_FALSE #STRING# K_SUPER K_CLASS #REGEX# 'T_LSQUARE' #ID# 'T_LPARAN' K_TRUE K_DELETE #NUMBER# K_VOID K_NEW K_TYPEOF K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 'T_LBRACE' 
-- First-set rules: singleExpression 
Status #0 - arrowFunctionBody => @ ( singleExpression | 'T_LBRACE' [ functionBody ] 'T_RBRACE' )
  To #1:  'T_LBRACE'
  To #2:  singleExpression
Status #1 - arrowFunctionBody => ( singleExpression | 'T_LBRACE' @ [ functionBody ] 'T_RBRACE' )
  To #3:  'T_RBRACE'
  To #4:  functionBody
Status #2 [FINAL] - arrowFunctionBody => ( singleExpression @ | 'T_LBRACE' [ functionBody ] 'T_RBRACE' )
Status #3 [FINAL] - arrowFunctionBody => ( singleExpression | 'T_LBRACE' [ functionBody ] 'T_RBRACE' @ )
Status #4 - arrowFunctionBody => ( singleExpression | 'T_LBRACE' [ functionBody @ ] 'T_RBRACE' )
  To #3:  'T_RBRACE'

** Rule: arrowFunctionParameters => ( #ID# | ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') )
-- Tokens: #ID# 'T_LPARAN' 
-- First-set tokens: 'T_LPARAN' #ID# 
-- First-set rules: 
Status #0 - arrowFunctionParameters => @ ( #ID# | ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') )
  To #1:  ('T_LPARAN')
  To #2:  #ID#
Status #1 - arrowFunctionParameters => ( #ID# | ('T_LPARAN') @ [ formalParameterList ] ('T_RPARAN') )
  To #3:  ('T_RPARAN')
  To #4:  formalParameterList
Status #2 [FINAL] - arrowFunctionParameters => ( #ID# @ | ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') )
Status #3 [FINAL] - arrowFunctionParameters => ( #ID# | ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') @ )
Status #4 - arrowFunctionParameters => ( #ID# | ('T_LPARAN') [ formalParameterList @ ] ('T_RPARAN') )
  To #3:  ('T_RPARAN')

** Rule: assignable => ( #ID# | arrayLiteral | objectLiteral )
-- Tokens: #ID# 'T_LBRACE' 'T_LSQUARE' 
-- First-set tokens: 'T_LSQUARE' 'T_LBRACE' #ID# 
-- First-set rules: objectLiteral arrayLiteral 
Status #0 - assignable => @ ( #ID# | arrayLiteral | objectLiteral )
  To #1:  objectLiteral
  To #2:  #ID#
  To #3:  arrayLiteral
Status #1 [FINAL] - assignable => ( #ID# | arrayLiteral | objectLiteral @ )
Status #2 [FINAL] - assignable => ( #ID# @ | arrayLiteral | objectLiteral )
Status #3 [FINAL] - assignable => ( #ID# | arrayLiteral @ | objectLiteral )

** Rule: assignmentExpression => [ assignmentExpression 'T_ASSIGN' ] assignmentOperatorExpression
-- Tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF K_NEW K_VOID #NUMBER# 'T_LBRACE' K_DELETE K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER #STRING# K_FALSE 
-- First-set tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_TYPEOF K_NEW K_THIS #NUMBER# 'T_LBRACE' K_TRUE 'T_LPARAN' K_VOID #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER K_DELETE #STRING# K_FALSE 
-- First-set rules: assignmentOperatorExpression assignmentExpression 
Status #0 - assignmentExpression => [ @ assignmentExpression 'T_ASSIGN' ] assignmentOperatorExpression
  To #1:  assignmentExpression
  To #2:  assignmentOperatorExpression
Status #1 - assignmentExpression => [ assignmentExpression @ 'T_ASSIGN' ] assignmentOperatorExpression
  To #3:  'T_ASSIGN'
Status #2 [FINAL] - assignmentExpression => [ assignmentExpression 'T_ASSIGN' ] assignmentOperatorExpression @
Status #3 - assignmentExpression => [ assignmentExpression 'T_ASSIGN' @ ] assignmentOperatorExpression
  To #2:  assignmentOperatorExpression

** Rule: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
-- Tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF K_NEW K_VOID #NUMBER# 'T_LBRACE' K_DELETE K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER #STRING# K_FALSE 
-- First-set tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_TYPEOF K_NEW K_THIS #NUMBER# 'T_LBRACE' K_TRUE 'T_LPARAN' K_VOID #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER K_DELETE #STRING# K_FALSE 
-- First-set rules: ternaryExpression assignmentOperatorExpression 
Status #0 - assignmentOperatorExpression => [ @ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
  To #1:  assignmentOperatorExpression
  To #2:  ternaryExpression
Status #1 - assignmentOperatorExpression => [ assignmentOperatorExpression @ ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
  To #3:  'T_ASSIGN_POWER'
  To #4:  'T_ASSIGN_ADD'
  To #5:  'T_ASSIGN_SUB'
  To #6:  'T_ASSIGN_MUL'
  To #7:  'T_ASSIGN_DIV'
  To #8:  'T_ASSIGN_MOD'
  To #9:  'T_ASSIGN_LSHIFT'
  To #10:  'T_ASSIGN_RSHIFT'
  To #11:  'T_ASSIGN_URSHIFT'
  To #12:  'T_ASSIGN_AND'
  To #13:  'T_ASSIGN_OR'
  To #14:  'T_ASSIGN_XOR'
Status #2 [FINAL] - assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
Status #3 - assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' @ ) ] ternaryExpression
  To #2:  ternaryExpression
Status #4 - assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' @ | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
  To #2:  ternaryExpression
Status #5 - assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' @ | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
  To #2:  ternaryExpression
Status #6 - assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' @ | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
  To #2:  ternaryExpression
Status #7 - assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' @ | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
  To #2:  ternaryExpression
Status #8 - assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' @ | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
  To #2:  ternaryExpression
Status #9 - assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' @ | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
  To #2:  ternaryExpression
Status #10 - assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' @ | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
  To #2:  ternaryExpression
Status #11 - assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' @ | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
  To #2:  ternaryExpression
Status #12 - assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' @ | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
  To #2:  ternaryExpression
Status #13 - assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' @ | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
  To #2:  ternaryExpression
Status #14 - assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' @ | 'T_ASSIGN_POWER' ) ] ternaryExpression
  To #2:  ternaryExpression

** Rule: bitAndExpression => [ bitAndExpression 'T_BIT_AND' ] equalityExpression
-- Tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF K_NEW K_VOID #NUMBER# 'T_LBRACE' K_DELETE K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER #STRING# K_FALSE 
-- First-set tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_TYPEOF K_NEW K_THIS #NUMBER# 'T_LBRACE' K_TRUE 'T_LPARAN' K_VOID #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER K_DELETE #STRING# K_FALSE 
-- First-set rules: equalityExpression bitAndExpression 
Status #0 - bitAndExpression => [ @ bitAndExpression 'T_BIT_AND' ] equalityExpression
  To #1:  bitAndExpression
  To #2:  equalityExpression
Status #1 - bitAndExpression => [ bitAndExpression @ 'T_BIT_AND' ] equalityExpression
  To #3:  'T_BIT_AND'
Status #2 [FINAL] - bitAndExpression => [ bitAndExpression 'T_BIT_AND' ] equalityExpression @
Status #3 - bitAndExpression => [ bitAndExpression 'T_BIT_AND' @ ] equalityExpression
  To #2:  equalityExpression

** Rule: bitNotExpression => ( 'T_BIT_NOT' bitNotExpression | unaryMinusExpression )
-- Tokens: 'T_BIT_NOT' 'T_SUB' 'T_ADD' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF K_NEW K_VOID #NUMBER# 'T_LBRACE' K_DELETE K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER #STRING# K_FALSE 
-- First-set tokens: K_FALSE #STRING# K_SUPER K_CLASS #REGEX# 'T_LSQUARE' #ID# 'T_LPARAN' K_TRUE K_DELETE 'T_LBRACE' #NUMBER# K_VOID K_NEW K_TYPEOF K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 'T_ADD' 'T_SUB' 'T_BIT_NOT' 
-- First-set rules: unaryMinusExpression 
Status #0 - bitNotExpression => @ ( 'T_BIT_NOT' bitNotExpression | unaryMinusExpression )
  To #1:  unaryMinusExpression
  To #2:  'T_BIT_NOT'
Status #1 [FINAL] - bitNotExpression => ( 'T_BIT_NOT' bitNotExpression | unaryMinusExpression @ )
Status #2 - bitNotExpression => ( 'T_BIT_NOT' @ bitNotExpression | unaryMinusExpression )
  To #3:  bitNotExpression
Status #3 [FINAL] - bitNotExpression => ( 'T_BIT_NOT' bitNotExpression @ | unaryMinusExpression )

** Rule: bitOrExpression => [ bitOrExpression 'T_BIT_OR' ] bitXOrExpression
-- Tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF K_NEW K_VOID #NUMBER# 'T_LBRACE' K_DELETE K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER #STRING# K_FALSE 
-- First-set tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_TYPEOF K_NEW K_THIS #NUMBER# 'T_LBRACE' K_TRUE 'T_LPARAN' K_VOID #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER K_DELETE #STRING# K_FALSE 
-- First-set rules: bitXOrExpression bitOrExpression 
Status #0 - bitOrExpression => [ @ bitOrExpression 'T_BIT_OR' ] bitXOrExpression
  To #1:  bitOrExpression
  To #2:  bitXOrExpression
Status #1 - bitOrExpression => [ bitOrExpression @ 'T_BIT_OR' ] bitXOrExpression
  To #3:  'T_BIT_OR'
Status #2 [FINAL] - bitOrExpression => [ bitOrExpression 'T_BIT_OR' ] bitXOrExpression @
Status #3 - bitOrExpression => [ bitOrExpression 'T_BIT_OR' @ ] bitXOrExpression
  To #2:  bitXOrExpression

** Rule: bitShiftExpression => [ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression
-- Tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF K_NEW K_VOID #NUMBER# 'T_LBRACE' K_DELETE K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER #STRING# K_FALSE 
-- First-set tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_TYPEOF K_NEW K_THIS #NUMBER# 'T_LBRACE' K_TRUE 'T_LPARAN' K_VOID #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER K_DELETE #STRING# K_FALSE 
-- First-set rules: coalesceExpression bitShiftExpression 
Status #0 - bitShiftExpression => [ @ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression
  To #1:  bitShiftExpression
  To #2:  coalesceExpression
Status #1 - bitShiftExpression => [ bitShiftExpression @ ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression
  To #3:  'T_URSHIFT'
  To #4:  'T_LSHIFT'
  To #5:  'T_RSHIFT'
Status #2 [FINAL] - bitShiftExpression => [ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression @
Status #3 - bitShiftExpression => [ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' @ ) ] coalesceExpression
  To #2:  coalesceExpression
Status #4 - bitShiftExpression => [ bitShiftExpression ( 'T_LSHIFT' @ | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression
  To #2:  coalesceExpression
Status #5 - bitShiftExpression => [ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' @ | 'T_URSHIFT' ) ] coalesceExpression
  To #2:  coalesceExpression

** Rule: bitXOrExpression => [ bitXOrExpression 'T_BIT_XOR' ] bitAndExpression
-- Tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF K_NEW K_VOID #NUMBER# 'T_LBRACE' K_DELETE K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER #STRING# K_FALSE 
-- First-set tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_TYPEOF K_NEW K_THIS #NUMBER# 'T_LBRACE' K_TRUE 'T_LPARAN' K_VOID #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER K_DELETE #STRING# K_FALSE 
-- First-set rules: bitAndExpression bitXOrExpression 
Status #0 - bitXOrExpression => [ @ bitXOrExpression 'T_BIT_XOR' ] bitAndExpression
  To #1:  bitXOrExpression
  To #2:  bitAndExpression
Status #1 - bitXOrExpression => [ bitXOrExpression @ 'T_BIT_XOR' ] bitAndExpression
  To #3:  'T_BIT_XOR'
Status #2 [FINAL] - bitXOrExpression => [ bitXOrExpression 'T_BIT_XOR' ] bitAndExpression @
Status #3 - bitXOrExpression => [ bitXOrExpression 'T_BIT_XOR' @ ] bitAndExpression
  To #2:  bitAndExpression

** Rule: block => ('T_LBRACE') [ statementList ] ('T_RBRACE')
-- Tokens: 'T_LBRACE' 
-- First-set tokens: 'T_LBRACE' 
-- First-set rules: 
Status #0 - block => @ ('T_LBRACE') [ statementList ] ('T_RBRACE')
  To #1:  ('T_LBRACE')
Status #1 - block => ('T_LBRACE') @ [ statementList ] ('T_RBRACE')
  To #2:  ('T_RBRACE')
  To #3:  statementList
Status #2 [FINAL] - block => ('T_LBRACE') [ statementList ] ('T_RBRACE') @
Status #3 - block => ('T_LBRACE') [ statementList @ ] ('T_RBRACE')
  To #2:  ('T_RBRACE')

** Rule: breakStatement => K_BREAK [ #ID# ] [ eos ]
-- Tokens: K_BREAK 
-- First-set tokens: K_BREAK 
-- First-set rules: 
Status #0 - breakStatement => @ K_BREAK [ #ID# ] [ eos ]
  To #1:  K_BREAK
Status #1 [FINAL] - breakStatement => K_BREAK @ [ #ID# ] [ eos ]
  To #2:  eos
  To #3:  #ID#
Status #2 [FINAL] - breakStatement => K_BREAK [ #ID# ] [ eos @ ]
Status #3 [FINAL] - breakStatement => K_BREAK [ #ID# @ ] [ eos ]
  To #2:  eos

** Rule: caseBlock => ('T_LBRACE') [ caseClauses ] [ defaultClause [ caseClauses ] ] ('T_RBRACE')
-- Tokens: 'T_LBRACE' 
-- First-set tokens: 'T_LBRACE' 
-- First-set rules: 
Status #0 - caseBlock => @ ('T_LBRACE') [ caseClauses ] [ defaultClause [ caseClauses ] ] ('T_RBRACE')
  To #1:  ('T_LBRACE')
Status #1 - caseBlock => ('T_LBRACE') @ [ caseClauses ] [ defaultClause [ caseClauses ] ] ('T_RBRACE')
  To #2:  ('T_RBRACE')
  To #3:  caseClauses
  To #4:  defaultClause
Status #2 [FINAL] - caseBlock => ('T_LBRACE') [ caseClauses ] [ defaultClause [ caseClauses ] ] ('T_RBRACE') @
Status #3 - caseBlock => ('T_LBRACE') [ caseClauses @ ] [ defaultClause [ caseClauses ] ] ('T_RBRACE')
  To #2:  ('T_RBRACE')
  To #4:  defaultClause
Status #4 - caseBlock => ('T_LBRACE') [ caseClauses ] [ defaultClause @ [ caseClauses ] ] ('T_RBRACE')
  To #2:  ('T_RBRACE')
  To #5:  caseClauses
Status #5 - caseBlock => ('T_LBRACE') [ caseClauses ] [ defaultClause [ caseClauses @ ] ] ('T_RBRACE')
  To #2:  ('T_RBRACE')

** Rule: caseClause => K_CASE expressionSequence 'T_COLON' [ statementList ]
-- Tokens: K_CASE 
-- First-set tokens: K_CASE 
-- First-set rules: 
Status #0 - caseClause => @ K_CASE expressionSequence 'T_COLON' [ statementList ]
  To #1:  K_CASE
Status #1 - caseClause => K_CASE @ expressionSequence 'T_COLON' [ statementList ]
  To #2:  expressionSequence
Status #2 - caseClause => K_CASE expressionSequence @ 'T_COLON' [ statementList ]
  To #3:  'T_COLON'
Status #3 [FINAL] - caseClause => K_CASE expressionSequence 'T_COLON' @ [ statementList ]
  To #4:  statementList
Status #4 [FINAL] - caseClause => K_CASE expressionSequence 'T_COLON' [ statementList @ ]

** Rule: caseClauses => caseClause [ caseClauses ]
-- Tokens: K_CASE 
-- First-set tokens: K_CASE 
-- First-set rules: caseClause 
Status #0 - caseClauses => @ caseClause [ caseClauses ]
  To #1:  caseClause
Status #1 [FINAL] - caseClauses => caseClause @ [ caseClauses ]
  To #2:  caseClauses
Status #2 [FINAL] - caseClauses => caseClause [ caseClauses @ ]

** Rule: catchProduction => K_CATCH [ ('T_LPARAN') [ assignable ] ('T_RPARAN') ] block
-- Tokens: K_CATCH 
-- First-set tokens: K_CATCH 
-- First-set rules: 
Status #0 - catchProduction => @ K_CATCH [ ('T_LPARAN') [ assignable ] ('T_RPARAN') ] block
  To #1:  K_CATCH
Status #1 - catchProduction => K_CATCH @ [ ('T_LPARAN') [ assignable ] ('T_RPARAN') ] block
  To #2:  block
  To #3:  ('T_LPARAN')
Status #2 [FINAL] - catchProduction => K_CATCH [ ('T_LPARAN') [ assignable ] ('T_RPARAN') ] block @
Status #3 - catchProduction => K_CATCH [ ('T_LPARAN') @ [ assignable ] ('T_RPARAN') ] block
  To #4:  ('T_RPARAN')
  To #5:  assignable
Status #4 - catchProduction => K_CATCH [ ('T_LPARAN') [ assignable ] ('T_RPARAN') @ ] block
  To #2:  block
Status #5 - catchProduction => K_CATCH [ ('T_LPARAN') [ assignable @ ] ('T_RPARAN') ] block
  To #4:  ('T_RPARAN')

** Rule: classDeclaration => K_CLASS #ID# classTail
-- Tokens: K_CLASS 
-- First-set tokens: K_CLASS 
-- First-set rules: 
Status #0 - classDeclaration => @ K_CLASS #ID# classTail
  To #1:  K_CLASS
Status #1 - classDeclaration => K_CLASS @ #ID# classTail
  To #2:  #ID#
Status #2 - classDeclaration => K_CLASS #ID# @ classTail
  To #3:  classTail
Status #3 [FINAL] - classDeclaration => K_CLASS #ID# classTail @

** Rule: classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' singleExpression )
-- Tokens: K_SUPER K_TRY K_FUNCTION K_WITH K_DELETE K_ELSE K_BREAK K_IF K_VOID K_INSTANCEOF K_FOR K_FINALLY K_RETURN K_DO K_LET K_CONTINUE K_SWITCH K_NEW K_WHILE K_DEBUGGER K_DEFAULT K_TRUE K_FALSE K_CLASS K_THROW #ID# K_THIS K_IN K_VAR 'T_LSQUARE' K_TYPEOF #NUMBER# K_CASE 'T_SHARP' K_CATCH #STRING# 'T_SEMI' 
-- First-set tokens: 'T_SEMI' 'T_SHARP' K_CASE #NUMBER# 'T_LSQUARE' #STRING# K_THIS #ID# K_CLASS K_FALSE K_TRUE K_DEFAULT K_DEBUGGER K_VAR K_WHILE K_SWITCH K_CONTINUE K_LET K_IN K_RETURN K_FINALLY K_NEW K_FOR K_INSTANCEOF K_CATCH K_VOID K_IF K_BREAK K_THROW K_ELSE K_DELETE K_WITH K_DO K_TYPEOF K_FUNCTION K_TRY K_SUPER 
-- First-set rules: propertyName emptyStatement methodDefinition 
Status #0 - classElement => @ ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' singleExpression )
  To #1:  propertyName
  To #2:  methodDefinition
  To #3:  emptyStatement
  To #4:  'T_SHARP'
Status #1 - classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName @ 'T_ASSIGN' singleExpression )
  To #5:  'T_ASSIGN'
Status #2 [FINAL] - classElement => ( methodDefinition @ | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' singleExpression )
Status #3 [FINAL] - classElement => ( methodDefinition | emptyStatement @ | [ 'T_SHARP' ] propertyName 'T_ASSIGN' singleExpression )
Status #4 - classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' @ ] propertyName 'T_ASSIGN' singleExpression )
  To #1:  propertyName
Status #5 - classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' @ singleExpression )
  To #6:  singleExpression
Status #6 [FINAL] - classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' singleExpression @ )

** Rule: classElements => [ classElements ('T_COMMA') ] classElement
-- Tokens: K_SUPER K_TRY K_FUNCTION K_WITH K_DELETE K_ELSE K_BREAK K_IF K_VOID K_INSTANCEOF K_FOR K_FINALLY K_RETURN K_DO K_LET K_CONTINUE K_SWITCH K_NEW K_WHILE K_DEBUGGER K_DEFAULT K_TRUE K_FALSE K_CLASS K_THROW #ID# K_THIS K_IN K_VAR 'T_LSQUARE' K_TYPEOF #NUMBER# K_CASE 'T_SHARP' K_CATCH #STRING# 'T_SEMI' 
-- First-set tokens: K_SUPER K_WITH K_FUNCTION K_DELETE K_BREAK K_VOID K_INSTANCEOF K_FOR K_FINALLY K_RETURN K_DO K_LET K_CONTINUE K_SWITCH K_NEW K_WHILE K_DEBUGGER K_DEFAULT K_TRUE K_FALSE K_IF K_CLASS K_THROW #ID# K_ELSE K_THIS K_IN K_VAR K_TRY 'T_LSQUARE' K_TYPEOF #NUMBER# K_CASE 'T_SHARP' K_CATCH #STRING# 'T_SEMI' 
-- First-set rules: classElement classElements 
Status #0 - classElements => [ @ classElements ('T_COMMA') ] classElement
  To #1:  classElements
  To #2:  classElement
Status #1 - classElements => [ classElements @ ('T_COMMA') ] classElement
  To #3:  ('T_COMMA')
Status #2 [FINAL] - classElements => [ classElements ('T_COMMA') ] classElement @
Status #3 - classElements => [ classElements ('T_COMMA') @ ] classElement
  To #2:  classElement

** Rule: classExpression => K_CLASS (#ID#) classTail
-- Tokens: K_CLASS 
-- First-set tokens: K_CLASS 
-- First-set rules: 
Status #0 - classExpression => @ K_CLASS (#ID#) classTail
  To #1:  K_CLASS
Status #1 - classExpression => K_CLASS @ (#ID#) classTail
  To #2:  (#ID#)
Status #2 - classExpression => K_CLASS (#ID#) @ classTail
  To #3:  classTail
Status #3 [FINAL] - classExpression => K_CLASS (#ID#) classTail @

** Rule: classTail => ('T_LBRACE') classElements ('T_RBRACE')
-- Tokens: 'T_LBRACE' 
-- First-set tokens: 'T_LBRACE' 
-- First-set rules: 
Status #0 - classTail => @ ('T_LBRACE') classElements ('T_RBRACE')
  To #1:  ('T_LBRACE')
Status #1 - classTail => ('T_LBRACE') @ classElements ('T_RBRACE')
  To #2:  classElements
Status #2 - classTail => ('T_LBRACE') classElements @ ('T_RBRACE')
  To #3:  ('T_RBRACE')
Status #3 [FINAL] - classTail => ('T_LBRACE') classElements ('T_RBRACE') @

** Rule: coalesceExpression => [ coalesceExpression 'T_COALESCE' ] additiveExpression
-- Tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF K_NEW K_VOID #NUMBER# 'T_LBRACE' K_DELETE K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER #STRING# K_FALSE 
-- First-set tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_TYPEOF K_NEW K_THIS #NUMBER# 'T_LBRACE' K_TRUE 'T_LPARAN' K_VOID #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER K_DELETE #STRING# K_FALSE 
-- First-set rules: additiveExpression coalesceExpression 
Status #0 - coalesceExpression => [ @ coalesceExpression 'T_COALESCE' ] additiveExpression
  To #1:  coalesceExpression
  To #2:  additiveExpression
Status #1 - coalesceExpression => [ coalesceExpression @ 'T_COALESCE' ] additiveExpression
  To #3:  'T_COALESCE'
Status #2 [FINAL] - coalesceExpression => [ coalesceExpression 'T_COALESCE' ] additiveExpression @
Status #3 - coalesceExpression => [ coalesceExpression 'T_COALESCE' @ ] additiveExpression
  To #2:  additiveExpression

** Rule: computedPropertyExpressionAssignment => ('T_LPARAN') singleExpression ('T_RPARAN') ('T_COLON') singleExpression
-- Tokens: 'T_LPARAN' 
-- First-set tokens: 'T_LPARAN' 
-- First-set rules: 
Status #0 - computedPropertyExpressionAssignment => @ ('T_LPARAN') singleExpression ('T_RPARAN') ('T_COLON') singleExpression
  To #1:  ('T_LPARAN')
Status #1 - computedPropertyExpressionAssignment => ('T_LPARAN') @ singleExpression ('T_RPARAN') ('T_COLON') singleExpression
  To #2:  singleExpression
Status #2 - computedPropertyExpressionAssignment => ('T_LPARAN') singleExpression @ ('T_RPARAN') ('T_COLON') singleExpression
  To #3:  ('T_RPARAN')
Status #3 - computedPropertyExpressionAssignment => ('T_LPARAN') singleExpression ('T_RPARAN') @ ('T_COLON') singleExpression
  To #4:  ('T_COLON')
Status #4 - computedPropertyExpressionAssignment => ('T_LPARAN') singleExpression ('T_RPARAN') ('T_COLON') @ singleExpression
  To #5:  singleExpression
Status #5 [FINAL] - computedPropertyExpressionAssignment => ('T_LPARAN') singleExpression ('T_RPARAN') ('T_COLON') singleExpression @

** Rule: continueStatement => K_CONTINUE [ #ID# ] [ eos ]
-- Tokens: K_CONTINUE 
-- First-set tokens: K_CONTINUE 
-- First-set rules: 
Status #0 - continueStatement => @ K_CONTINUE [ #ID# ] [ eos ]
  To #1:  K_CONTINUE
Status #1 [FINAL] - continueStatement => K_CONTINUE @ [ #ID# ] [ eos ]
  To #2:  eos
  To #3:  #ID#
Status #2 [FINAL] - continueStatement => K_CONTINUE [ #ID# ] [ eos @ ]
Status #3 [FINAL] - continueStatement => K_CONTINUE [ #ID# @ ] [ eos ]
  To #2:  eos

** Rule: debuggerStatement => K_DEBUGGER [ eos ]
-- Tokens: K_DEBUGGER 
-- First-set tokens: K_DEBUGGER 
-- First-set rules: 
Status #0 - debuggerStatement => @ K_DEBUGGER [ eos ]
  To #1:  K_DEBUGGER
Status #1 [FINAL] - debuggerStatement => K_DEBUGGER @ [ eos ]
  To #2:  eos
Status #2 [FINAL] - debuggerStatement => K_DEBUGGER [ eos @ ]

** Rule: declaration => ( variableStatement | classDeclaration | functionDeclaration )
-- Tokens: K_FUNCTION K_CLASS K_VAR 
-- First-set tokens: K_VAR K_CLASS K_FUNCTION 
-- First-set rules: functionDeclaration classDeclaration variableStatement 
Status #0 - declaration => @ ( variableStatement | classDeclaration | functionDeclaration )
  To #1:  functionDeclaration
  To #2:  variableStatement
  To #3:  classDeclaration
Status #1 [FINAL] - declaration => ( variableStatement | classDeclaration | functionDeclaration @ )
Status #2 [FINAL] - declaration => ( variableStatement @ | classDeclaration | functionDeclaration )
Status #3 [FINAL] - declaration => ( variableStatement | classDeclaration @ | functionDeclaration )

** Rule: defaultClause => K_DEFAULT 'T_COLON' [ statementList ]
-- Tokens: K_DEFAULT 
-- First-set tokens: K_DEFAULT 
-- First-set rules: 
Status #0 - defaultClause => @ K_DEFAULT 'T_COLON' [ statementList ]
  To #1:  K_DEFAULT
Status #1 - defaultClause => K_DEFAULT @ 'T_COLON' [ statementList ]
  To #2:  'T_COLON'
Status #2 [FINAL] - defaultClause => K_DEFAULT 'T_COLON' @ [ statementList ]
  To #3:  statementList
Status #3 [FINAL] - defaultClause => K_DEFAULT 'T_COLON' [ statementList @ ]

** Rule: deleteExpression => ( K_DELETE deleteExpression | newExpression )
-- Tokens: K_DELETE K_NEW #REGEX# K_SUPER #NUMBER# 'T_LBRACE' K_TRUE 'T_LPARAN' #ID# K_FALSE K_NULL #STRING# 'T_LSQUARE' K_FUNCTION K_CLASS K_THIS 
-- First-set tokens: K_THIS K_CLASS K_FUNCTION 'T_LSQUARE' #STRING# K_NULL K_FALSE #ID# 'T_LPARAN' K_TRUE 'T_LBRACE' #NUMBER# K_SUPER #REGEX# K_NEW K_DELETE 
-- First-set rules: newExpression 
Status #0 - deleteExpression => @ ( K_DELETE deleteExpression | newExpression )
  To #1:  newExpression
  To #2:  K_DELETE
Status #1 [FINAL] - deleteExpression => ( K_DELETE deleteExpression | newExpression @ )
Status #2 - deleteExpression => ( K_DELETE @ deleteExpression | newExpression )
  To #3:  deleteExpression
Status #3 [FINAL] - deleteExpression => ( K_DELETE deleteExpression @ | newExpression )

** Rule: doStatement => K_DO statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
-- Tokens: K_DO 
-- First-set tokens: K_DO 
-- First-set rules: 
Status #0 - doStatement => @ K_DO statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
  To #1:  K_DO
Status #1 - doStatement => K_DO @ statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
  To #2:  statement
Status #2 - doStatement => K_DO statement @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
  To #3:  K_WHILE
Status #3 - doStatement => K_DO statement K_WHILE @ ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
  To #4:  ('T_LPARAN')
Status #4 - doStatement => K_DO statement K_WHILE ('T_LPARAN') @ expressionSequence ('T_RPARAN') [ eos ]
  To #5:  expressionSequence
Status #5 - doStatement => K_DO statement K_WHILE ('T_LPARAN') expressionSequence @ ('T_RPARAN') [ eos ]
  To #6:  ('T_RPARAN')
Status #6 [FINAL] - doStatement => K_DO statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ [ eos ]
  To #7:  eos
Status #7 [FINAL] - doStatement => K_DO statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos @ ]

** Rule: elementList => [ elementList ('T_COMMA') ] arrayElement
-- Tokens: 'T_ELLIPSIS' 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF K_NEW K_VOID #NUMBER# 'T_LBRACE' K_DELETE K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER #STRING# K_FALSE 
-- First-set tokens: 'T_ELLIPSIS' 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_TYPEOF K_NEW K_THIS #NUMBER# 'T_LBRACE' K_TRUE 'T_LPARAN' K_VOID #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER K_DELETE #STRING# K_FALSE 
-- First-set rules: arrayElement elementList 
Status #0 - elementList => [ @ elementList ('T_COMMA') ] arrayElement
  To #1:  elementList
  To #2:  arrayElement
Status #1 - elementList => [ elementList @ ('T_COMMA') ] arrayElement
  To #3:  ('T_COMMA')
Status #2 [FINAL] - elementList => [ elementList ('T_COMMA') ] arrayElement @
Status #3 - elementList => [ elementList ('T_COMMA') @ ] arrayElement
  To #2:  arrayElement

** Rule: emptyStatement => 'T_SEMI'
-- Tokens: 'T_SEMI' 
-- First-set tokens: 'T_SEMI' 
-- First-set rules: 
Status #0 - emptyStatement => @ 'T_SEMI'
  To #1:  'T_SEMI'
Status #1 [FINAL] - emptyStatement => 'T_SEMI' @

** Rule: eos => ( 'T_SEMI' | #END# )
-- Tokens: 'T_SEMI' #END# 
-- First-set tokens: #END# 'T_SEMI' 
-- First-set rules: 
Status #0 - eos => @ ( 'T_SEMI' | #END# )
  To #1:  #END#
  To #2:  'T_SEMI'
Status #1 [FINAL] - eos => ( 'T_SEMI' | #END# @ )
Status #2 [FINAL] - eos => ( 'T_SEMI' @ | #END# )

** Rule: equalityExpression => [ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression
-- Tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF K_NEW K_VOID #NUMBER# 'T_LBRACE' K_DELETE K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER #STRING# K_FALSE 
-- First-set tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_TYPEOF K_NEW K_THIS #NUMBER# 'T_LBRACE' K_TRUE 'T_LPARAN' K_VOID #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER K_DELETE #STRING# K_FALSE 
-- First-set rules: inExpression equalityExpression 
Status #0 - equalityExpression => [ @ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression
  To #1:  equalityExpression
  To #2:  inExpression
Status #1 - equalityExpression => [ equalityExpression @ ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression
  To #3:  'T_FNOT_EQUAL'
  To #4:  'T_EQUAL'
  To #5:  'T_NOT_EQUAL'
  To #6:  'T_FEQUAL'
Status #2 [FINAL] - equalityExpression => [ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression @
Status #3 - equalityExpression => [ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' @ ) ] inExpression
  To #2:  inExpression
Status #4 - equalityExpression => [ equalityExpression ( 'T_EQUAL' @ | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression
  To #2:  inExpression
Status #5 - equalityExpression => [ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' @ | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression
  To #2:  inExpression
Status #6 - equalityExpression => [ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' @ | 'T_FNOT_EQUAL' ) ] inExpression
  To #2:  inExpression

** Rule: expressionSequence => [ expressionSequence ('T_COMMA') ] singleExpression
-- Tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF K_NEW K_VOID #NUMBER# 'T_LBRACE' K_DELETE K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER #STRING# K_FALSE 
-- First-set tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_TYPEOF K_NEW K_THIS #NUMBER# 'T_LBRACE' K_TRUE 'T_LPARAN' K_VOID #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER K_DELETE #STRING# K_FALSE 
-- First-set rules: singleExpression expressionSequence 
Status #0 - expressionSequence => [ @ expressionSequence ('T_COMMA') ] singleExpression
  To #1:  expressionSequence
  To #2:  singleExpression
Status #1 - expressionSequence => [ expressionSequence @ ('T_COMMA') ] singleExpression
  To #3:  ('T_COMMA')
Status #2 [FINAL] - expressionSequence => [ expressionSequence ('T_COMMA') ] singleExpression @
Status #3 - expressionSequence => [ expressionSequence ('T_COMMA') @ ] singleExpression
  To #2:  singleExpression

** Rule: expressionStatement => expressionSequence [ eos ]
-- Tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF K_NEW K_VOID #NUMBER# 'T_LBRACE' K_DELETE K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER #STRING# K_FALSE 
-- First-set tokens: K_FALSE #STRING# K_SUPER K_CLASS #REGEX# 'T_LSQUARE' #ID# 'T_LPARAN' K_TRUE K_DELETE 'T_LBRACE' #NUMBER# K_VOID K_NEW K_TYPEOF K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 
-- First-set rules: expressionSequence 
Status #0 - expressionStatement => @ expressionSequence [ eos ]
  To #1:  expressionSequence
Status #1 [FINAL] - expressionStatement => expressionSequence @ [ eos ]
  To #2:  eos
Status #2 [FINAL] - expressionStatement => expressionSequence [ eos @ ]

** Rule: finallyProduction => K_FINALLY block
-- Tokens: K_FINALLY 
-- First-set tokens: K_FINALLY 
-- First-set rules: 
Status #0 - finallyProduction => @ K_FINALLY block
  To #1:  K_FINALLY
Status #1 - finallyProduction => K_FINALLY @ block
  To #2:  block
Status #2 [FINAL] - finallyProduction => K_FINALLY block @

** Rule: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement
-- Tokens: K_FOR 
-- First-set tokens: K_FOR 
-- First-set rules: 
Status #0 - forInStatement => @ K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement
  To #1:  K_FOR
Status #1 - forInStatement => K_FOR @ ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement
  To #2:  ('T_LPARAN')
Status #2 - forInStatement => K_FOR ('T_LPARAN') @ [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement
  To #3:  K_IN
  To #4:  singleExpression
  To #5:  K_VAR
Status #3 - forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN @ expressionSequence ('T_RPARAN') statement
  To #6:  expressionSequence
Status #4 - forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression @ | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement
  To #3:  K_IN
Status #5 - forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR @ variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement
  To #7:  variableDeclarationList
Status #6 - forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence @ ('T_RPARAN') statement
  To #8:  ('T_RPARAN')
Status #7 - forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList @ ) ] K_IN expressionSequence ('T_RPARAN') statement
  To #3:  K_IN
Status #8 - forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') @ statement
  To #9:  statement
Status #9 [FINAL] - forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement @

** Rule: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
-- Tokens: K_FOR 
-- First-set tokens: K_FOR 
-- First-set rules: 
Status #0 - forStatement => @ K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
  To #1:  K_FOR
Status #1 - forStatement => K_FOR @ ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
  To #2:  ('T_LPARAN')
Status #2 - forStatement => K_FOR ('T_LPARAN') @ [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
  To #3:  'T_SEMI'
  To #4:  expressionSequence
  To #5:  K_VAR
Status #3 - forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' @ [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
  To #6:  'T_SEMI'
  To #7:  expressionSequence
Status #4 - forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence @ | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
  To #3:  'T_SEMI'
Status #5 - forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR @ variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
  To #8:  variableDeclarationList
Status #6 - forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' @ [ expressionSequence ] ('T_RPARAN') statement
  To #9:  ('T_RPARAN')
  To #10:  expressionSequence
Status #7 - forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence @ ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
  To #6:  'T_SEMI'
Status #8 - forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList @ ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
  To #3:  'T_SEMI'
Status #9 - forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') @ statement
  To #11:  statement
Status #10 - forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence @ ] ('T_RPARAN') statement
  To #9:  ('T_RPARAN')
Status #11 [FINAL] - forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement @

** Rule: formalParameterArg => assignable
-- Tokens: #ID# 'T_LBRACE' 'T_LSQUARE' 
-- First-set tokens: 'T_LSQUARE' 'T_LBRACE' #ID# 
-- First-set rules: assignable 
Status #0 - formalParameterArg => @ assignable
  To #1:  assignable
Status #1 [FINAL] - formalParameterArg => assignable @

** Rule: formalParameterList => [ formalParameterList ('T_COMMA') ] assignable
-- Tokens: #ID# 'T_LBRACE' 'T_LSQUARE' 
-- First-set tokens: #ID# 'T_LBRACE' 'T_LSQUARE' 
-- First-set rules: assignable formalParameterList 
Status #0 - formalParameterList => [ @ formalParameterList ('T_COMMA') ] assignable
  To #1:  formalParameterList
  To #2:  assignable
Status #1 - formalParameterList => [ formalParameterList @ ('T_COMMA') ] assignable
  To #3:  ('T_COMMA')
Status #2 [FINAL] - formalParameterList => [ formalParameterList ('T_COMMA') ] assignable @
Status #3 - formalParameterList => [ formalParameterList ('T_COMMA') @ ] assignable
  To #2:  assignable

** Rule: functionBody => [ functionBody ] sourceElements
-- Tokens: K_TRY K_WITH 'T_LOG_NOT' K_TYPEOF #NUMBER# K_DEBUGGER K_THROW #ID# K_VAR 'T_LSQUARE' K_RETURN K_CONTINUE K_FUNCTION K_SWITCH 'T_SEMI' #STRING# 'T_ADD' K_CLASS 'T_BIT_NOT' K_TRUE 'T_SUB' 'T_DEC' K_NULL K_THIS K_VOID K_DELETE #REGEX# K_SUPER K_FALSE K_IF 'T_LPARAN' K_FOR K_NEW K_WHILE K_DO 'T_LBRACE' 'T_INC' K_BREAK 
-- First-set tokens: K_WITH 'T_LOG_NOT' K_TYPEOF #NUMBER# K_DEBUGGER K_THROW K_VAR K_TRY 'T_LSQUARE' K_RETURN K_CONTINUE K_SWITCH 'T_SEMI' #STRING# 'T_ADD' 'T_BIT_NOT' K_TRUE 'T_SUB' #ID# 'T_DEC' K_NULL K_THIS K_FUNCTION K_DELETE K_VOID #REGEX# K_FALSE K_CLASS K_IF K_SUPER 'T_LPARAN' K_FOR K_NEW K_WHILE K_DO 'T_LBRACE' 'T_INC' K_BREAK 
-- First-set rules: sourceElements functionBody 
Status #0 - functionBody => [ @ functionBody ] sourceElements
  To #1:  functionBody
  To #2:  sourceElements
Status #1 - functionBody => [ functionBody @ ] sourceElements
  To #2:  sourceElements
Status #2 [FINAL] - functionBody => [ functionBody ] sourceElements @

** Rule: functionDecl => functionDeclaration
-- Tokens: K_FUNCTION 
-- First-set tokens: K_FUNCTION 
-- First-set rules: functionDeclaration 
Status #0 - functionDecl => @ functionDeclaration
  To #1:  functionDeclaration
Status #1 [FINAL] - functionDecl => functionDeclaration @

** Rule: functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
-- Tokens: K_FUNCTION 
-- First-set tokens: K_FUNCTION 
-- First-set rules: 
Status #0 - functionDeclaration => @ K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
  To #1:  K_FUNCTION
Status #1 - functionDeclaration => K_FUNCTION @ #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
  To #2:  #ID#
Status #2 - functionDeclaration => K_FUNCTION #ID# @ ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
  To #3:  ('T_LPARAN')
Status #3 - functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') @ [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
  To #4:  ('T_RPARAN')
  To #5:  formalParameterList
Status #4 - functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') @ ('T_LBRACE') [ functionBody ] ('T_RBRACE')
  To #6:  ('T_LBRACE')
Status #5 - functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList @ ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
  To #4:  ('T_RPARAN')
Status #6 - functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') @ [ functionBody ] ('T_RBRACE')
  To #7:  ('T_RBRACE')
  To #8:  functionBody
Status #7 [FINAL] - functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE') @
Status #8 - functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody @ ] ('T_RBRACE')
  To #7:  ('T_RBRACE')

** Rule: functionExpression => ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
-- Tokens: K_SUPER #NUMBER# 'T_LBRACE' K_TRUE 'T_LPARAN' #ID# #REGEX# K_FALSE K_NULL #STRING# 'T_LSQUARE' K_FUNCTION K_CLASS K_THIS 
-- First-set tokens: K_THIS K_CLASS K_FUNCTION 'T_LSQUARE' #STRING# K_FALSE #REGEX# #ID# 'T_LPARAN' K_TRUE K_NULL 'T_LBRACE' #NUMBER# K_SUPER 
-- First-set rules: objectLiteralExpression arrayLiteralExpression literalExpression superExpression anonymousFunction classExpression parenthesizedExpression thisExpression identifierExpression 
Status #0 - functionExpression => @ ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
  To #1:  parenthesizedExpression
  To #2:  anonymousFunction
  To #3:  classExpression
  To #4:  thisExpression
  To #5:  identifierExpression
  To #6:  superExpression
  To #7:  literalExpression
  To #8:  arrayLiteralExpression
  To #9:  objectLiteralExpression
Status #1 [FINAL] - functionExpression => ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression @ )
Status #2 [FINAL] - functionExpression => ( anonymousFunction @ | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
Status #3 [FINAL] - functionExpression => ( anonymousFunction | classExpression @ | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
Status #4 [FINAL] - functionExpression => ( anonymousFunction | classExpression | thisExpression @ | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
Status #5 [FINAL] - functionExpression => ( anonymousFunction | classExpression | thisExpression | identifierExpression @ | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
Status #6 [FINAL] - functionExpression => ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression @ | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
Status #7 [FINAL] - functionExpression => ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression @ | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
Status #8 [FINAL] - functionExpression => ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression @ | objectLiteralExpression | parenthesizedExpression )
Status #9 [FINAL] - functionExpression => ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression @ | parenthesizedExpression )

** Rule: identifierExpression => #ID#
-- Tokens: #ID# 
-- First-set tokens: #ID# 
-- First-set rules: 
Status #0 - identifierExpression => @ #ID#
  To #1:  #ID#
Status #1 [FINAL] - identifierExpression => #ID# @

** Rule: identifierName => ( #ID# | reservedWord )
-- Tokens: #ID# K_CLASS K_FALSE K_TRUE K_DEFAULT K_DEBUGGER K_VAR K_WHILE K_SWITCH K_CONTINUE K_VOID K_LET K_IN K_RETURN K_TYPEOF K_FINALLY K_NEW K_FOR K_INSTANCEOF K_CASE K_CATCH K_ELSE K_THIS K_IF K_BREAK K_THROW K_DELETE K_WITH K_DO K_FUNCTION K_TRY K_SUPER 
-- First-set tokens: K_SUPER K_TRY K_FUNCTION K_DO K_WITH K_DELETE K_THROW K_BREAK K_IF K_THIS K_ELSE K_CATCH K_CASE K_INSTANCEOF K_FOR K_NEW K_FINALLY K_TYPEOF K_RETURN K_IN K_LET K_VOID K_CONTINUE K_SWITCH K_WHILE K_VAR K_DEBUGGER K_DEFAULT K_TRUE K_FALSE K_CLASS #ID# 
-- First-set rules: reservedWord 
Status #0 - identifierName => @ ( #ID# | reservedWord )
  To #1:  reservedWord
  To #2:  #ID#
Status #1 [FINAL] - identifierName => ( #ID# | reservedWord @ )
Status #2 [FINAL] - identifierName => ( #ID# @ | reservedWord )

** Rule: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement ]
-- Tokens: K_IF 
-- First-set tokens: K_IF 
-- First-set rules: 
Status #0 - ifStatement => @ K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement ]
  To #1:  K_IF
Status #1 - ifStatement => K_IF @ ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement ]
  To #2:  ('T_LPARAN')
Status #2 - ifStatement => K_IF ('T_LPARAN') @ expressionSequence ('T_RPARAN') statement [ K_ELSE statement ]
  To #3:  expressionSequence
Status #3 - ifStatement => K_IF ('T_LPARAN') expressionSequence @ ('T_RPARAN') statement [ K_ELSE statement ]
  To #4:  ('T_RPARAN')
Status #4 - ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement [ K_ELSE statement ]
  To #5:  statement
Status #5 [FINAL] - ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement @ [ K_ELSE statement ]
  To #6:  K_ELSE
Status #6 - ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE @ statement ]
  To #7:  statement
Status #7 [FINAL] - ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement @ ]

** Rule: inExpression => [ inExpression K_IN ] instanceofExpression
-- Tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF K_NEW K_VOID #NUMBER# 'T_LBRACE' K_DELETE K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER #STRING# K_FALSE 
-- First-set tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_TYPEOF K_NEW K_THIS #NUMBER# 'T_LBRACE' K_TRUE 'T_LPARAN' K_VOID #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER K_DELETE #STRING# K_FALSE 
-- First-set rules: instanceofExpression inExpression 
Status #0 - inExpression => [ @ inExpression K_IN ] instanceofExpression
  To #1:  inExpression
  To #2:  instanceofExpression
Status #1 - inExpression => [ inExpression @ K_IN ] instanceofExpression
  To #3:  K_IN
Status #2 [FINAL] - inExpression => [ inExpression K_IN ] instanceofExpression @
Status #3 - inExpression => [ inExpression K_IN @ ] instanceofExpression
  To #2:  instanceofExpression

** Rule: instanceofExpression => [ instanceofExpression K_INSTANCEOF ] relationalExpression
-- Tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF K_NEW K_VOID #NUMBER# 'T_LBRACE' K_DELETE K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER #STRING# K_FALSE 
-- First-set tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_TYPEOF K_NEW K_THIS #NUMBER# 'T_LBRACE' K_TRUE 'T_LPARAN' K_VOID #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER K_DELETE #STRING# K_FALSE 
-- First-set rules: relationalExpression instanceofExpression 
Status #0 - instanceofExpression => [ @ instanceofExpression K_INSTANCEOF ] relationalExpression
  To #1:  instanceofExpression
  To #2:  relationalExpression
Status #1 - instanceofExpression => [ instanceofExpression @ K_INSTANCEOF ] relationalExpression
  To #3:  K_INSTANCEOF
Status #2 [FINAL] - instanceofExpression => [ instanceofExpression K_INSTANCEOF ] relationalExpression @
Status #3 - instanceofExpression => [ instanceofExpression K_INSTANCEOF @ ] relationalExpression
  To #2:  relationalExpression

** Rule: iterationStatement => ( doStatement | whileStatement | forStatement | forInStatement )
-- Tokens: K_FOR K_WHILE K_DO 
-- First-set tokens: K_DO K_WHILE K_FOR 
-- First-set rules: forInStatement forStatement whileStatement doStatement 
Status #0 - iterationStatement => @ ( doStatement | whileStatement | forStatement | forInStatement )
  To #1:  forInStatement
  To #2:  doStatement
  To #3:  whileStatement
  To #4:  forStatement
Status #1 [FINAL] - iterationStatement => ( doStatement | whileStatement | forStatement | forInStatement @ )
Status #2 [FINAL] - iterationStatement => ( doStatement @ | whileStatement | forStatement | forInStatement )
Status #3 [FINAL] - iterationStatement => ( doStatement | whileStatement @ | forStatement | forInStatement )
Status #4 [FINAL] - iterationStatement => ( doStatement | whileStatement | forStatement @ | forInStatement )

** Rule: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
-- Tokens: K_DEFAULT K_DEBUGGER K_SWITCH K_CONTINUE K_VOID K_LET K_RETURN K_TYPEOF K_VAR K_FINALLY K_INSTANCEOF K_NEW K_CASE K_CATCH K_ELSE K_FOR K_THIS K_IF K_BREAK K_THROW K_DELETE K_WITH K_IN K_DO K_FUNCTION K_TRY K_CLASS K_WHILE K_SUPER 
-- First-set tokens: K_SUPER K_CLASS K_TRY K_IN K_DELETE K_THROW K_THIS K_ELSE K_WHILE K_CASE K_FUNCTION K_CATCH K_DO K_NEW K_INSTANCEOF K_FINALLY K_BREAK K_VAR K_TYPEOF K_RETURN K_LET K_VOID K_CONTINUE K_FOR K_IF K_SWITCH K_DEBUGGER K_WITH K_DEFAULT 
-- First-set rules: 
Status #0 - keyword => @ ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
  To #1:  K_LET
  To #2:  K_BREAK
  To #3:  K_DO
  To #4:  K_INSTANCEOF
  To #5:  K_TYPEOF
  To #6:  K_CASE
  To #7:  K_ELSE
  To #8:  K_NEW
  To #9:  K_VAR
  To #10:  K_CATCH
  To #11:  K_FINALLY
  To #12:  K_RETURN
  To #13:  K_VOID
  To #14:  K_CONTINUE
  To #15:  K_FOR
  To #16:  K_SWITCH
  To #17:  K_WHILE
  To #18:  K_DEBUGGER
  To #19:  K_FUNCTION
  To #20:  K_THIS
  To #21:  K_WITH
  To #22:  K_DEFAULT
  To #23:  K_IF
  To #24:  K_THROW
  To #25:  K_DELETE
  To #26:  K_IN
  To #27:  K_TRY
  To #28:  K_CLASS
  To #29:  K_SUPER
Status #1 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET @ )
Status #2 [FINAL] - keyword => ( K_BREAK @ | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #3 [FINAL] - keyword => ( K_BREAK | K_DO @ | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #4 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF @ | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #5 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF @ | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #6 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE @ | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #7 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE @ | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #8 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW @ | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #9 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR @ | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #10 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH @ | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #11 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY @ | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #12 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN @ | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #13 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID @ | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #14 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE @ | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #15 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR @ | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #16 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH @ | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #17 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE @ | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #18 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER @ | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #19 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION @ | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #20 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS @ | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #21 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH @ | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #22 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT @ | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #23 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF @ | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #24 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW @ | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #25 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE @ | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #26 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN @ | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #27 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY @ | K_CLASS | K_SUPER | K_LET )
Status #28 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS @ | K_SUPER | K_LET )
Status #29 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER @ | K_LET )

** Rule: labelledStatement => #ID# 'T_COLON' statement
-- Tokens: #ID# 
-- First-set tokens: #ID# 
-- First-set rules: 
Status #0 - labelledStatement => @ #ID# 'T_COLON' statement
  To #1:  #ID#
Status #1 - labelledStatement => #ID# @ 'T_COLON' statement
  To #2:  'T_COLON'
Status #2 - labelledStatement => #ID# 'T_COLON' @ statement
  To #3:  statement
Status #3 [FINAL] - labelledStatement => #ID# 'T_COLON' statement @

** Rule: literal => ( K_NULL | K_TRUE | K_FALSE | #STRING# | #REGEX# | #NUMBER# )
-- Tokens: #STRING# K_FALSE #REGEX# K_TRUE K_NULL #NUMBER# 
-- First-set tokens: #NUMBER# K_NULL K_TRUE #REGEX# K_FALSE #STRING# 
-- First-set rules: 
Status #0 - literal => @ ( K_NULL | K_TRUE | K_FALSE | #STRING# | #REGEX# | #NUMBER# )
  To #1:  #NUMBER#
  To #2:  K_NULL
  To #3:  K_TRUE
  To #4:  K_FALSE
  To #5:  #STRING#
  To #6:  #REGEX#
Status #1 [FINAL] - literal => ( K_NULL | K_TRUE | K_FALSE | #STRING# | #REGEX# | #NUMBER# @ )
Status #2 [FINAL] - literal => ( K_NULL @ | K_TRUE | K_FALSE | #STRING# | #REGEX# | #NUMBER# )
Status #3 [FINAL] - literal => ( K_NULL | K_TRUE @ | K_FALSE | #STRING# | #REGEX# | #NUMBER# )
Status #4 [FINAL] - literal => ( K_NULL | K_TRUE | K_FALSE @ | #STRING# | #REGEX# | #NUMBER# )
Status #5 [FINAL] - literal => ( K_NULL | K_TRUE | K_FALSE | #STRING# @ | #REGEX# | #NUMBER# )
Status #6 [FINAL] - literal => ( K_NULL | K_TRUE | K_FALSE | #STRING# | #REGEX# @ | #NUMBER# )

** Rule: literalExpression => literal
-- Tokens: #STRING# K_FALSE #REGEX# K_TRUE K_NULL #NUMBER# 
-- First-set tokens: #NUMBER# K_NULL K_TRUE #REGEX# K_FALSE #STRING# 
-- First-set rules: literal 
Status #0 - literalExpression => @ literal
  To #1:  literal
Status #1 [FINAL] - literalExpression => literal @

** Rule: logicalAndExpression => [ logicalAndExpression 'T_LOG_AND' ] bitOrExpression
-- Tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF K_NEW K_VOID #NUMBER# 'T_LBRACE' K_DELETE K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER #STRING# K_FALSE 
-- First-set tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_TYPEOF K_NEW K_THIS #NUMBER# 'T_LBRACE' K_TRUE 'T_LPARAN' K_VOID #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER K_DELETE #STRING# K_FALSE 
-- First-set rules: bitOrExpression logicalAndExpression 
Status #0 - logicalAndExpression => [ @ logicalAndExpression 'T_LOG_AND' ] bitOrExpression
  To #1:  logicalAndExpression
  To #2:  bitOrExpression
Status #1 - logicalAndExpression => [ logicalAndExpression @ 'T_LOG_AND' ] bitOrExpression
  To #3:  'T_LOG_AND'
Status #2 [FINAL] - logicalAndExpression => [ logicalAndExpression 'T_LOG_AND' ] bitOrExpression @
Status #3 - logicalAndExpression => [ logicalAndExpression 'T_LOG_AND' @ ] bitOrExpression
  To #2:  bitOrExpression

** Rule: logicalOrExpression => [ logicalOrExpression 'T_LOG_OR' ] logicalAndExpression
-- Tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF K_NEW K_VOID #NUMBER# 'T_LBRACE' K_DELETE K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER #STRING# K_FALSE 
-- First-set tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_TYPEOF K_NEW K_THIS #NUMBER# 'T_LBRACE' K_TRUE 'T_LPARAN' K_VOID #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER K_DELETE #STRING# K_FALSE 
-- First-set rules: logicalAndExpression logicalOrExpression 
Status #0 - logicalOrExpression => [ @ logicalOrExpression 'T_LOG_OR' ] logicalAndExpression
  To #1:  logicalOrExpression
  To #2:  logicalAndExpression
Status #1 - logicalOrExpression => [ logicalOrExpression @ 'T_LOG_OR' ] logicalAndExpression
  To #3:  'T_LOG_OR'
Status #2 [FINAL] - logicalOrExpression => [ logicalOrExpression 'T_LOG_OR' ] logicalAndExpression @
Status #3 - logicalOrExpression => [ logicalOrExpression 'T_LOG_OR' @ ] logicalAndExpression
  To #2:  logicalAndExpression

** Rule: memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' [ 'T_SHARP' ] identifierName
-- Tokens: 'T_QUERY' 'T_DOT' 
-- First-set tokens: 'T_DOT' 'T_QUERY' 
-- First-set rules: memberDotExpression 
Status #0 - memberDotExpression => [ @ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' [ 'T_SHARP' ] identifierName
  To #1:  memberDotExpression
  To #2:  'T_QUERY'
  To #3:  'T_DOT'
Status #1 - memberDotExpression => [ memberDotExpression @ ] [ 'T_QUERY' ] 'T_DOT' [ 'T_SHARP' ] identifierName
  To #3:  'T_DOT'
  To #2:  'T_QUERY'
Status #2 - memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' @ ] 'T_DOT' [ 'T_SHARP' ] identifierName
  To #3:  'T_DOT'
Status #3 - memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' @ [ 'T_SHARP' ] identifierName
  To #4:  identifierName
  To #5:  'T_SHARP'
Status #4 [FINAL] - memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' [ 'T_SHARP' ] identifierName @
Status #5 - memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' [ 'T_SHARP' @ ] identifierName
  To #4:  identifierName

** Rule: memberIndexExpression => [ memberIndexExpression ] 'T_LSQUARE' expressionSequence 'T_RSQUARE'
-- Tokens: 'T_LSQUARE' 
-- First-set tokens: 'T_LSQUARE' 
-- First-set rules: memberIndexExpression 
Status #0 - memberIndexExpression => [ @ memberIndexExpression ] 'T_LSQUARE' expressionSequence 'T_RSQUARE'
  To #1:  memberIndexExpression
  To #2:  'T_LSQUARE'
Status #1 - memberIndexExpression => [ memberIndexExpression @ ] 'T_LSQUARE' expressionSequence 'T_RSQUARE'
  To #2:  'T_LSQUARE'
Status #2 - memberIndexExpression => [ memberIndexExpression ] 'T_LSQUARE' @ expressionSequence 'T_RSQUARE'
  To #3:  expressionSequence
Status #3 - memberIndexExpression => [ memberIndexExpression ] 'T_LSQUARE' expressionSequence @ 'T_RSQUARE'
  To #4:  'T_RSQUARE'
Status #4 [FINAL] - memberIndexExpression => [ memberIndexExpression ] 'T_LSQUARE' expressionSequence 'T_RSQUARE' @

** Rule: methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
-- Tokens: 'T_SHARP' K_CASE #NUMBER# 'T_LSQUARE' #STRING# K_THIS #ID# K_CLASS K_FALSE K_TRUE K_DEFAULT K_DEBUGGER K_VAR K_WHILE K_SWITCH K_CONTINUE K_VOID K_LET K_IN K_RETURN K_TYPEOF K_FINALLY K_NEW K_FOR K_INSTANCEOF K_CATCH K_ELSE K_IF K_BREAK K_THROW K_DELETE K_WITH K_DO K_FUNCTION K_TRY K_SUPER 
-- First-set tokens: K_SUPER K_TRY K_FUNCTION K_DO K_WITH K_DELETE K_THROW K_BREAK K_IF K_ELSE K_CATCH K_INSTANCEOF K_FOR K_NEW K_FINALLY K_TYPEOF K_RETURN K_IN K_LET K_VOID K_CONTINUE K_SWITCH K_WHILE K_VAR K_DEBUGGER K_DEFAULT K_TRUE K_FALSE K_CLASS #ID# K_THIS #STRING# 'T_LSQUARE' #NUMBER# K_CASE 'T_SHARP' 
-- First-set rules: propertyName 
Status #0 - methodDefinition => [ @ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
  To #1:  'T_SHARP'
  To #2:  propertyName
Status #1 - methodDefinition => [ 'T_SHARP' @ ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
  To #2:  propertyName
Status #2 - methodDefinition => [ 'T_SHARP' ] propertyName @ ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
  To #3:  ('T_LPARAN')
Status #3 - methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') @ [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
  To #4:  ('T_RPARAN')
  To #5:  formalParameterList
Status #4 - methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') @ ('T_LBRACE') [ functionBody ] ('T_RBRACE')
  To #6:  ('T_LBRACE')
Status #5 - methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList @ ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
  To #4:  ('T_RPARAN')
Status #6 - methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') @ [ functionBody ] ('T_RBRACE')
  To #7:  ('T_RBRACE')
  To #8:  functionBody
Status #7 [FINAL] - methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE') @
Status #8 - methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody @ ] ('T_RBRACE')
  To #7:  ('T_RBRACE')

** Rule: multiplicativeExpression => [ multiplicativeExpression ( 'T_MUL' | 'T_DIV' | 'T_MOD' ) ] powerExpression
-- Tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF K_NEW K_VOID #NUMBER# 'T_LBRACE' K_DELETE K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER #STRING# K_FALSE 
-- First-set tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_TYPEOF K_NEW K_THIS #NUMBER# 'T_LBRACE' K_TRUE 'T_LPARAN' K_VOID #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER K_DELETE #STRING# K_FALSE 
-- First-set rules: powerExpression multiplicativeExpression 
Status #0 - multiplicativeExpression => [ @ multiplicativeExpression ( 'T_MUL' | 'T_DIV' | 'T_MOD' ) ] powerExpression
  To #1:  multiplicativeExpression
  To #2:  powerExpression
Status #1 - multiplicativeExpression => [ multiplicativeExpression @ ( 'T_MUL' | 'T_DIV' | 'T_MOD' ) ] powerExpression
  To #3:  'T_MOD'
  To #4:  'T_MUL'
  To #5:  'T_DIV'
Status #2 [FINAL] - multiplicativeExpression => [ multiplicativeExpression ( 'T_MUL' | 'T_DIV' | 'T_MOD' ) ] powerExpression @
Status #3 - multiplicativeExpression => [ multiplicativeExpression ( 'T_MUL' | 'T_DIV' | 'T_MOD' @ ) ] powerExpression
  To #2:  powerExpression
Status #4 - multiplicativeExpression => [ multiplicativeExpression ( 'T_MUL' @ | 'T_DIV' | 'T_MOD' ) ] powerExpression
  To #2:  powerExpression
Status #5 - multiplicativeExpression => [ multiplicativeExpression ( 'T_MUL' | 'T_DIV' @ | 'T_MOD' ) ] powerExpression
  To #2:  powerExpression

** Rule: newExpression => ( K_NEW singleExpression [ arguments ] | postfixExpression )
-- Tokens: K_NEW #REGEX# K_SUPER #NUMBER# 'T_LBRACE' K_TRUE 'T_LPARAN' #ID# K_FALSE K_NULL #STRING# 'T_LSQUARE' K_FUNCTION K_CLASS K_THIS 
-- First-set tokens: K_THIS K_CLASS K_FUNCTION 'T_LSQUARE' #STRING# K_NULL K_FALSE #ID# 'T_LPARAN' K_TRUE 'T_LBRACE' #NUMBER# K_SUPER #REGEX# K_NEW 
-- First-set rules: postfixExpression 
Status #0 - newExpression => @ ( K_NEW singleExpression [ arguments ] | postfixExpression )
  To #1:  postfixExpression
  To #2:  K_NEW
Status #1 [FINAL] - newExpression => ( K_NEW singleExpression [ arguments ] | postfixExpression @ )
Status #2 - newExpression => ( K_NEW @ singleExpression [ arguments ] | postfixExpression )
  To #3:  singleExpression
Status #3 [FINAL] - newExpression => ( K_NEW singleExpression @ [ arguments ] | postfixExpression )
  To #4:  arguments
Status #4 [FINAL] - newExpression => ( K_NEW singleExpression [ arguments @ ] | postfixExpression )

** Rule: notExpression => ( 'T_LOG_NOT' notExpression | bitNotExpression )
-- Tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF K_NEW K_VOID #NUMBER# 'T_LBRACE' K_DELETE K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER #STRING# K_FALSE 
-- First-set tokens: K_FALSE #STRING# K_SUPER K_CLASS #REGEX# 'T_LSQUARE' #ID# 'T_LPARAN' K_TRUE K_DELETE 'T_LBRACE' #NUMBER# K_VOID K_NEW K_TYPEOF K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 
-- First-set rules: bitNotExpression 
Status #0 - notExpression => @ ( 'T_LOG_NOT' notExpression | bitNotExpression )
  To #1:  bitNotExpression
  To #2:  'T_LOG_NOT'
Status #1 [FINAL] - notExpression => ( 'T_LOG_NOT' notExpression | bitNotExpression @ )
Status #2 - notExpression => ( 'T_LOG_NOT' @ notExpression | bitNotExpression )
  To #3:  notExpression
Status #3 [FINAL] - notExpression => ( 'T_LOG_NOT' notExpression @ | bitNotExpression )

** Rule: numericLiteral => #NUMBER#
-- Tokens: #NUMBER# 
-- First-set tokens: #NUMBER# 
-- First-set rules: 
Status #0 - numericLiteral => @ #NUMBER#
  To #1:  #NUMBER#
Status #1 [FINAL] - numericLiteral => #NUMBER# @

** Rule: objectLiteral => ('T_LBRACE') [ propertyAssignments ] [ ('T_COMMA') ] ('T_RBRACE')
-- Tokens: 'T_LBRACE' 
-- First-set tokens: 'T_LBRACE' 
-- First-set rules: 
Status #0 - objectLiteral => @ ('T_LBRACE') [ propertyAssignments ] [ ('T_COMMA') ] ('T_RBRACE')
  To #1:  ('T_LBRACE')
Status #1 - objectLiteral => ('T_LBRACE') @ [ propertyAssignments ] [ ('T_COMMA') ] ('T_RBRACE')
  To #2:  ('T_RBRACE')
  To #3:  propertyAssignments
  To #4:  ('T_COMMA')
Status #2 [FINAL] - objectLiteral => ('T_LBRACE') [ propertyAssignments ] [ ('T_COMMA') ] ('T_RBRACE') @
Status #3 - objectLiteral => ('T_LBRACE') [ propertyAssignments @ ] [ ('T_COMMA') ] ('T_RBRACE')
  To #2:  ('T_RBRACE')
  To #4:  ('T_COMMA')
Status #4 - objectLiteral => ('T_LBRACE') [ propertyAssignments ] [ ('T_COMMA') @ ] ('T_RBRACE')
  To #2:  ('T_RBRACE')

** Rule: objectLiteralExpression => objectLiteral
-- Tokens: 'T_LBRACE' 
-- First-set tokens: 'T_LBRACE' 
-- First-set rules: objectLiteral 
Status #0 - objectLiteralExpression => @ objectLiteral
  To #1:  objectLiteral
Status #1 [FINAL] - objectLiteralExpression => objectLiteral @

** Rule: parenthesizedExpression => ('T_LPARAN') expressionSequence ('T_RPARAN')
-- Tokens: 'T_LPARAN' 
-- First-set tokens: 'T_LPARAN' 
-- First-set rules: 
Status #0 - parenthesizedExpression => @ ('T_LPARAN') expressionSequence ('T_RPARAN')
  To #1:  ('T_LPARAN')
Status #1 - parenthesizedExpression => ('T_LPARAN') @ expressionSequence ('T_RPARAN')
  To #2:  expressionSequence
Status #2 - parenthesizedExpression => ('T_LPARAN') expressionSequence @ ('T_RPARAN')
  To #3:  ('T_RPARAN')
Status #3 [FINAL] - parenthesizedExpression => ('T_LPARAN') expressionSequence ('T_RPARAN') @

** Rule: postDecreaseExpression => [ postDecreaseExpression ] 'T_DEC'
-- Tokens: 'T_DEC' 
-- First-set tokens: 'T_DEC' 
-- First-set rules: postDecreaseExpression 
Status #0 - postDecreaseExpression => [ @ postDecreaseExpression ] 'T_DEC'
  To #1:  postDecreaseExpression
  To #2:  'T_DEC'
Status #1 - postDecreaseExpression => [ postDecreaseExpression @ ] 'T_DEC'
  To #2:  'T_DEC'
Status #2 [FINAL] - postDecreaseExpression => [ postDecreaseExpression ] 'T_DEC' @

** Rule: postIncrementExpression => [ postIncrementExpression ] 'T_INC'
-- Tokens: 'T_INC' 
-- First-set tokens: 'T_INC' 
-- First-set rules: postIncrementExpression 
Status #0 - postIncrementExpression => [ @ postIncrementExpression ] 'T_INC'
  To #1:  postIncrementExpression
  To #2:  'T_INC'
Status #1 - postIncrementExpression => [ postIncrementExpression @ ] 'T_INC'
  To #2:  'T_INC'
Status #2 [FINAL] - postIncrementExpression => [ postIncrementExpression ] 'T_INC' @

** Rule: postfixExpression => ( postfixExpression ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )
-- Tokens: K_SUPER #NUMBER# 'T_LBRACE' K_TRUE 'T_LPARAN' #ID# #REGEX# K_FALSE K_NULL #STRING# 'T_LSQUARE' K_FUNCTION K_CLASS K_THIS 
-- First-set tokens: K_SUPER #NUMBER# 'T_LBRACE' K_TRUE 'T_LPARAN' #REGEX# K_FALSE K_NULL 'T_LSQUARE' K_FUNCTION #ID# K_CLASS #STRING# K_THIS 
-- First-set rules: functionExpression postfixExpression 
Status #0 - postfixExpression => @ ( postfixExpression ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )
  To #1:  functionExpression
  To #2:  postfixExpression
Status #1 [FINAL] - postfixExpression => ( postfixExpression ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression @ )
Status #2 - postfixExpression => ( postfixExpression @ ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )
  To #3:  postDecreaseExpression
  To #4:  memberIndexExpression
  To #5:  memberDotExpression
  To #6:  argumentsExpression
  To #7:  postIncrementExpression
Status #3 [FINAL] - postfixExpression => ( postfixExpression ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression @ ) | functionExpression )
Status #4 [FINAL] - postfixExpression => ( postfixExpression ( memberIndexExpression @ | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )
Status #5 [FINAL] - postfixExpression => ( postfixExpression ( memberIndexExpression | memberDotExpression @ | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )
Status #6 [FINAL] - postfixExpression => ( postfixExpression ( memberIndexExpression | memberDotExpression | argumentsExpression @ | postIncrementExpression | postDecreaseExpression ) | functionExpression )
Status #7 [FINAL] - postfixExpression => ( postfixExpression ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression @ | postDecreaseExpression ) | functionExpression )

** Rule: powerExpression => [ powerExpression 'T_POWER' ] notExpression
-- Tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF K_NEW K_VOID #NUMBER# 'T_LBRACE' K_DELETE K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER #STRING# K_FALSE 
-- First-set tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_TYPEOF K_NEW K_THIS #NUMBER# 'T_LBRACE' K_TRUE 'T_LPARAN' K_VOID #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER K_DELETE #STRING# K_FALSE 
-- First-set rules: notExpression powerExpression 
Status #0 - powerExpression => [ @ powerExpression 'T_POWER' ] notExpression
  To #1:  powerExpression
  To #2:  notExpression
Status #1 - powerExpression => [ powerExpression @ 'T_POWER' ] notExpression
  To #3:  'T_POWER'
Status #2 [FINAL] - powerExpression => [ powerExpression 'T_POWER' ] notExpression @
Status #3 - powerExpression => [ powerExpression 'T_POWER' @ ] notExpression
  To #2:  notExpression

** Rule: preDecreaseExpression => ( 'T_DEC' preDecreaseExpression | preIncrementExpression )
-- Tokens: 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_TYPEOF K_VOID #NUMBER# 'T_LBRACE' K_DELETE K_NEW K_THIS K_TRUE 'T_LPARAN' #ID# #REGEX# K_SUPER #STRING# K_FALSE 'T_LSQUARE' K_CLASS 
-- First-set tokens: K_CLASS 'T_LSQUARE' K_FALSE #STRING# K_SUPER #REGEX# #ID# 'T_LPARAN' K_TRUE K_THIS K_NEW K_DELETE 'T_LBRACE' #NUMBER# K_VOID K_TYPEOF K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
-- First-set rules: preIncrementExpression 
Status #0 - preDecreaseExpression => @ ( 'T_DEC' preDecreaseExpression | preIncrementExpression )
  To #1:  preIncrementExpression
  To #2:  'T_DEC'
Status #1 [FINAL] - preDecreaseExpression => ( 'T_DEC' preDecreaseExpression | preIncrementExpression @ )
Status #2 - preDecreaseExpression => ( 'T_DEC' @ preDecreaseExpression | preIncrementExpression )
  To #3:  preDecreaseExpression
Status #3 [FINAL] - preDecreaseExpression => ( 'T_DEC' preDecreaseExpression @ | preIncrementExpression )

** Rule: preIncrementExpression => ( 'T_INC' preIncrementExpression | typeofExpression )
-- Tokens: 'T_INC' K_FUNCTION K_TYPEOF K_VOID #NUMBER# 'T_LBRACE' K_DELETE K_NEW K_THIS K_TRUE 'T_LPARAN' #ID# #REGEX# K_SUPER #STRING# K_FALSE K_NULL 'T_LSQUARE' K_CLASS 
-- First-set tokens: K_CLASS 'T_LSQUARE' K_NULL K_FALSE #STRING# K_SUPER #REGEX# #ID# 'T_LPARAN' K_TRUE K_THIS K_NEW K_DELETE 'T_LBRACE' #NUMBER# K_VOID K_TYPEOF K_FUNCTION 'T_INC' 
-- First-set rules: typeofExpression 
Status #0 - preIncrementExpression => @ ( 'T_INC' preIncrementExpression | typeofExpression )
  To #1:  typeofExpression
  To #2:  'T_INC'
Status #1 [FINAL] - preIncrementExpression => ( 'T_INC' preIncrementExpression | typeofExpression @ )
Status #2 - preIncrementExpression => ( 'T_INC' @ preIncrementExpression | typeofExpression )
  To #3:  preIncrementExpression
Status #3 [FINAL] - preIncrementExpression => ( 'T_INC' preIncrementExpression @ | typeofExpression )

** Rule: program => sourceElements
-- Tokens: K_TRY K_WITH 'T_LOG_NOT' K_TYPEOF #NUMBER# K_DEBUGGER K_THROW #ID# K_VAR 'T_LSQUARE' K_RETURN K_CONTINUE K_FUNCTION K_SWITCH 'T_SEMI' #STRING# 'T_ADD' K_CLASS 'T_BIT_NOT' K_TRUE 'T_SUB' 'T_DEC' K_NULL K_THIS K_VOID K_DELETE #REGEX# K_SUPER K_FALSE K_IF 'T_LPARAN' K_FOR K_NEW K_WHILE K_DO 'T_LBRACE' 'T_INC' K_BREAK 
-- First-set tokens: K_BREAK 'T_INC' 'T_LBRACE' K_DO K_WHILE K_NEW K_FOR 'T_LPARAN' K_IF K_FALSE K_SUPER #REGEX# K_DELETE K_VOID K_THIS K_NULL 'T_DEC' 'T_SUB' K_TRUE 'T_BIT_NOT' K_CLASS 'T_ADD' #STRING# 'T_SEMI' K_SWITCH K_FUNCTION K_CONTINUE K_RETURN 'T_LSQUARE' K_VAR #ID# K_THROW K_DEBUGGER #NUMBER# K_TYPEOF 'T_LOG_NOT' K_WITH K_TRY 
-- First-set rules: sourceElements 
Status #0 - program => @ sourceElements
  To #1:  sourceElements
Status #1 [FINAL] - program => sourceElements @

** Rule: propertyAssignment => ( propertyExpressionAssignment | computedPropertyExpressionAssignment | propertyShorthand )
-- Tokens: K_FOR K_SUPER #NUMBER# K_CLASS #REGEX# 'T_LPARAN' K_DELETE K_INSTANCEOF K_NEW K_THIS K_FUNCTION K_CONTINUE 'T_INC' K_NULL 'T_DEC' 'T_SUB' K_TRUE 'T_BIT_NOT' 'T_ADD' K_TYPEOF K_VAR K_FALSE 'T_ELLIPSIS' K_TRY 'T_LBRACE' 'T_LOG_NOT' K_DEFAULT K_DEBUGGER K_WHILE #STRING# K_SWITCH K_ELSE K_VOID K_LET K_IN 'T_LSQUARE' #ID# K_RETURN K_IF K_FINALLY K_CASE K_CATCH K_BREAK K_THROW K_WITH K_DO 
-- First-set tokens: K_DO K_WITH K_THROW K_BREAK K_CATCH K_CASE K_FINALLY K_IF K_RETURN K_IN K_LET K_ELSE K_SWITCH K_WHILE K_DEBUGGER K_DEFAULT K_TRY 'T_ELLIPSIS' K_VAR 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_CONTINUE K_FUNCTION K_THIS K_TYPEOF K_NEW K_DELETE K_TRUE K_INSTANCEOF 'T_LPARAN' #ID# K_VOID 'T_LSQUARE' #REGEX# 'T_LBRACE' K_CLASS #NUMBER# K_SUPER K_FOR #STRING# K_FALSE 
-- First-set rules: propertyShorthand computedPropertyExpressionAssignment propertyExpressionAssignment 
Status #0 - propertyAssignment => @ ( propertyExpressionAssignment | computedPropertyExpressionAssignment | propertyShorthand )
  To #1:  propertyShorthand
  To #2:  propertyExpressionAssignment
  To #3:  computedPropertyExpressionAssignment
Status #1 [FINAL] - propertyAssignment => ( propertyExpressionAssignment | computedPropertyExpressionAssignment | propertyShorthand @ )
Status #2 [FINAL] - propertyAssignment => ( propertyExpressionAssignment @ | computedPropertyExpressionAssignment | propertyShorthand )
Status #3 [FINAL] - propertyAssignment => ( propertyExpressionAssignment | computedPropertyExpressionAssignment @ | propertyShorthand )

** Rule: propertyAssignments => [ propertyAssignments ('T_COMMA') ] propertyAssignment
-- Tokens: K_FOR K_SUPER #NUMBER# K_CLASS #REGEX# 'T_LPARAN' K_DELETE K_INSTANCEOF K_NEW K_THIS K_FUNCTION K_CONTINUE 'T_INC' K_NULL 'T_DEC' 'T_SUB' K_TRUE 'T_BIT_NOT' 'T_ADD' K_TYPEOF K_VAR K_FALSE 'T_ELLIPSIS' K_TRY 'T_LBRACE' 'T_LOG_NOT' K_DEFAULT K_DEBUGGER K_WHILE #STRING# K_SWITCH K_ELSE K_VOID K_LET K_IN 'T_LSQUARE' #ID# K_RETURN K_IF K_FINALLY K_CASE K_CATCH K_BREAK K_THROW K_WITH K_DO 
-- First-set tokens: K_FOR K_SUPER #NUMBER# K_CLASS 'T_LPARAN' K_DELETE K_INSTANCEOF K_NEW K_THIS K_CONTINUE 'T_INC' K_NULL 'T_DEC' 'T_SUB' K_TRUE 'T_BIT_NOT' 'T_ADD' K_TYPEOF K_VAR K_FALSE 'T_ELLIPSIS' K_TRY 'T_LBRACE' 'T_LOG_NOT' K_DEFAULT K_WHILE #STRING# K_SWITCH K_DEBUGGER K_ELSE K_VOID K_LET K_IN 'T_LSQUARE' #ID# K_RETURN K_IF K_FINALLY K_CASE K_FUNCTION K_CATCH K_BREAK #REGEX# K_THROW K_WITH K_DO 
-- First-set rules: propertyAssignment propertyAssignments 
Status #0 - propertyAssignments => [ @ propertyAssignments ('T_COMMA') ] propertyAssignment
  To #1:  propertyAssignments
  To #2:  propertyAssignment
Status #1 - propertyAssignments => [ propertyAssignments @ ('T_COMMA') ] propertyAssignment
  To #3:  ('T_COMMA')
Status #2 [FINAL] - propertyAssignments => [ propertyAssignments ('T_COMMA') ] propertyAssignment @
Status #3 - propertyAssignments => [ propertyAssignments ('T_COMMA') @ ] propertyAssignment
  To #2:  propertyAssignment

** Rule: propertyExpressionAssignment => propertyName ('T_COLON') singleExpression
-- Tokens: #NUMBER# 'T_LSQUARE' #STRING# K_THIS #ID# K_CLASS K_FALSE K_TRUE K_DEFAULT K_DEBUGGER K_VAR K_WHILE K_SWITCH K_CONTINUE K_VOID K_LET K_IN K_RETURN K_TYPEOF K_FINALLY K_NEW K_FOR K_INSTANCEOF K_CASE K_CATCH K_ELSE K_IF K_BREAK K_THROW K_DELETE K_WITH K_DO K_FUNCTION K_TRY K_SUPER 
-- First-set tokens: K_SUPER K_TRY K_FUNCTION K_DO K_WITH K_DELETE K_THROW K_BREAK K_IF K_ELSE K_CATCH K_CASE K_INSTANCEOF K_FOR K_NEW K_FINALLY K_TYPEOF K_RETURN K_IN K_LET K_VOID K_CONTINUE K_SWITCH K_WHILE K_VAR K_DEBUGGER K_DEFAULT K_TRUE K_FALSE K_CLASS #ID# K_THIS #STRING# 'T_LSQUARE' #NUMBER# 
-- First-set rules: propertyName 
Status #0 - propertyExpressionAssignment => @ propertyName ('T_COLON') singleExpression
  To #1:  propertyName
Status #1 - propertyExpressionAssignment => propertyName @ ('T_COLON') singleExpression
  To #2:  ('T_COLON')
Status #2 - propertyExpressionAssignment => propertyName ('T_COLON') @ singleExpression
  To #3:  singleExpression
Status #3 [FINAL] - propertyExpressionAssignment => propertyName ('T_COLON') singleExpression @

** Rule: propertyName => ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') )
-- Tokens: #NUMBER# 'T_LSQUARE' #STRING# K_THIS #ID# K_CLASS K_FALSE K_TRUE K_DEFAULT K_DEBUGGER K_VAR K_WHILE K_SWITCH K_CONTINUE K_VOID K_LET K_IN K_RETURN K_TYPEOF K_FINALLY K_NEW K_FOR K_INSTANCEOF K_CASE K_CATCH K_ELSE K_IF K_BREAK K_THROW K_DELETE K_WITH K_DO K_FUNCTION K_TRY K_SUPER 
-- First-set tokens: K_SUPER K_TRY K_FUNCTION K_DO K_WITH K_DELETE K_THROW K_BREAK K_IF K_ELSE K_CATCH K_CASE K_INSTANCEOF K_FOR K_NEW K_FINALLY K_TYPEOF K_RETURN K_IN K_LET K_VOID K_CONTINUE K_SWITCH K_WHILE K_VAR K_DEBUGGER K_DEFAULT K_TRUE K_FALSE K_CLASS #ID# K_THIS #STRING# 'T_LSQUARE' #NUMBER# 
-- First-set rules: numericLiteral identifierName 
Status #0 - propertyName => @ ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') )
  To #1:  ('T_LSQUARE')
  To #2:  identifierName
  To #3:  #STRING#
  To #4:  numericLiteral
Status #1 - propertyName => ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') @ singleExpression ('T_RSQUARE') )
  To #5:  singleExpression
Status #2 [FINAL] - propertyName => ( identifierName @ | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') )
Status #3 [FINAL] - propertyName => ( identifierName | #STRING# @ | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') )
Status #4 [FINAL] - propertyName => ( identifierName | #STRING# | numericLiteral @ | ('T_LSQUARE') singleExpression ('T_RSQUARE') )
Status #5 - propertyName => ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression @ ('T_RSQUARE') )
  To #6:  ('T_RSQUARE')
Status #6 [FINAL] - propertyName => ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') @ )

** Rule: propertyShorthand => [ 'T_ELLIPSIS' ] singleExpression
-- Tokens: 'T_ELLIPSIS' 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF K_NEW K_VOID #NUMBER# 'T_LBRACE' K_DELETE K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER #STRING# K_FALSE 
-- First-set tokens: K_FALSE #STRING# K_SUPER K_CLASS #REGEX# 'T_LSQUARE' #ID# 'T_LPARAN' K_TRUE K_DELETE 'T_LBRACE' #NUMBER# K_VOID K_NEW K_TYPEOF K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 'T_ELLIPSIS' 
-- First-set rules: singleExpression 
Status #0 - propertyShorthand => [ @ 'T_ELLIPSIS' ] singleExpression
  To #1:  'T_ELLIPSIS'
  To #2:  singleExpression
Status #1 - propertyShorthand => [ 'T_ELLIPSIS' @ ] singleExpression
  To #2:  singleExpression
Status #2 [FINAL] - propertyShorthand => [ 'T_ELLIPSIS' ] singleExpression @

** Rule: relationalExpression => [ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression
-- Tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF K_NEW K_VOID #NUMBER# 'T_LBRACE' K_DELETE K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER #STRING# K_FALSE 
-- First-set tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_TYPEOF K_NEW K_THIS #NUMBER# 'T_LBRACE' K_TRUE 'T_LPARAN' K_VOID #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER K_DELETE #STRING# K_FALSE 
-- First-set rules: bitShiftExpression relationalExpression 
Status #0 - relationalExpression => [ @ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression
  To #1:  relationalExpression
  To #2:  bitShiftExpression
Status #1 - relationalExpression => [ relationalExpression @ ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression
  To #3:  'T_GREATER_EQUAL'
  To #4:  'T_LESS'
  To #5:  'T_LESS_EQUAL'
  To #6:  'T_GREATER'
Status #2 [FINAL] - relationalExpression => [ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression @
Status #3 - relationalExpression => [ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' @ ) ] bitShiftExpression
  To #2:  bitShiftExpression
Status #4 - relationalExpression => [ relationalExpression ( 'T_LESS' @ | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression
  To #2:  bitShiftExpression
Status #5 - relationalExpression => [ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' @ | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression
  To #2:  bitShiftExpression
Status #6 - relationalExpression => [ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' @ | 'T_GREATER_EQUAL' ) ] bitShiftExpression
  To #2:  bitShiftExpression

** Rule: reservedWord => ( keyword | K_TRUE | K_FALSE )
-- Tokens: K_FALSE K_TRUE K_DEFAULT K_DEBUGGER K_VAR K_WHILE K_SWITCH K_CONTINUE K_VOID K_LET K_IN K_RETURN K_TYPEOF K_FINALLY K_NEW K_FOR K_INSTANCEOF K_CASE K_CATCH K_ELSE K_THIS K_IF K_BREAK K_THROW K_DELETE K_WITH K_DO K_FUNCTION K_TRY K_CLASS K_SUPER 
-- First-set tokens: K_SUPER K_CLASS K_TRY K_FUNCTION K_DO K_WITH K_DELETE K_THROW K_BREAK K_IF K_THIS K_ELSE K_CATCH K_CASE K_INSTANCEOF K_FOR K_NEW K_FINALLY K_TYPEOF K_RETURN K_IN K_LET K_VOID K_CONTINUE K_SWITCH K_WHILE K_VAR K_DEBUGGER K_DEFAULT K_TRUE K_FALSE 
-- First-set rules: keyword 
Status #0 - reservedWord => @ ( keyword | K_TRUE | K_FALSE )
  To #1:  K_FALSE
  To #2:  keyword
  To #3:  K_TRUE
Status #1 [FINAL] - reservedWord => ( keyword | K_TRUE | K_FALSE @ )
Status #2 [FINAL] - reservedWord => ( keyword @ | K_TRUE | K_FALSE )
Status #3 [FINAL] - reservedWord => ( keyword | K_TRUE @ | K_FALSE )

** Rule: returnStatement => K_RETURN [ expressionSequence ] [ eos ]
-- Tokens: K_RETURN 
-- First-set tokens: K_RETURN 
-- First-set rules: 
Status #0 - returnStatement => @ K_RETURN [ expressionSequence ] [ eos ]
  To #1:  K_RETURN
Status #1 [FINAL] - returnStatement => K_RETURN @ [ expressionSequence ] [ eos ]
  To #2:  eos
  To #3:  expressionSequence
Status #2 [FINAL] - returnStatement => K_RETURN [ expressionSequence ] [ eos @ ]
Status #3 [FINAL] - returnStatement => K_RETURN [ expressionSequence @ ] [ eos ]
  To #2:  eos

** Rule: singleExpression => [ singleExpression ('T_COMMA') ] assignmentExpression
-- Tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF K_NEW K_VOID #NUMBER# 'T_LBRACE' K_DELETE K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER #STRING# K_FALSE 
-- First-set tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_TYPEOF K_NEW K_THIS #NUMBER# 'T_LBRACE' K_TRUE 'T_LPARAN' K_VOID #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER K_DELETE #STRING# K_FALSE 
-- First-set rules: assignmentExpression singleExpression 
Status #0 - singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
  To #1:  singleExpression
  To #2:  assignmentExpression
Status #1 - singleExpression => [ singleExpression @ ('T_COMMA') ] assignmentExpression
  To #3:  ('T_COMMA')
Status #2 [FINAL] - singleExpression => [ singleExpression ('T_COMMA') ] assignmentExpression @
Status #3 - singleExpression => [ singleExpression ('T_COMMA') @ ] assignmentExpression
  To #2:  assignmentExpression

** Rule: sourceElement => statement
-- Tokens: K_TRY K_WITH 'T_LOG_NOT' K_TYPEOF #NUMBER# K_DEBUGGER K_THROW #ID# K_VAR 'T_LSQUARE' K_RETURN K_CONTINUE K_FUNCTION K_SWITCH 'T_SEMI' #STRING# 'T_ADD' K_CLASS 'T_BIT_NOT' K_TRUE 'T_SUB' 'T_DEC' K_NULL K_THIS K_VOID K_DELETE #REGEX# K_SUPER K_FALSE K_IF 'T_LPARAN' K_FOR K_NEW K_WHILE K_DO 'T_LBRACE' 'T_INC' K_BREAK 
-- First-set tokens: K_BREAK 'T_INC' 'T_LBRACE' K_DO K_WHILE K_NEW K_FOR 'T_LPARAN' K_IF K_FALSE K_SUPER #REGEX# K_DELETE K_VOID K_THIS K_NULL 'T_DEC' 'T_SUB' K_TRUE 'T_BIT_NOT' K_CLASS 'T_ADD' #STRING# 'T_SEMI' K_SWITCH K_FUNCTION K_CONTINUE K_RETURN 'T_LSQUARE' K_VAR #ID# K_THROW K_DEBUGGER #NUMBER# K_TYPEOF 'T_LOG_NOT' K_WITH K_TRY 
-- First-set rules: statement 
Status #0 - sourceElement => @ statement
  To #1:  statement
Status #1 [FINAL] - sourceElement => statement @

** Rule: sourceElements => [ sourceElements ] statement
-- Tokens: K_TRY K_WITH 'T_LOG_NOT' K_TYPEOF #NUMBER# K_DEBUGGER K_THROW #ID# K_VAR 'T_LSQUARE' K_RETURN K_CONTINUE K_FUNCTION K_SWITCH 'T_SEMI' #STRING# 'T_ADD' K_CLASS 'T_BIT_NOT' K_TRUE 'T_SUB' 'T_DEC' K_NULL K_THIS K_VOID K_DELETE #REGEX# K_SUPER K_FALSE K_IF 'T_LPARAN' K_FOR K_NEW K_WHILE K_DO 'T_LBRACE' 'T_INC' K_BREAK 
-- First-set tokens: K_WITH 'T_LOG_NOT' K_TYPEOF #NUMBER# K_DEBUGGER K_THROW K_VAR K_TRY 'T_LSQUARE' K_RETURN K_CONTINUE K_SWITCH 'T_SEMI' #STRING# 'T_ADD' 'T_BIT_NOT' K_TRUE 'T_SUB' #ID# 'T_DEC' K_NULL K_THIS K_FUNCTION K_DELETE K_VOID #REGEX# K_FALSE K_CLASS K_IF K_SUPER 'T_LPARAN' K_FOR K_NEW K_WHILE K_DO 'T_LBRACE' 'T_INC' K_BREAK 
-- First-set rules: statement sourceElements 
Status #0 - sourceElements => [ @ sourceElements ] statement
  To #1:  sourceElements
  To #2:  statement
Status #1 - sourceElements => [ sourceElements @ ] statement
  To #2:  statement
Status #2 [FINAL] - sourceElements => [ sourceElements ] statement @

** Rule: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
-- Tokens: K_TRY K_WITH 'T_LOG_NOT' K_TYPEOF #NUMBER# K_DEBUGGER K_THROW #ID# K_VAR 'T_LSQUARE' K_RETURN K_CONTINUE K_FUNCTION K_SWITCH 'T_SEMI' #STRING# 'T_ADD' K_CLASS 'T_BIT_NOT' K_TRUE 'T_SUB' 'T_DEC' K_NULL K_THIS K_VOID K_DELETE #REGEX# K_SUPER K_FALSE K_IF 'T_LPARAN' K_FOR K_NEW K_WHILE K_DO 'T_LBRACE' 'T_INC' K_BREAK 
-- First-set tokens: K_BREAK K_DO K_WHILE K_FOR K_IF K_FALSE K_SUPER #REGEX# 'T_LPARAN' K_DELETE K_VOID K_NEW K_THIS 'T_INC' K_NULL 'T_DEC' 'T_SUB' K_TRUE 'T_BIT_NOT' 'T_ADD' #STRING# K_SWITCH K_FUNCTION K_CONTINUE K_RETURN 'T_LSQUARE' #ID# K_DEBUGGER #NUMBER# K_CLASS 'T_SEMI' K_WITH K_TRY K_THROW K_TYPEOF K_VAR 'T_LOG_NOT' 'T_LBRACE' 
-- First-set rules: debuggerStatement tryStatement throwStatement withStatement labelledStatement classDeclaration continueStatement functionDeclaration emptyStatement switchStatement variableStatement block expressionStatement ifStatement iterationStatement breakStatement returnStatement 
Status #0 - statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
  To #1:  functionDeclaration
  To #2:  block
  To #3:  variableStatement
  To #4:  emptyStatement
  To #5:  classDeclaration
  To #6:  expressionStatement
  To #7:  ifStatement
  To #8:  iterationStatement
  To #9:  continueStatement
  To #10:  breakStatement
  To #11:  returnStatement
  To #12:  withStatement
  To #13:  labelledStatement
  To #14:  switchStatement
  To #15:  throwStatement
  To #16:  tryStatement
  To #17:  debuggerStatement
Status #1 [FINAL] - statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration @ )
Status #2 [FINAL] - statement => ( block @ | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
Status #3 [FINAL] - statement => ( block | variableStatement @ | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
Status #4 [FINAL] - statement => ( block | variableStatement | emptyStatement @ | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
Status #5 [FINAL] - statement => ( block | variableStatement | emptyStatement | classDeclaration @ | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
Status #6 [FINAL] - statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement @ | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
Status #7 [FINAL] - statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement @ | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
Status #8 [FINAL] - statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement @ | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
Status #9 [FINAL] - statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement @ | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
Status #10 [FINAL] - statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement @ | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
Status #11 [FINAL] - statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement @ | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
Status #12 [FINAL] - statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement @ | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
Status #13 [FINAL] - statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement @ | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
Status #14 [FINAL] - statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement @ | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
Status #15 [FINAL] - statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement @ | tryStatement | debuggerStatement | functionDeclaration )
Status #16 [FINAL] - statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement @ | debuggerStatement | functionDeclaration )
Status #17 [FINAL] - statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement @ | functionDeclaration )

** Rule: statementList => [ statementList ] statement
-- Tokens: K_TRY K_WITH 'T_LOG_NOT' K_TYPEOF #NUMBER# K_DEBUGGER K_THROW #ID# K_VAR 'T_LSQUARE' K_RETURN K_CONTINUE K_FUNCTION K_SWITCH 'T_SEMI' #STRING# 'T_ADD' K_CLASS 'T_BIT_NOT' K_TRUE 'T_SUB' 'T_DEC' K_NULL K_THIS K_VOID K_DELETE #REGEX# K_SUPER K_FALSE K_IF 'T_LPARAN' K_FOR K_NEW K_WHILE K_DO 'T_LBRACE' 'T_INC' K_BREAK 
-- First-set tokens: K_WITH 'T_LOG_NOT' K_TYPEOF #NUMBER# K_DEBUGGER K_THROW K_VAR K_TRY 'T_LSQUARE' K_RETURN K_CONTINUE K_SWITCH 'T_SEMI' #STRING# 'T_ADD' 'T_BIT_NOT' K_TRUE 'T_SUB' #ID# 'T_DEC' K_NULL K_THIS K_FUNCTION K_DELETE K_VOID #REGEX# K_FALSE K_CLASS K_IF K_SUPER 'T_LPARAN' K_FOR K_NEW K_WHILE K_DO 'T_LBRACE' 'T_INC' K_BREAK 
-- First-set rules: statement statementList 
Status #0 - statementList => [ @ statementList ] statement
  To #1:  statementList
  To #2:  statement
Status #1 - statementList => [ statementList @ ] statement
  To #2:  statement
Status #2 [FINAL] - statementList => [ statementList ] statement @

** Rule: superExpression => K_SUPER
-- Tokens: K_SUPER 
-- First-set tokens: K_SUPER 
-- First-set rules: 
Status #0 - superExpression => @ K_SUPER
  To #1:  K_SUPER
Status #1 [FINAL] - superExpression => K_SUPER @

** Rule: switchStatement => K_SWITCH ('T_LPARAN') expressionSequence ('T_RPARAN') caseBlock
-- Tokens: K_SWITCH 
-- First-set tokens: K_SWITCH 
-- First-set rules: 
Status #0 - switchStatement => @ K_SWITCH ('T_LPARAN') expressionSequence ('T_RPARAN') caseBlock
  To #1:  K_SWITCH
Status #1 - switchStatement => K_SWITCH @ ('T_LPARAN') expressionSequence ('T_RPARAN') caseBlock
  To #2:  ('T_LPARAN')
Status #2 - switchStatement => K_SWITCH ('T_LPARAN') @ expressionSequence ('T_RPARAN') caseBlock
  To #3:  expressionSequence
Status #3 - switchStatement => K_SWITCH ('T_LPARAN') expressionSequence @ ('T_RPARAN') caseBlock
  To #4:  ('T_RPARAN')
Status #4 - switchStatement => K_SWITCH ('T_LPARAN') expressionSequence ('T_RPARAN') @ caseBlock
  To #5:  caseBlock
Status #5 [FINAL] - switchStatement => K_SWITCH ('T_LPARAN') expressionSequence ('T_RPARAN') caseBlock @

** Rule: ternaryExpression => logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' singleExpression ]
-- Tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF K_NEW K_VOID #NUMBER# 'T_LBRACE' K_DELETE K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# K_CLASS K_SUPER #STRING# K_FALSE 
-- First-set tokens: K_FALSE #STRING# K_SUPER K_CLASS #REGEX# 'T_LSQUARE' #ID# 'T_LPARAN' K_TRUE K_DELETE 'T_LBRACE' #NUMBER# K_VOID K_NEW K_TYPEOF K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 
-- First-set rules: logicalOrExpression 
Status #0 - ternaryExpression => @ logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' singleExpression ]
  To #1:  logicalOrExpression
Status #1 [FINAL] - ternaryExpression => logicalOrExpression @ [ 'T_QUERY' singleExpression 'T_COLON' singleExpression ]
  To #2:  'T_QUERY'
Status #2 - ternaryExpression => logicalOrExpression [ 'T_QUERY' @ singleExpression 'T_COLON' singleExpression ]
  To #3:  singleExpression
Status #3 - ternaryExpression => logicalOrExpression [ 'T_QUERY' singleExpression @ 'T_COLON' singleExpression ]
  To #4:  'T_COLON'
Status #4 - ternaryExpression => logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' @ singleExpression ]
  To #5:  singleExpression
Status #5 [FINAL] - ternaryExpression => logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' singleExpression @ ]

** Rule: thisExpression => K_THIS
-- Tokens: K_THIS 
-- First-set tokens: K_THIS 
-- First-set rules: 
Status #0 - thisExpression => @ K_THIS
  To #1:  K_THIS
Status #1 [FINAL] - thisExpression => K_THIS @

** Rule: throwStatement => K_THROW expressionSequence [ eos ]
-- Tokens: K_THROW 
-- First-set tokens: K_THROW 
-- First-set rules: 
Status #0 - throwStatement => @ K_THROW expressionSequence [ eos ]
  To #1:  K_THROW
Status #1 - throwStatement => K_THROW @ expressionSequence [ eos ]
  To #2:  expressionSequence
Status #2 [FINAL] - throwStatement => K_THROW expressionSequence @ [ eos ]
  To #3:  eos
Status #3 [FINAL] - throwStatement => K_THROW expressionSequence [ eos @ ]

** Rule: tryStatement => K_TRY block ( catchProduction [ finallyProduction ] | finallyProduction )
-- Tokens: K_TRY 
-- First-set tokens: K_TRY 
-- First-set rules: 
Status #0 - tryStatement => @ K_TRY block ( catchProduction [ finallyProduction ] | finallyProduction )
  To #1:  K_TRY
Status #1 - tryStatement => K_TRY @ block ( catchProduction [ finallyProduction ] | finallyProduction )
  To #2:  block
Status #2 - tryStatement => K_TRY block @ ( catchProduction [ finallyProduction ] | finallyProduction )
  To #3:  finallyProduction
  To #4:  catchProduction
Status #3 [FINAL] - tryStatement => K_TRY block ( catchProduction [ finallyProduction ] | finallyProduction @ )
Status #4 [FINAL] - tryStatement => K_TRY block ( catchProduction @ [ finallyProduction ] | finallyProduction )
  To #5:  finallyProduction
Status #5 [FINAL] - tryStatement => K_TRY block ( catchProduction [ finallyProduction @ ] | finallyProduction )

** Rule: typeofExpression => ( K_TYPEOF typeofExpression | voidExpression )
-- Tokens: K_TYPEOF K_VOID K_DELETE K_NEW K_TRUE #REGEX# K_SUPER #NUMBER# 'T_LBRACE' #STRING# 'T_LPARAN' #ID# K_FALSE K_NULL 'T_LSQUARE' K_FUNCTION K_CLASS K_THIS 
-- First-set tokens: K_THIS K_CLASS K_FUNCTION 'T_LSQUARE' K_NULL K_FALSE #ID# 'T_LPARAN' #STRING# 'T_LBRACE' #NUMBER# K_SUPER #REGEX# K_TRUE K_NEW K_DELETE K_VOID K_TYPEOF 
-- First-set rules: voidExpression 
Status #0 - typeofExpression => @ ( K_TYPEOF typeofExpression | voidExpression )
  To #1:  voidExpression
  To #2:  K_TYPEOF
Status #1 [FINAL] - typeofExpression => ( K_TYPEOF typeofExpression | voidExpression @ )
Status #2 - typeofExpression => ( K_TYPEOF @ typeofExpression | voidExpression )
  To #3:  typeofExpression
Status #3 [FINAL] - typeofExpression => ( K_TYPEOF typeofExpression @ | voidExpression )

** Rule: unaryMinusExpression => ( 'T_SUB' unaryMinusExpression | unaryPlusExpression )
-- Tokens: 'T_SUB' 'T_ADD' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_TYPEOF K_VOID #NUMBER# 'T_LBRACE' K_DELETE K_NEW K_THIS K_TRUE 'T_LPARAN' #ID# #REGEX# K_SUPER #STRING# K_FALSE 'T_LSQUARE' K_CLASS 
-- First-set tokens: K_CLASS 'T_LSQUARE' K_FALSE #STRING# K_SUPER #REGEX# #ID# 'T_LPARAN' K_TRUE K_THIS K_NEW K_DELETE 'T_LBRACE' #NUMBER# K_VOID K_TYPEOF K_FUNCTION 'T_INC' K_NULL 'T_DEC' 'T_ADD' 'T_SUB' 
-- First-set rules: unaryPlusExpression 
Status #0 - unaryMinusExpression => @ ( 'T_SUB' unaryMinusExpression | unaryPlusExpression )
  To #1:  unaryPlusExpression
  To #2:  'T_SUB'
Status #1 [FINAL] - unaryMinusExpression => ( 'T_SUB' unaryMinusExpression | unaryPlusExpression @ )
Status #2 - unaryMinusExpression => ( 'T_SUB' @ unaryMinusExpression | unaryPlusExpression )
  To #3:  unaryMinusExpression
Status #3 [FINAL] - unaryMinusExpression => ( 'T_SUB' unaryMinusExpression @ | unaryPlusExpression )

** Rule: unaryPlusExpression => ( 'T_ADD' unaryPlusExpression | preDecreaseExpression )
-- Tokens: 'T_ADD' 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_TYPEOF K_VOID #NUMBER# 'T_LBRACE' K_DELETE K_NEW K_THIS K_TRUE 'T_LPARAN' #ID# #REGEX# K_SUPER #STRING# K_FALSE 'T_LSQUARE' K_CLASS 
-- First-set tokens: K_CLASS 'T_LSQUARE' K_FALSE #STRING# K_SUPER #REGEX# #ID# 'T_LPARAN' K_TRUE K_THIS K_NEW K_DELETE 'T_LBRACE' #NUMBER# K_VOID K_TYPEOF K_FUNCTION 'T_INC' K_NULL 'T_DEC' 'T_ADD' 
-- First-set rules: preDecreaseExpression 
Status #0 - unaryPlusExpression => @ ( 'T_ADD' unaryPlusExpression | preDecreaseExpression )
  To #1:  preDecreaseExpression
  To #2:  'T_ADD'
Status #1 [FINAL] - unaryPlusExpression => ( 'T_ADD' unaryPlusExpression | preDecreaseExpression @ )
Status #2 - unaryPlusExpression => ( 'T_ADD' @ unaryPlusExpression | preDecreaseExpression )
  To #3:  unaryPlusExpression
Status #3 [FINAL] - unaryPlusExpression => ( 'T_ADD' unaryPlusExpression @ | preDecreaseExpression )

** Rule: variableDeclaration => assignable [ 'T_ASSIGN' singleExpression ]
-- Tokens: #ID# 'T_LBRACE' 'T_LSQUARE' 
-- First-set tokens: 'T_LSQUARE' 'T_LBRACE' #ID# 
-- First-set rules: assignable 
Status #0 - variableDeclaration => @ assignable [ 'T_ASSIGN' singleExpression ]
  To #1:  assignable
Status #1 [FINAL] - variableDeclaration => assignable @ [ 'T_ASSIGN' singleExpression ]
  To #2:  'T_ASSIGN'
Status #2 - variableDeclaration => assignable [ 'T_ASSIGN' @ singleExpression ]
  To #3:  singleExpression
Status #3 [FINAL] - variableDeclaration => assignable [ 'T_ASSIGN' singleExpression @ ]

** Rule: variableDeclarationList => [ variableDeclarationList ('T_COMMA') ] variableDeclaration
-- Tokens: #ID# 'T_LBRACE' 'T_LSQUARE' 
-- First-set tokens: #ID# 'T_LBRACE' 'T_LSQUARE' 
-- First-set rules: variableDeclaration variableDeclarationList 
Status #0 - variableDeclarationList => [ @ variableDeclarationList ('T_COMMA') ] variableDeclaration
  To #1:  variableDeclarationList
  To #2:  variableDeclaration
Status #1 - variableDeclarationList => [ variableDeclarationList @ ('T_COMMA') ] variableDeclaration
  To #3:  ('T_COMMA')
Status #2 [FINAL] - variableDeclarationList => [ variableDeclarationList ('T_COMMA') ] variableDeclaration @
Status #3 - variableDeclarationList => [ variableDeclarationList ('T_COMMA') @ ] variableDeclaration
  To #2:  variableDeclaration

** Rule: variableStatement => K_VAR variableDeclarationList [ eos ]
-- Tokens: K_VAR 
-- First-set tokens: K_VAR 
-- First-set rules: 
Status #0 - variableStatement => @ K_VAR variableDeclarationList [ eos ]
  To #1:  K_VAR
Status #1 - variableStatement => K_VAR @ variableDeclarationList [ eos ]
  To #2:  variableDeclarationList
Status #2 [FINAL] - variableStatement => K_VAR variableDeclarationList @ [ eos ]
  To #3:  eos
Status #3 [FINAL] - variableStatement => K_VAR variableDeclarationList [ eos @ ]

** Rule: voidExpression => ( K_VOID voidExpression | deleteExpression )
-- Tokens: K_VOID K_DELETE K_NEW K_TRUE #REGEX# K_SUPER #NUMBER# 'T_LBRACE' #STRING# 'T_LPARAN' #ID# K_FALSE K_NULL 'T_LSQUARE' K_FUNCTION K_CLASS K_THIS 
-- First-set tokens: K_THIS K_CLASS K_FUNCTION 'T_LSQUARE' K_NULL K_FALSE #ID# 'T_LPARAN' #STRING# 'T_LBRACE' #NUMBER# K_SUPER #REGEX# K_TRUE K_NEW K_DELETE K_VOID 
-- First-set rules: deleteExpression 
Status #0 - voidExpression => @ ( K_VOID voidExpression | deleteExpression )
  To #1:  deleteExpression
  To #2:  K_VOID
Status #1 [FINAL] - voidExpression => ( K_VOID voidExpression | deleteExpression @ )
Status #2 - voidExpression => ( K_VOID @ voidExpression | deleteExpression )
  To #3:  voidExpression
Status #3 [FINAL] - voidExpression => ( K_VOID voidExpression @ | deleteExpression )

** Rule: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement
-- Tokens: K_WHILE 
-- First-set tokens: K_WHILE 
-- First-set rules: 
Status #0 - whileStatement => @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement
  To #1:  K_WHILE
Status #1 - whileStatement => K_WHILE @ ('T_LPARAN') expressionSequence ('T_RPARAN') statement
  To #2:  ('T_LPARAN')
Status #2 - whileStatement => K_WHILE ('T_LPARAN') @ expressionSequence ('T_RPARAN') statement
  To #3:  expressionSequence
Status #3 - whileStatement => K_WHILE ('T_LPARAN') expressionSequence @ ('T_RPARAN') statement
  To #4:  ('T_RPARAN')
Status #4 - whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
  To #5:  statement
Status #5 [FINAL] - whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement @

** Rule: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement
-- Tokens: K_WITH 
-- First-set tokens: K_WITH 
-- First-set rules: 
Status #0 - withStatement => @ K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement
  To #1:  K_WITH
Status #1 - withStatement => K_WITH @ ('T_LPARAN') expressionSequence ('T_RPARAN') statement
  To #2:  ('T_LPARAN')
Status #2 - withStatement => K_WITH ('T_LPARAN') @ expressionSequence ('T_RPARAN') statement
  To #3:  expressionSequence
Status #3 - withStatement => K_WITH ('T_LPARAN') expressionSequence @ ('T_RPARAN') statement
  To #4:  ('T_RPARAN')
Status #4 - withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
  To #5:  statement
Status #5 [FINAL] - withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement @

==== PDA  ====
** [Initial] State: program => @ sourceElements

** State #0: program => @ sourceElements
    --> __________________
    --> #1: sourceElements => [ @ sourceElements ] statement
    -->     Type: shift
    -->     LA: K_BREAK 'T_INC' 'T_LBRACE' K_DO K_WHILE 
    -->     LA: K_NEW K_FOR 'T_LPARAN' K_SUPER K_IF 
    -->     LA: K_FALSE #REGEX# K_VOID K_DELETE K_FUNCTION 
    -->     LA: K_THIS K_NULL 'T_DEC' 'T_SUB' K_TRUE 
    -->     LA: K_CLASS 'T_BIT_NOT' 'T_ADD' #STRING# 'T_SEMI' 
    -->     LA: K_SWITCH K_CONTINUE K_RETURN K_TRY 'T_LSQUARE' 
    -->     LA: K_VAR #ID# K_THROW K_DEBUGGER #NUMBER# 
    -->     LA: K_TYPEOF 'T_LOG_NOT' K_WITH 

** State #1: sourceElements => [ @ sourceElements ] statement
    --> __________________
    --> #2: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: shift
    -->     LA: K_TRY K_WITH 'T_LOG_NOT' K_TYPEOF #NUMBER# 
    -->     LA: K_DEBUGGER K_THROW #ID# K_VAR 'T_LSQUARE' 
    -->     LA: K_RETURN K_CONTINUE K_FUNCTION K_SWITCH 'T_SEMI' 
    -->     LA: #STRING# 'T_ADD' K_CLASS 'T_BIT_NOT' K_TRUE 
    -->     LA: 'T_SUB' 'T_DEC' K_NULL K_THIS K_VOID 
    -->     LA: K_DELETE #REGEX# K_SUPER K_FALSE K_IF 
    -->     LA: 'T_LPARAN' K_FOR K_NEW K_WHILE K_DO 
    -->     LA: 'T_LBRACE' 'T_INC' K_BREAK 

** State #2: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    --> __________________
    --> #3: functionDeclaration => @ K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: shift
    -->     LA: K_FUNCTION 
    --> __________________
    --> #4: block => @ ('T_LBRACE') [ statementList ] ('T_RBRACE')
    -->     Type: shift
    -->     LA: 'T_LBRACE' 
    --> __________________
    --> #5: variableStatement => @ K_VAR variableDeclarationList [ eos ]
    -->     Type: shift
    -->     LA: K_VAR 
    --> __________________
    --> #6: emptyStatement => @ 'T_SEMI'
    -->     Type: shift
    -->     LA: 'T_SEMI' 
    --> __________________
    --> #7: classDeclaration => @ K_CLASS #ID# classTail
    -->     Type: shift
    -->     LA: K_CLASS 
    --> __________________
    --> #8: expressionStatement => @ expressionSequence [ eos ]
    -->     Type: shift
    -->     LA: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' 
    -->     LA: K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF 
    -->     LA: K_NEW K_VOID #NUMBER# 'T_LBRACE' K_DELETE 
    -->     LA: K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# 
    -->     LA: K_CLASS K_SUPER #STRING# K_FALSE 
    --> __________________
    --> #9: ifStatement => @ K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement ]
    -->     Type: shift
    -->     LA: K_IF 
    --> __________________
    --> #10: iterationStatement => @ ( doStatement | whileStatement | forStatement | forInStatement )
    -->     Type: shift
    -->     LA: K_FOR K_WHILE K_DO 
    --> __________________
    --> #11: continueStatement => @ K_CONTINUE [ #ID# ] [ eos ]
    -->     Type: shift
    -->     LA: K_CONTINUE 
    --> __________________
    --> #12: breakStatement => @ K_BREAK [ #ID# ] [ eos ]
    -->     Type: shift
    -->     LA: K_BREAK 
    --> __________________
    --> #13: returnStatement => @ K_RETURN [ expressionSequence ] [ eos ]
    -->     Type: shift
    -->     LA: K_RETURN 
    --> __________________
    --> #14: withStatement => @ K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement
    -->     Type: shift
    -->     LA: K_WITH 
    --> __________________
    --> #15: labelledStatement => @ #ID# 'T_COLON' statement
    -->     Type: shift
    -->     LA: #ID# 
    --> __________________
    --> #16: switchStatement => @ K_SWITCH ('T_LPARAN') expressionSequence ('T_RPARAN') caseBlock
    -->     Type: shift
    -->     LA: K_SWITCH 
    --> __________________
    --> #17: throwStatement => @ K_THROW expressionSequence [ eos ]
    -->     Type: shift
    -->     LA: K_THROW 
    --> __________________
    --> #18: tryStatement => @ K_TRY block ( catchProduction [ finallyProduction ] | finallyProduction )
    -->     Type: shift
    -->     LA: K_TRY 
    --> __________________
    --> #19: debuggerStatement => @ K_DEBUGGER [ eos ]
    -->     Type: shift
    -->     LA: K_DEBUGGER 

** State #3: functionDeclaration => @ K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #20: functionDeclaration => K_FUNCTION @ #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: move
    -->     LA: K_FUNCTION 

** State #4: block => @ ('T_LBRACE') [ statementList ] ('T_RBRACE')
    --> __________________
    --> #21: block => ('T_LBRACE') @ [ statementList ] ('T_RBRACE')
    -->     Type: pass
    -->     LA: 'T_LBRACE' 

** State #5: variableStatement => @ K_VAR variableDeclarationList [ eos ]
    --> __________________
    --> #22: variableStatement => K_VAR @ variableDeclarationList [ eos ]
    -->     Type: move
    -->     LA: K_VAR 

** State #6: emptyStatement => @ 'T_SEMI'
    --> __________________
    --> #23: emptyStatement => 'T_SEMI' @
    -->     Type: move
    -->     LA: 'T_SEMI' 

** State #7: classDeclaration => @ K_CLASS #ID# classTail
    --> __________________
    --> #24: classDeclaration => K_CLASS @ #ID# classTail
    -->     Type: move
    -->     LA: K_CLASS 

** State #8: expressionStatement => @ expressionSequence [ eos ]
    --> __________________
    --> #25: expressionSequence => [ @ expressionSequence ('T_COMMA') ] singleExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #9: ifStatement => @ K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement ]
    --> __________________
    --> #26: ifStatement => K_IF @ ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement ]
    -->     Type: move
    -->     LA: K_IF 

** State #10: iterationStatement => @ ( doStatement | whileStatement | forStatement | forInStatement )
    --> __________________
    --> #30: forStatement => @ K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
    -->     Type: shift
    -->     LA: K_FOR 
    --> __________________
    --> #28: doStatement => @ K_DO statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    -->     Type: shift
    -->     LA: K_DO 
    --> __________________
    --> #29: whileStatement => @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement
    -->     Type: shift
    -->     LA: K_WHILE 
    --> __________________
    --> #27: forInStatement => @ K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement
    -->     Type: shift
    -->     LA: K_FOR 

** State #11: continueStatement => @ K_CONTINUE [ #ID# ] [ eos ]
    --> __________________
    --> #31: continueStatement => K_CONTINUE @ [ #ID# ] [ eos ]
    -->     Type: move
    -->     LA: K_CONTINUE 

** State #12: breakStatement => @ K_BREAK [ #ID# ] [ eos ]
    --> __________________
    --> #32: breakStatement => K_BREAK @ [ #ID# ] [ eos ]
    -->     Type: move
    -->     LA: K_BREAK 

** State #13: returnStatement => @ K_RETURN [ expressionSequence ] [ eos ]
    --> __________________
    --> #33: returnStatement => K_RETURN @ [ expressionSequence ] [ eos ]
    -->     Type: move
    -->     LA: K_RETURN 

** State #14: withStatement => @ K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement
    --> __________________
    --> #34: withStatement => K_WITH @ ('T_LPARAN') expressionSequence ('T_RPARAN') statement
    -->     Type: move
    -->     LA: K_WITH 

** State #15: labelledStatement => @ #ID# 'T_COLON' statement
    --> __________________
    --> #35: labelledStatement => #ID# @ 'T_COLON' statement
    -->     Type: move
    -->     LA: #ID# 

** State #16: switchStatement => @ K_SWITCH ('T_LPARAN') expressionSequence ('T_RPARAN') caseBlock
    --> __________________
    --> #36: switchStatement => K_SWITCH @ ('T_LPARAN') expressionSequence ('T_RPARAN') caseBlock
    -->     Type: move
    -->     LA: K_SWITCH 

** State #17: throwStatement => @ K_THROW expressionSequence [ eos ]
    --> __________________
    --> #37: throwStatement => K_THROW @ expressionSequence [ eos ]
    -->     Type: move
    -->     LA: K_THROW 

** State #18: tryStatement => @ K_TRY block ( catchProduction [ finallyProduction ] | finallyProduction )
    --> __________________
    --> #38: tryStatement => K_TRY @ block ( catchProduction [ finallyProduction ] | finallyProduction )
    -->     Type: move
    -->     LA: K_TRY 

** State #19: debuggerStatement => @ K_DEBUGGER [ eos ]
    --> __________________
    --> #39: debuggerStatement => K_DEBUGGER @ [ eos ]
    -->     Type: move
    -->     LA: K_DEBUGGER 

** State #20: functionDeclaration => K_FUNCTION @ #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #40: functionDeclaration => K_FUNCTION #ID# @ ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: move
    -->     LA: #ID# 

** State #21: block => ('T_LBRACE') @ [ statementList ] ('T_RBRACE')
    --> __________________
    --> #41: block => ('T_LBRACE') [ statementList ] ('T_RBRACE') @
    -->     Type: pass
    -->     LA: 'T_RBRACE' 
    --> __________________
    --> #42: statementList => [ @ statementList ] statement
    -->     Type: shift
    -->     LA: K_BREAK 'T_INC' 'T_LBRACE' K_DO K_WHILE 
    -->     LA: K_NEW K_FOR 'T_LPARAN' K_SUPER K_IF 
    -->     LA: K_FALSE #REGEX# K_VOID K_DELETE K_FUNCTION 
    -->     LA: K_THIS K_NULL 'T_DEC' 'T_SUB' K_TRUE 
    -->     LA: K_CLASS 'T_BIT_NOT' 'T_ADD' #STRING# 'T_SEMI' 
    -->     LA: K_SWITCH K_CONTINUE K_RETURN K_TRY 'T_LSQUARE' 
    -->     LA: K_VAR #ID# K_THROW K_DEBUGGER #NUMBER# 
    -->     LA: K_TYPEOF 'T_LOG_NOT' K_WITH 

** State #22: variableStatement => K_VAR @ variableDeclarationList [ eos ]
    --> __________________
    --> #43: variableDeclarationList => [ @ variableDeclarationList ('T_COMMA') ] variableDeclaration
    -->     Type: shift
    -->     LA: 'T_LSQUARE' 'T_LBRACE' #ID# 

** [FINAL] State #23: emptyStatement => 'T_SEMI' @
    --> __________________
    --> #44: classElement => ( methodDefinition | emptyStatement @ | [ 'T_SHARP' ] propertyName 'T_ASSIGN' singleExpression )
    -->     Type: reduce
    -->     Reduce: classElement => @ ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' singleExpression )
    --> __________________
    --> #45: statement => ( block | variableStatement | emptyStatement @ | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** State #24: classDeclaration => K_CLASS @ #ID# classTail
    --> __________________
    --> #46: classDeclaration => K_CLASS #ID# @ classTail
    -->     Type: move
    -->     LA: #ID# 

** State #25: expressionSequence => [ @ expressionSequence ('T_COMMA') ] singleExpression
    --> __________________
    --> #47: singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #26: ifStatement => K_IF @ ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement ]
    --> __________________
    --> #48: ifStatement => K_IF ('T_LPARAN') @ expressionSequence ('T_RPARAN') statement [ K_ELSE statement ]
    -->     Type: pass
    -->     LA: 'T_LPARAN' 

** State #27: forInStatement => @ K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement
    --> __________________
    --> #49: forInStatement => K_FOR @ ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement
    -->     Type: move
    -->     LA: K_FOR 

** State #28: doStatement => @ K_DO statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #50: doStatement => K_DO @ statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    -->     Type: move
    -->     LA: K_DO 

** State #29: whileStatement => @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement
    --> __________________
    --> #51: whileStatement => K_WHILE @ ('T_LPARAN') expressionSequence ('T_RPARAN') statement
    -->     Type: move
    -->     LA: K_WHILE 

** State #30: forStatement => @ K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
    --> __________________
    --> #52: forStatement => K_FOR @ ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
    -->     Type: move
    -->     LA: K_FOR 

** [FINAL] State #31: continueStatement => K_CONTINUE @ [ #ID# ] [ eos ]
    --> __________________
    --> #53: eos => @ ( 'T_SEMI' | #END# )
    -->     Type: shift
    -->     LA: 'T_SEMI' #END# 
    --> __________________
    --> #54: continueStatement => K_CONTINUE [ #ID# @ ] [ eos ]
    -->     Type: move
    -->     LA: #ID# 
    --> __________________
    --> #55: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement @ | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** [FINAL] State #32: breakStatement => K_BREAK @ [ #ID# ] [ eos ]
    --> __________________
    --> #53: eos => @ ( 'T_SEMI' | #END# )
    -->     Type: shift
    -->     LA: 'T_SEMI' #END# 
    --> __________________
    --> #56: breakStatement => K_BREAK [ #ID# @ ] [ eos ]
    -->     Type: move
    -->     LA: #ID# 
    --> __________________
    --> #57: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement @ | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** [FINAL] State #33: returnStatement => K_RETURN @ [ expressionSequence ] [ eos ]
    --> __________________
    --> #53: eos => @ ( 'T_SEMI' | #END# )
    -->     Type: shift
    -->     LA: 'T_SEMI' #END# 
    --> __________________
    --> #25: expressionSequence => [ @ expressionSequence ('T_COMMA') ] singleExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 
    --> __________________
    --> #58: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement @ | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** State #34: withStatement => K_WITH @ ('T_LPARAN') expressionSequence ('T_RPARAN') statement
    --> __________________
    --> #59: withStatement => K_WITH ('T_LPARAN') @ expressionSequence ('T_RPARAN') statement
    -->     Type: pass
    -->     LA: 'T_LPARAN' 

** State #35: labelledStatement => #ID# @ 'T_COLON' statement
    --> __________________
    --> #60: labelledStatement => #ID# 'T_COLON' @ statement
    -->     Type: move
    -->     LA: 'T_COLON' 

** State #36: switchStatement => K_SWITCH @ ('T_LPARAN') expressionSequence ('T_RPARAN') caseBlock
    --> __________________
    --> #61: switchStatement => K_SWITCH ('T_LPARAN') @ expressionSequence ('T_RPARAN') caseBlock
    -->     Type: pass
    -->     LA: 'T_LPARAN' 

** State #37: throwStatement => K_THROW @ expressionSequence [ eos ]
    --> __________________
    --> #25: expressionSequence => [ @ expressionSequence ('T_COMMA') ] singleExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #38: tryStatement => K_TRY @ block ( catchProduction [ finallyProduction ] | finallyProduction )
    --> __________________
    --> #4: block => @ ('T_LBRACE') [ statementList ] ('T_RBRACE')
    -->     Type: shift
    -->     LA: 'T_LBRACE' 

** [FINAL] State #39: debuggerStatement => K_DEBUGGER @ [ eos ]
    --> __________________
    --> #53: eos => @ ( 'T_SEMI' | #END# )
    -->     Type: shift
    -->     LA: 'T_SEMI' #END# 
    --> __________________
    --> #62: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement @ | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** State #40: functionDeclaration => K_FUNCTION #ID# @ ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #63: functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') @ [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: pass
    -->     LA: 'T_LPARAN' 

** [FINAL] State #41: block => ('T_LBRACE') [ statementList ] ('T_RBRACE') @
    --> __________________
    --> #64: catchProduction => K_CATCH [ ('T_LPARAN') [ assignable ] ('T_RPARAN') ] block @
    -->     Type: reduce
    -->     Reduce: catchProduction => K_CATCH @ [ ('T_LPARAN') [ assignable ] ('T_RPARAN') ] block
    --> __________________
    --> #64: catchProduction => K_CATCH [ ('T_LPARAN') [ assignable ] ('T_RPARAN') ] block @
    -->     Type: reduce
    -->     Reduce: catchProduction => K_CATCH [ ('T_LPARAN') [ assignable ] ('T_RPARAN') @ ] block
    --> __________________
    --> #65: finallyProduction => K_FINALLY block @
    -->     Type: reduce
    -->     Reduce: finallyProduction => K_FINALLY @ block
    --> __________________
    --> #66: statement => ( block @ | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    --> __________________
    --> #67: tryStatement => K_TRY block @ ( catchProduction [ finallyProduction ] | finallyProduction )
    -->     Type: reduce
    -->     Reduce: tryStatement => K_TRY @ block ( catchProduction [ finallyProduction ] | finallyProduction )

** State #42: statementList => [ @ statementList ] statement
    --> __________________
    --> #2: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: shift
    -->     LA: K_TRY K_WITH 'T_LOG_NOT' K_TYPEOF #NUMBER# 
    -->     LA: K_DEBUGGER K_THROW #ID# K_VAR 'T_LSQUARE' 
    -->     LA: K_RETURN K_CONTINUE K_FUNCTION K_SWITCH 'T_SEMI' 
    -->     LA: #STRING# 'T_ADD' K_CLASS 'T_BIT_NOT' K_TRUE 
    -->     LA: 'T_SUB' 'T_DEC' K_NULL K_THIS K_VOID 
    -->     LA: K_DELETE #REGEX# K_SUPER K_FALSE K_IF 
    -->     LA: 'T_LPARAN' K_FOR K_NEW K_WHILE K_DO 
    -->     LA: 'T_LBRACE' 'T_INC' K_BREAK 

** State #43: variableDeclarationList => [ @ variableDeclarationList ('T_COMMA') ] variableDeclaration
    --> __________________
    --> #68: variableDeclaration => @ assignable [ 'T_ASSIGN' singleExpression ]
    -->     Type: shift
    -->     LA: #ID# 'T_LBRACE' 'T_LSQUARE' 

** [FINAL] State #44: classElement => ( methodDefinition | emptyStatement @ | [ 'T_SHARP' ] propertyName 'T_ASSIGN' singleExpression )
    --> __________________
    --> #69: classElements => [ classElements ('T_COMMA') ] classElement @
    -->     Type: reduce
    -->     Reduce: classElements => [ @ classElements ('T_COMMA') ] classElement
    --> __________________
    --> #69: classElements => [ classElements ('T_COMMA') ] classElement @
    -->     Type: reduce
    -->     Reduce: classElements => [ classElements ('T_COMMA') @ ] classElement

** [FINAL] State #45: statement => ( block | variableStatement | emptyStatement @ | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    --> __________________
    --> #70: doStatement => K_DO statement @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    -->     Type: reduce
    -->     Reduce: doStatement => K_DO @ statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #71: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #72: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') @ statement
    --> __________________
    --> #73: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement @ [ K_ELSE statement ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement [ K_ELSE statement ]
    --> __________________
    --> #74: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement @ ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE @ statement ]
    --> __________________
    --> #75: labelledStatement => #ID# 'T_COLON' statement @
    -->     Type: reduce
    -->     Reduce: labelledStatement => #ID# 'T_COLON' @ statement
    --> __________________
    --> #76: sourceElement => statement @
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #77: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ @ sourceElements ] statement
    --> __________________
    --> #77: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ sourceElements @ ] statement
    --> __________________
    --> #78: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ @ statementList ] statement
    --> __________________
    --> #78: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ statementList @ ] statement
    --> __________________
    --> #79: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #80: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement

** State #46: classDeclaration => K_CLASS #ID# @ classTail
    --> __________________
    --> #81: classTail => @ ('T_LBRACE') classElements ('T_RBRACE')
    -->     Type: shift
    -->     LA: 'T_LBRACE' 

** State #47: singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    --> __________________
    --> #82: assignmentExpression => [ @ assignmentExpression 'T_ASSIGN' ] assignmentOperatorExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #48: ifStatement => K_IF ('T_LPARAN') @ expressionSequence ('T_RPARAN') statement [ K_ELSE statement ]
    --> __________________
    --> #25: expressionSequence => [ @ expressionSequence ('T_COMMA') ] singleExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #49: forInStatement => K_FOR @ ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement
    --> __________________
    --> #83: forInStatement => K_FOR ('T_LPARAN') @ [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement
    -->     Type: pass
    -->     LA: 'T_LPARAN' 

** State #50: doStatement => K_DO @ statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #2: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: shift
    -->     LA: K_TRY K_WITH 'T_LOG_NOT' K_TYPEOF #NUMBER# 
    -->     LA: K_DEBUGGER K_THROW #ID# K_VAR 'T_LSQUARE' 
    -->     LA: K_RETURN K_CONTINUE K_FUNCTION K_SWITCH 'T_SEMI' 
    -->     LA: #STRING# 'T_ADD' K_CLASS 'T_BIT_NOT' K_TRUE 
    -->     LA: 'T_SUB' 'T_DEC' K_NULL K_THIS K_VOID 
    -->     LA: K_DELETE #REGEX# K_SUPER K_FALSE K_IF 
    -->     LA: 'T_LPARAN' K_FOR K_NEW K_WHILE K_DO 
    -->     LA: 'T_LBRACE' 'T_INC' K_BREAK 

** State #51: whileStatement => K_WHILE @ ('T_LPARAN') expressionSequence ('T_RPARAN') statement
    --> __________________
    --> #84: whileStatement => K_WHILE ('T_LPARAN') @ expressionSequence ('T_RPARAN') statement
    -->     Type: pass
    -->     LA: 'T_LPARAN' 

** State #52: forStatement => K_FOR @ ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
    --> __________________
    --> #85: forStatement => K_FOR ('T_LPARAN') @ [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
    -->     Type: pass
    -->     LA: 'T_LPARAN' 

** State #53: eos => @ ( 'T_SEMI' | #END# )
    --> __________________
    --> #86: eos => ( 'T_SEMI' | #END# @ )
    -->     Type: move
    -->     LA: #END# 
    --> __________________
    --> #87: eos => ( 'T_SEMI' @ | #END# )
    -->     Type: move
    -->     LA: 'T_SEMI' 

** [FINAL] State #54: continueStatement => K_CONTINUE [ #ID# @ ] [ eos ]
    --> __________________
    --> #53: eos => @ ( 'T_SEMI' | #END# )
    -->     Type: shift
    -->     LA: 'T_SEMI' #END# 
    --> __________________
    --> #55: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement @ | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** [FINAL] State #55: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement @ | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    --> __________________
    --> #70: doStatement => K_DO statement @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    -->     Type: reduce
    -->     Reduce: doStatement => K_DO @ statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #71: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #72: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') @ statement
    --> __________________
    --> #73: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement @ [ K_ELSE statement ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement [ K_ELSE statement ]
    --> __________________
    --> #74: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement @ ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE @ statement ]
    --> __________________
    --> #75: labelledStatement => #ID# 'T_COLON' statement @
    -->     Type: reduce
    -->     Reduce: labelledStatement => #ID# 'T_COLON' @ statement
    --> __________________
    --> #76: sourceElement => statement @
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #77: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ @ sourceElements ] statement
    --> __________________
    --> #77: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ sourceElements @ ] statement
    --> __________________
    --> #78: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ @ statementList ] statement
    --> __________________
    --> #78: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ statementList @ ] statement
    --> __________________
    --> #79: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #80: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement

** [FINAL] State #56: breakStatement => K_BREAK [ #ID# @ ] [ eos ]
    --> __________________
    --> #53: eos => @ ( 'T_SEMI' | #END# )
    -->     Type: shift
    -->     LA: 'T_SEMI' #END# 
    --> __________________
    --> #57: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement @ | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** [FINAL] State #57: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement @ | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    --> __________________
    --> #70: doStatement => K_DO statement @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    -->     Type: reduce
    -->     Reduce: doStatement => K_DO @ statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #71: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #72: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') @ statement
    --> __________________
    --> #73: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement @ [ K_ELSE statement ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement [ K_ELSE statement ]
    --> __________________
    --> #74: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement @ ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE @ statement ]
    --> __________________
    --> #75: labelledStatement => #ID# 'T_COLON' statement @
    -->     Type: reduce
    -->     Reduce: labelledStatement => #ID# 'T_COLON' @ statement
    --> __________________
    --> #76: sourceElement => statement @
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #77: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ @ sourceElements ] statement
    --> __________________
    --> #77: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ sourceElements @ ] statement
    --> __________________
    --> #78: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ @ statementList ] statement
    --> __________________
    --> #78: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ statementList @ ] statement
    --> __________________
    --> #79: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #80: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement

** [FINAL] State #58: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement @ | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    --> __________________
    --> #70: doStatement => K_DO statement @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    -->     Type: reduce
    -->     Reduce: doStatement => K_DO @ statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #71: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #72: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') @ statement
    --> __________________
    --> #73: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement @ [ K_ELSE statement ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement [ K_ELSE statement ]
    --> __________________
    --> #74: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement @ ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE @ statement ]
    --> __________________
    --> #75: labelledStatement => #ID# 'T_COLON' statement @
    -->     Type: reduce
    -->     Reduce: labelledStatement => #ID# 'T_COLON' @ statement
    --> __________________
    --> #76: sourceElement => statement @
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #77: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ @ sourceElements ] statement
    --> __________________
    --> #77: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ sourceElements @ ] statement
    --> __________________
    --> #78: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ @ statementList ] statement
    --> __________________
    --> #78: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ statementList @ ] statement
    --> __________________
    --> #79: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #80: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement

** State #59: withStatement => K_WITH ('T_LPARAN') @ expressionSequence ('T_RPARAN') statement
    --> __________________
    --> #25: expressionSequence => [ @ expressionSequence ('T_COMMA') ] singleExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #60: labelledStatement => #ID# 'T_COLON' @ statement
    --> __________________
    --> #2: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: shift
    -->     LA: K_TRY K_WITH 'T_LOG_NOT' K_TYPEOF #NUMBER# 
    -->     LA: K_DEBUGGER K_THROW #ID# K_VAR 'T_LSQUARE' 
    -->     LA: K_RETURN K_CONTINUE K_FUNCTION K_SWITCH 'T_SEMI' 
    -->     LA: #STRING# 'T_ADD' K_CLASS 'T_BIT_NOT' K_TRUE 
    -->     LA: 'T_SUB' 'T_DEC' K_NULL K_THIS K_VOID 
    -->     LA: K_DELETE #REGEX# K_SUPER K_FALSE K_IF 
    -->     LA: 'T_LPARAN' K_FOR K_NEW K_WHILE K_DO 
    -->     LA: 'T_LBRACE' 'T_INC' K_BREAK 

** State #61: switchStatement => K_SWITCH ('T_LPARAN') @ expressionSequence ('T_RPARAN') caseBlock
    --> __________________
    --> #25: expressionSequence => [ @ expressionSequence ('T_COMMA') ] singleExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #62: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement @ | functionDeclaration )
    --> __________________
    --> #70: doStatement => K_DO statement @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    -->     Type: reduce
    -->     Reduce: doStatement => K_DO @ statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #71: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #72: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') @ statement
    --> __________________
    --> #73: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement @ [ K_ELSE statement ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement [ K_ELSE statement ]
    --> __________________
    --> #74: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement @ ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE @ statement ]
    --> __________________
    --> #75: labelledStatement => #ID# 'T_COLON' statement @
    -->     Type: reduce
    -->     Reduce: labelledStatement => #ID# 'T_COLON' @ statement
    --> __________________
    --> #76: sourceElement => statement @
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #77: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ @ sourceElements ] statement
    --> __________________
    --> #77: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ sourceElements @ ] statement
    --> __________________
    --> #78: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ @ statementList ] statement
    --> __________________
    --> #78: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ statementList @ ] statement
    --> __________________
    --> #79: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #80: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement

** State #63: functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') @ [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #88: functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') @ ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: pass
    -->     LA: 'T_RPARAN' 
    --> __________________
    --> #89: formalParameterList => [ @ formalParameterList ('T_COMMA') ] assignable
    -->     Type: shift
    -->     LA: 'T_LSQUARE' 'T_LBRACE' #ID# 

** [FINAL] State #64: catchProduction => K_CATCH [ ('T_LPARAN') [ assignable ] ('T_RPARAN') ] block @
    --> __________________
    --> #90: tryStatement => K_TRY block ( catchProduction @ [ finallyProduction ] | finallyProduction )
    -->     Type: reduce
    -->     Reduce: tryStatement => K_TRY block @ ( catchProduction [ finallyProduction ] | finallyProduction )

** [FINAL] State #65: finallyProduction => K_FINALLY block @
    --> __________________
    --> #91: tryStatement => K_TRY block ( catchProduction [ finallyProduction ] | finallyProduction @ )
    -->     Type: reduce
    -->     Reduce: tryStatement => K_TRY block @ ( catchProduction [ finallyProduction ] | finallyProduction )
    --> __________________
    --> #92: tryStatement => K_TRY block ( catchProduction [ finallyProduction @ ] | finallyProduction )
    -->     Type: reduce
    -->     Reduce: tryStatement => K_TRY block ( catchProduction @ [ finallyProduction ] | finallyProduction )

** [FINAL] State #66: statement => ( block @ | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    --> __________________
    --> #70: doStatement => K_DO statement @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    -->     Type: reduce
    -->     Reduce: doStatement => K_DO @ statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #71: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #72: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') @ statement
    --> __________________
    --> #73: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement @ [ K_ELSE statement ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement [ K_ELSE statement ]
    --> __________________
    --> #74: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement @ ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE @ statement ]
    --> __________________
    --> #75: labelledStatement => #ID# 'T_COLON' statement @
    -->     Type: reduce
    -->     Reduce: labelledStatement => #ID# 'T_COLON' @ statement
    --> __________________
    --> #76: sourceElement => statement @
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #77: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ @ sourceElements ] statement
    --> __________________
    --> #77: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ sourceElements @ ] statement
    --> __________________
    --> #78: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ @ statementList ] statement
    --> __________________
    --> #78: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ statementList @ ] statement
    --> __________________
    --> #79: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #80: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement

** State #67: tryStatement => K_TRY block @ ( catchProduction [ finallyProduction ] | finallyProduction )
    --> __________________
    --> #93: finallyProduction => @ K_FINALLY block
    -->     Type: shift
    -->     LA: K_FINALLY 
    --> __________________
    --> #94: catchProduction => @ K_CATCH [ ('T_LPARAN') [ assignable ] ('T_RPARAN') ] block
    -->     Type: shift
    -->     LA: K_CATCH 

** State #68: variableDeclaration => @ assignable [ 'T_ASSIGN' singleExpression ]
    --> __________________
    --> #95: assignable => @ ( #ID# | arrayLiteral | objectLiteral )
    -->     Type: shift
    -->     LA: #ID# 'T_LBRACE' 'T_LSQUARE' 

** [FINAL] State #69: classElements => [ classElements ('T_COMMA') ] classElement @
    --> __________________
    --> #96: classElements => [ classElements @ ('T_COMMA') ] classElement
    -->     Type: recursion
    -->     LA: 'T_COMMA' 
    --> __________________
    --> #97: classTail => ('T_LBRACE') classElements @ ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: classTail => ('T_LBRACE') @ classElements ('T_RBRACE')

** State #70: doStatement => K_DO statement @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #98: doStatement => K_DO statement K_WHILE @ ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    -->     Type: move
    -->     LA: K_WHILE 

** [FINAL] State #71: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement @
    --> __________________
    --> #99: iterationStatement => ( doStatement | whileStatement | forStatement | forInStatement @ )
    -->     Type: reduce
    -->     Reduce: iterationStatement => @ ( doStatement | whileStatement | forStatement | forInStatement )

** [FINAL] State #72: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement @
    --> __________________
    --> #100: iterationStatement => ( doStatement | whileStatement | forStatement @ | forInStatement )
    -->     Type: reduce
    -->     Reduce: iterationStatement => @ ( doStatement | whileStatement | forStatement | forInStatement )

** [FINAL] State #73: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement @ [ K_ELSE statement ]
    --> __________________
    --> #101: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE @ statement ]
    -->     Type: move
    -->     LA: K_ELSE 
    --> __________________
    --> #102: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement @ | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** [FINAL] State #74: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement @ ]
    --> __________________
    --> #102: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement @ | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** [FINAL] State #75: labelledStatement => #ID# 'T_COLON' statement @
    --> __________________
    --> #103: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement @ | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** [FINAL] State #76: sourceElement => statement @

** [FINAL] State #77: sourceElements => [ sourceElements ] statement @
    --> __________________
    --> #104: functionBody => [ functionBody ] sourceElements @
    -->     Type: reduce
    -->     Reduce: functionBody => [ @ functionBody ] sourceElements
    --> __________________
    --> #104: functionBody => [ functionBody ] sourceElements @
    -->     Type: reduce
    -->     Reduce: functionBody => [ functionBody @ ] sourceElements
    --> __________________
    --> #105: program => sourceElements @
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #106: sourceElements => [ sourceElements @ ] statement
    -->     Type: recursion
    -->     LA: K_TRY K_WITH 'T_LOG_NOT' K_TYPEOF #NUMBER# 
    -->     LA: K_DEBUGGER K_THROW #ID# K_VAR 'T_LSQUARE' 
    -->     LA: K_RETURN K_CONTINUE K_FUNCTION K_SWITCH 'T_SEMI' 
    -->     LA: #STRING# 'T_ADD' K_CLASS 'T_BIT_NOT' K_TRUE 
    -->     LA: 'T_SUB' 'T_DEC' K_NULL K_THIS K_VOID 
    -->     LA: K_DELETE #REGEX# K_SUPER K_FALSE K_IF 
    -->     LA: 'T_LPARAN' K_FOR K_NEW K_WHILE K_DO 
    -->     LA: 'T_LBRACE' 'T_INC' K_BREAK 

** [FINAL] State #78: statementList => [ statementList ] statement @
    --> __________________
    --> #107: block => ('T_LBRACE') [ statementList @ ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: block => ('T_LBRACE') @ [ statementList ] ('T_RBRACE')
    --> __________________
    --> #108: caseClause => K_CASE expressionSequence 'T_COLON' [ statementList @ ]
    -->     Type: reduce
    -->     Reduce: caseClause => K_CASE expressionSequence 'T_COLON' @ [ statementList ]
    --> __________________
    --> #109: defaultClause => K_DEFAULT 'T_COLON' [ statementList @ ]
    -->     Type: reduce
    -->     Reduce: defaultClause => K_DEFAULT 'T_COLON' @ [ statementList ]
    --> __________________
    --> #110: statementList => [ statementList @ ] statement
    -->     Type: recursion
    -->     LA: K_TRY K_WITH 'T_LOG_NOT' K_TYPEOF #NUMBER# 
    -->     LA: K_DEBUGGER K_THROW #ID# K_VAR 'T_LSQUARE' 
    -->     LA: K_RETURN K_CONTINUE K_FUNCTION K_SWITCH 'T_SEMI' 
    -->     LA: #STRING# 'T_ADD' K_CLASS 'T_BIT_NOT' K_TRUE 
    -->     LA: 'T_SUB' 'T_DEC' K_NULL K_THIS K_VOID 
    -->     LA: K_DELETE #REGEX# K_SUPER K_FALSE K_IF 
    -->     LA: 'T_LPARAN' K_FOR K_NEW K_WHILE K_DO 
    -->     LA: 'T_LBRACE' 'T_INC' K_BREAK 

** [FINAL] State #79: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    --> __________________
    --> #111: iterationStatement => ( doStatement | whileStatement @ | forStatement | forInStatement )
    -->     Type: reduce
    -->     Reduce: iterationStatement => @ ( doStatement | whileStatement | forStatement | forInStatement )

** [FINAL] State #80: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    --> __________________
    --> #112: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement @ | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** State #81: classTail => @ ('T_LBRACE') classElements ('T_RBRACE')
    --> __________________
    --> #113: classTail => ('T_LBRACE') @ classElements ('T_RBRACE')
    -->     Type: pass
    -->     LA: 'T_LBRACE' 

** State #82: assignmentExpression => [ @ assignmentExpression 'T_ASSIGN' ] assignmentOperatorExpression
    --> __________________
    --> #114: assignmentOperatorExpression => [ @ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #83: forInStatement => K_FOR ('T_LPARAN') @ [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement
    --> __________________
    --> #115: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN @ expressionSequence ('T_RPARAN') statement
    -->     Type: move
    -->     LA: K_IN 
    --> __________________
    --> #47: singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 
    --> __________________
    --> #116: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR @ variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement
    -->     Type: move
    -->     LA: K_VAR 

** State #84: whileStatement => K_WHILE ('T_LPARAN') @ expressionSequence ('T_RPARAN') statement
    --> __________________
    --> #25: expressionSequence => [ @ expressionSequence ('T_COMMA') ] singleExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #85: forStatement => K_FOR ('T_LPARAN') @ [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
    --> __________________
    --> #117: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' @ [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
    -->     Type: move
    -->     LA: 'T_SEMI' 
    --> __________________
    --> #25: expressionSequence => [ @ expressionSequence ('T_COMMA') ] singleExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 
    --> __________________
    --> #118: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR @ variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
    -->     Type: move
    -->     LA: K_VAR 

** [FINAL] State #86: eos => ( 'T_SEMI' | #END# @ )
    --> __________________
    --> #119: breakStatement => K_BREAK [ #ID# ] [ eos @ ]
    -->     Type: reduce
    -->     Reduce: breakStatement => K_BREAK @ [ #ID# ] [ eos ]
    --> __________________
    --> #119: breakStatement => K_BREAK [ #ID# ] [ eos @ ]
    -->     Type: reduce
    -->     Reduce: breakStatement => K_BREAK [ #ID# @ ] [ eos ]
    --> __________________
    --> #120: continueStatement => K_CONTINUE [ #ID# ] [ eos @ ]
    -->     Type: reduce
    -->     Reduce: continueStatement => K_CONTINUE @ [ #ID# ] [ eos ]
    --> __________________
    --> #120: continueStatement => K_CONTINUE [ #ID# ] [ eos @ ]
    -->     Type: reduce
    -->     Reduce: continueStatement => K_CONTINUE [ #ID# @ ] [ eos ]
    --> __________________
    --> #121: debuggerStatement => K_DEBUGGER [ eos @ ]
    -->     Type: reduce
    -->     Reduce: debuggerStatement => K_DEBUGGER @ [ eos ]
    --> __________________
    --> #122: doStatement => K_DO statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos @ ]
    -->     Type: reduce
    -->     Reduce: doStatement => K_DO statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ [ eos ]
    --> __________________
    --> #123: expressionStatement => expressionSequence [ eos @ ]
    -->     Type: reduce
    -->     Reduce: expressionStatement => expressionSequence @ [ eos ]
    --> __________________
    --> #124: returnStatement => K_RETURN [ expressionSequence ] [ eos @ ]
    -->     Type: reduce
    -->     Reduce: returnStatement => K_RETURN @ [ expressionSequence ] [ eos ]
    --> __________________
    --> #124: returnStatement => K_RETURN [ expressionSequence ] [ eos @ ]
    -->     Type: reduce
    -->     Reduce: returnStatement => K_RETURN [ expressionSequence @ ] [ eos ]
    --> __________________
    --> #125: throwStatement => K_THROW expressionSequence [ eos @ ]
    -->     Type: reduce
    -->     Reduce: throwStatement => K_THROW expressionSequence @ [ eos ]
    --> __________________
    --> #126: variableStatement => K_VAR variableDeclarationList [ eos @ ]
    -->     Type: reduce
    -->     Reduce: variableStatement => K_VAR variableDeclarationList @ [ eos ]

** [FINAL] State #87: eos => ( 'T_SEMI' @ | #END# )
    --> __________________
    --> #119: breakStatement => K_BREAK [ #ID# ] [ eos @ ]
    -->     Type: reduce
    -->     Reduce: breakStatement => K_BREAK @ [ #ID# ] [ eos ]
    --> __________________
    --> #119: breakStatement => K_BREAK [ #ID# ] [ eos @ ]
    -->     Type: reduce
    -->     Reduce: breakStatement => K_BREAK [ #ID# @ ] [ eos ]
    --> __________________
    --> #120: continueStatement => K_CONTINUE [ #ID# ] [ eos @ ]
    -->     Type: reduce
    -->     Reduce: continueStatement => K_CONTINUE @ [ #ID# ] [ eos ]
    --> __________________
    --> #120: continueStatement => K_CONTINUE [ #ID# ] [ eos @ ]
    -->     Type: reduce
    -->     Reduce: continueStatement => K_CONTINUE [ #ID# @ ] [ eos ]
    --> __________________
    --> #121: debuggerStatement => K_DEBUGGER [ eos @ ]
    -->     Type: reduce
    -->     Reduce: debuggerStatement => K_DEBUGGER @ [ eos ]
    --> __________________
    --> #122: doStatement => K_DO statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos @ ]
    -->     Type: reduce
    -->     Reduce: doStatement => K_DO statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ [ eos ]
    --> __________________
    --> #123: expressionStatement => expressionSequence [ eos @ ]
    -->     Type: reduce
    -->     Reduce: expressionStatement => expressionSequence @ [ eos ]
    --> __________________
    --> #124: returnStatement => K_RETURN [ expressionSequence ] [ eos @ ]
    -->     Type: reduce
    -->     Reduce: returnStatement => K_RETURN @ [ expressionSequence ] [ eos ]
    --> __________________
    --> #124: returnStatement => K_RETURN [ expressionSequence ] [ eos @ ]
    -->     Type: reduce
    -->     Reduce: returnStatement => K_RETURN [ expressionSequence @ ] [ eos ]
    --> __________________
    --> #125: throwStatement => K_THROW expressionSequence [ eos @ ]
    -->     Type: reduce
    -->     Reduce: throwStatement => K_THROW expressionSequence @ [ eos ]
    --> __________________
    --> #126: variableStatement => K_VAR variableDeclarationList [ eos @ ]
    -->     Type: reduce
    -->     Reduce: variableStatement => K_VAR variableDeclarationList @ [ eos ]

** State #88: functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') @ ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #127: functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') @ [ functionBody ] ('T_RBRACE')
    -->     Type: pass
    -->     LA: 'T_LBRACE' 

** State #89: formalParameterList => [ @ formalParameterList ('T_COMMA') ] assignable
    --> __________________
    --> #95: assignable => @ ( #ID# | arrayLiteral | objectLiteral )
    -->     Type: shift
    -->     LA: #ID# 'T_LBRACE' 'T_LSQUARE' 

** [FINAL] State #90: tryStatement => K_TRY block ( catchProduction @ [ finallyProduction ] | finallyProduction )
    --> __________________
    --> #93: finallyProduction => @ K_FINALLY block
    -->     Type: shift
    -->     LA: K_FINALLY 
    --> __________________
    --> #128: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement @ | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** [FINAL] State #91: tryStatement => K_TRY block ( catchProduction [ finallyProduction ] | finallyProduction @ )
    --> __________________
    --> #128: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement @ | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** [FINAL] State #92: tryStatement => K_TRY block ( catchProduction [ finallyProduction @ ] | finallyProduction )
    --> __________________
    --> #128: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement @ | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** State #93: finallyProduction => @ K_FINALLY block
    --> __________________
    --> #129: finallyProduction => K_FINALLY @ block
    -->     Type: move
    -->     LA: K_FINALLY 

** State #94: catchProduction => @ K_CATCH [ ('T_LPARAN') [ assignable ] ('T_RPARAN') ] block
    --> __________________
    --> #130: catchProduction => K_CATCH @ [ ('T_LPARAN') [ assignable ] ('T_RPARAN') ] block
    -->     Type: move
    -->     LA: K_CATCH 

** State #95: assignable => @ ( #ID# | arrayLiteral | objectLiteral )
    --> __________________
    --> #131: objectLiteral => @ ('T_LBRACE') [ propertyAssignments ] [ ('T_COMMA') ] ('T_RBRACE')
    -->     Type: shift
    -->     LA: 'T_LBRACE' 
    --> __________________
    --> #132: assignable => ( #ID# @ | arrayLiteral | objectLiteral )
    -->     Type: move
    -->     LA: #ID# 
    --> __________________
    --> #133: arrayLiteral => @ ('T_LSQUARE') [ elementList ] ('T_RSQUARE')
    -->     Type: shift
    -->     LA: 'T_LSQUARE' 

** State #96: classElements => [ classElements @ ('T_COMMA') ] classElement
    --> __________________
    --> #134: classElements => [ classElements ('T_COMMA') @ ] classElement
    -->     Type: pass
    -->     LA: 'T_COMMA' 

** State #97: classTail => ('T_LBRACE') classElements @ ('T_RBRACE')
    --> __________________
    --> #135: classTail => ('T_LBRACE') classElements ('T_RBRACE') @
    -->     Type: pass
    -->     LA: 'T_RBRACE' 

** State #98: doStatement => K_DO statement K_WHILE @ ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #136: doStatement => K_DO statement K_WHILE ('T_LPARAN') @ expressionSequence ('T_RPARAN') [ eos ]
    -->     Type: pass
    -->     LA: 'T_LPARAN' 

** [FINAL] State #99: iterationStatement => ( doStatement | whileStatement | forStatement | forInStatement @ )
    --> __________________
    --> #137: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement @ | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** [FINAL] State #100: iterationStatement => ( doStatement | whileStatement | forStatement @ | forInStatement )
    --> __________________
    --> #137: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement @ | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** State #101: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE @ statement ]
    --> __________________
    --> #2: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: shift
    -->     LA: K_TRY K_WITH 'T_LOG_NOT' K_TYPEOF #NUMBER# 
    -->     LA: K_DEBUGGER K_THROW #ID# K_VAR 'T_LSQUARE' 
    -->     LA: K_RETURN K_CONTINUE K_FUNCTION K_SWITCH 'T_SEMI' 
    -->     LA: #STRING# 'T_ADD' K_CLASS 'T_BIT_NOT' K_TRUE 
    -->     LA: 'T_SUB' 'T_DEC' K_NULL K_THIS K_VOID 
    -->     LA: K_DELETE #REGEX# K_SUPER K_FALSE K_IF 
    -->     LA: 'T_LPARAN' K_FOR K_NEW K_WHILE K_DO 
    -->     LA: 'T_LBRACE' 'T_INC' K_BREAK 

** [FINAL] State #102: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement @ | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    --> __________________
    --> #70: doStatement => K_DO statement @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    -->     Type: reduce
    -->     Reduce: doStatement => K_DO @ statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #71: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #72: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') @ statement
    --> __________________
    --> #73: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement @ [ K_ELSE statement ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement [ K_ELSE statement ]
    --> __________________
    --> #74: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement @ ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE @ statement ]
    --> __________________
    --> #75: labelledStatement => #ID# 'T_COLON' statement @
    -->     Type: reduce
    -->     Reduce: labelledStatement => #ID# 'T_COLON' @ statement
    --> __________________
    --> #76: sourceElement => statement @
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #77: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ @ sourceElements ] statement
    --> __________________
    --> #77: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ sourceElements @ ] statement
    --> __________________
    --> #78: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ @ statementList ] statement
    --> __________________
    --> #78: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ statementList @ ] statement
    --> __________________
    --> #79: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #80: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement

** [FINAL] State #103: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement @ | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    --> __________________
    --> #70: doStatement => K_DO statement @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    -->     Type: reduce
    -->     Reduce: doStatement => K_DO @ statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #71: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #72: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') @ statement
    --> __________________
    --> #73: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement @ [ K_ELSE statement ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement [ K_ELSE statement ]
    --> __________________
    --> #74: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement @ ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE @ statement ]
    --> __________________
    --> #75: labelledStatement => #ID# 'T_COLON' statement @
    -->     Type: reduce
    -->     Reduce: labelledStatement => #ID# 'T_COLON' @ statement
    --> __________________
    --> #76: sourceElement => statement @
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #77: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ @ sourceElements ] statement
    --> __________________
    --> #77: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ sourceElements @ ] statement
    --> __________________
    --> #78: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ @ statementList ] statement
    --> __________________
    --> #78: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ statementList @ ] statement
    --> __________________
    --> #79: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #80: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement

** [FINAL] State #104: functionBody => [ functionBody ] sourceElements @
    --> __________________
    --> #138: anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody @ ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') @ [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #139: arrowFunctionBody => ( singleExpression | 'T_LBRACE' [ functionBody @ ] 'T_RBRACE' )
    -->     Type: reduce
    -->     Reduce: arrowFunctionBody => ( singleExpression | 'T_LBRACE' @ [ functionBody ] 'T_RBRACE' )
    --> __________________
    --> #140: functionBody => [ functionBody @ ] sourceElements
    -->     Type: recursion
    -->     LA: K_BREAK 'T_INC' 'T_LBRACE' K_DO K_WHILE 
    -->     LA: K_NEW K_FOR 'T_LPARAN' K_SUPER K_IF 
    -->     LA: K_FALSE #REGEX# K_VOID K_DELETE K_FUNCTION 
    -->     LA: K_THIS K_NULL 'T_DEC' 'T_SUB' K_TRUE 
    -->     LA: K_CLASS 'T_BIT_NOT' 'T_ADD' #STRING# 'T_SEMI' 
    -->     LA: K_SWITCH K_CONTINUE K_RETURN K_TRY 'T_LSQUARE' 
    -->     LA: K_VAR #ID# K_THROW K_DEBUGGER #NUMBER# 
    -->     LA: K_TYPEOF 'T_LOG_NOT' K_WITH 
    --> __________________
    --> #141: functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody @ ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') @ [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #142: methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody @ ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') @ [ functionBody ] ('T_RBRACE')

** [FINAL] State #105: program => sourceElements @
    --> __________________
    --> #105: program => sourceElements @
    -->     Type: finish

** State #106: sourceElements => [ sourceElements @ ] statement
    --> __________________
    --> #2: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: shift
    -->     LA: K_TRY K_WITH 'T_LOG_NOT' K_TYPEOF #NUMBER# 
    -->     LA: K_DEBUGGER K_THROW #ID# K_VAR 'T_LSQUARE' 
    -->     LA: K_RETURN K_CONTINUE K_FUNCTION K_SWITCH 'T_SEMI' 
    -->     LA: #STRING# 'T_ADD' K_CLASS 'T_BIT_NOT' K_TRUE 
    -->     LA: 'T_SUB' 'T_DEC' K_NULL K_THIS K_VOID 
    -->     LA: K_DELETE #REGEX# K_SUPER K_FALSE K_IF 
    -->     LA: 'T_LPARAN' K_FOR K_NEW K_WHILE K_DO 
    -->     LA: 'T_LBRACE' 'T_INC' K_BREAK 

** State #107: block => ('T_LBRACE') [ statementList @ ] ('T_RBRACE')
    --> __________________
    --> #41: block => ('T_LBRACE') [ statementList ] ('T_RBRACE') @
    -->     Type: pass
    -->     LA: 'T_RBRACE' 

** [FINAL] State #108: caseClause => K_CASE expressionSequence 'T_COLON' [ statementList @ ]
    --> __________________
    --> #143: caseClauses => caseClause @ [ caseClauses ]
    -->     Type: reduce
    -->     Reduce: caseClauses => @ caseClause [ caseClauses ]

** [FINAL] State #109: defaultClause => K_DEFAULT 'T_COLON' [ statementList @ ]
    --> __________________
    --> #144: caseBlock => ('T_LBRACE') [ caseClauses ] [ defaultClause @ [ caseClauses ] ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: caseBlock => ('T_LBRACE') @ [ caseClauses ] [ defaultClause [ caseClauses ] ] ('T_RBRACE')
    --> __________________
    --> #144: caseBlock => ('T_LBRACE') [ caseClauses ] [ defaultClause @ [ caseClauses ] ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: caseBlock => ('T_LBRACE') [ caseClauses @ ] [ defaultClause [ caseClauses ] ] ('T_RBRACE')

** State #110: statementList => [ statementList @ ] statement
    --> __________________
    --> #2: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: shift
    -->     LA: K_TRY K_WITH 'T_LOG_NOT' K_TYPEOF #NUMBER# 
    -->     LA: K_DEBUGGER K_THROW #ID# K_VAR 'T_LSQUARE' 
    -->     LA: K_RETURN K_CONTINUE K_FUNCTION K_SWITCH 'T_SEMI' 
    -->     LA: #STRING# 'T_ADD' K_CLASS 'T_BIT_NOT' K_TRUE 
    -->     LA: 'T_SUB' 'T_DEC' K_NULL K_THIS K_VOID 
    -->     LA: K_DELETE #REGEX# K_SUPER K_FALSE K_IF 
    -->     LA: 'T_LPARAN' K_FOR K_NEW K_WHILE K_DO 
    -->     LA: 'T_LBRACE' 'T_INC' K_BREAK 

** [FINAL] State #111: iterationStatement => ( doStatement | whileStatement @ | forStatement | forInStatement )
    --> __________________
    --> #137: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement @ | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** [FINAL] State #112: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement @ | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    --> __________________
    --> #70: doStatement => K_DO statement @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    -->     Type: reduce
    -->     Reduce: doStatement => K_DO @ statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #71: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #72: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') @ statement
    --> __________________
    --> #73: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement @ [ K_ELSE statement ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement [ K_ELSE statement ]
    --> __________________
    --> #74: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement @ ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE @ statement ]
    --> __________________
    --> #75: labelledStatement => #ID# 'T_COLON' statement @
    -->     Type: reduce
    -->     Reduce: labelledStatement => #ID# 'T_COLON' @ statement
    --> __________________
    --> #76: sourceElement => statement @
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #77: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ @ sourceElements ] statement
    --> __________________
    --> #77: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ sourceElements @ ] statement
    --> __________________
    --> #78: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ @ statementList ] statement
    --> __________________
    --> #78: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ statementList @ ] statement
    --> __________________
    --> #79: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #80: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement

** State #113: classTail => ('T_LBRACE') @ classElements ('T_RBRACE')
    --> __________________
    --> #145: classElements => [ @ classElements ('T_COMMA') ] classElement
    -->     Type: shift
    -->     LA: 'T_SEMI' #STRING# K_CATCH 'T_SHARP' K_CASE 
    -->     LA: #NUMBER# K_TYPEOF K_TRY 'T_LSQUARE' K_VAR 
    -->     LA: K_IN K_THIS K_ELSE #ID# K_THROW 
    -->     LA: K_CLASS K_IF K_FALSE K_TRUE K_DEFAULT 
    -->     LA: K_DEBUGGER K_WHILE K_NEW K_SWITCH K_CONTINUE 
    -->     LA: K_LET K_DO K_RETURN K_FINALLY K_FOR 
    -->     LA: K_INSTANCEOF K_VOID K_BREAK K_DELETE K_FUNCTION 
    -->     LA: K_WITH K_SUPER 

** State #114: assignmentOperatorExpression => [ @ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #146: ternaryExpression => @ logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' singleExpression ]
    -->     Type: shift
    -->     LA: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' 
    -->     LA: K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF 
    -->     LA: K_NEW K_VOID #NUMBER# 'T_LBRACE' K_DELETE 
    -->     LA: K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# 
    -->     LA: K_CLASS K_SUPER #STRING# K_FALSE 

** State #115: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN @ expressionSequence ('T_RPARAN') statement
    --> __________________
    --> #25: expressionSequence => [ @ expressionSequence ('T_COMMA') ] singleExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #116: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR @ variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement
    --> __________________
    --> #43: variableDeclarationList => [ @ variableDeclarationList ('T_COMMA') ] variableDeclaration
    -->     Type: shift
    -->     LA: 'T_LSQUARE' 'T_LBRACE' #ID# 

** State #117: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' @ [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
    --> __________________
    --> #147: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' @ [ expressionSequence ] ('T_RPARAN') statement
    -->     Type: move
    -->     LA: 'T_SEMI' 
    --> __________________
    --> #25: expressionSequence => [ @ expressionSequence ('T_COMMA') ] singleExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #118: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR @ variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
    --> __________________
    --> #43: variableDeclarationList => [ @ variableDeclarationList ('T_COMMA') ] variableDeclaration
    -->     Type: shift
    -->     LA: 'T_LSQUARE' 'T_LBRACE' #ID# 

** [FINAL] State #119: breakStatement => K_BREAK [ #ID# ] [ eos @ ]
    --> __________________
    --> #57: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement @ | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** [FINAL] State #120: continueStatement => K_CONTINUE [ #ID# ] [ eos @ ]
    --> __________________
    --> #55: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement @ | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** [FINAL] State #121: debuggerStatement => K_DEBUGGER [ eos @ ]
    --> __________________
    --> #62: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement @ | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** [FINAL] State #122: doStatement => K_DO statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos @ ]
    --> __________________
    --> #148: iterationStatement => ( doStatement @ | whileStatement | forStatement | forInStatement )
    -->     Type: reduce
    -->     Reduce: iterationStatement => @ ( doStatement | whileStatement | forStatement | forInStatement )

** [FINAL] State #123: expressionStatement => expressionSequence [ eos @ ]
    --> __________________
    --> #149: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement @ | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** [FINAL] State #124: returnStatement => K_RETURN [ expressionSequence ] [ eos @ ]
    --> __________________
    --> #58: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement @ | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** [FINAL] State #125: throwStatement => K_THROW expressionSequence [ eos @ ]
    --> __________________
    --> #150: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement @ | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** [FINAL] State #126: variableStatement => K_VAR variableDeclarationList [ eos @ ]
    --> __________________
    --> #151: declaration => ( variableStatement @ | classDeclaration | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #152: statement => ( block | variableStatement @ | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** State #127: functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') @ [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #153: functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE') @
    -->     Type: pass
    -->     LA: 'T_RBRACE' 
    --> __________________
    --> #154: functionBody => [ @ functionBody ] sourceElements
    -->     Type: shift
    -->     LA: K_BREAK 'T_INC' 'T_LBRACE' K_DO K_WHILE 
    -->     LA: K_NEW K_FOR 'T_LPARAN' K_SUPER K_IF 
    -->     LA: K_FALSE #REGEX# K_VOID K_DELETE K_FUNCTION 
    -->     LA: K_THIS K_NULL 'T_DEC' 'T_SUB' K_TRUE 
    -->     LA: K_CLASS 'T_BIT_NOT' 'T_ADD' #STRING# 'T_SEMI' 
    -->     LA: K_SWITCH K_CONTINUE K_RETURN K_TRY 'T_LSQUARE' 
    -->     LA: K_VAR #ID# K_THROW K_DEBUGGER #NUMBER# 
    -->     LA: K_TYPEOF 'T_LOG_NOT' K_WITH 

** [FINAL] State #128: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement @ | debuggerStatement | functionDeclaration )
    --> __________________
    --> #70: doStatement => K_DO statement @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    -->     Type: reduce
    -->     Reduce: doStatement => K_DO @ statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #71: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #72: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') @ statement
    --> __________________
    --> #73: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement @ [ K_ELSE statement ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement [ K_ELSE statement ]
    --> __________________
    --> #74: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement @ ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE @ statement ]
    --> __________________
    --> #75: labelledStatement => #ID# 'T_COLON' statement @
    -->     Type: reduce
    -->     Reduce: labelledStatement => #ID# 'T_COLON' @ statement
    --> __________________
    --> #76: sourceElement => statement @
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #77: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ @ sourceElements ] statement
    --> __________________
    --> #77: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ sourceElements @ ] statement
    --> __________________
    --> #78: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ @ statementList ] statement
    --> __________________
    --> #78: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ statementList @ ] statement
    --> __________________
    --> #79: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #80: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement

** State #129: finallyProduction => K_FINALLY @ block
    --> __________________
    --> #4: block => @ ('T_LBRACE') [ statementList ] ('T_RBRACE')
    -->     Type: shift
    -->     LA: 'T_LBRACE' 

** State #130: catchProduction => K_CATCH @ [ ('T_LPARAN') [ assignable ] ('T_RPARAN') ] block
    --> __________________
    --> #4: block => @ ('T_LBRACE') [ statementList ] ('T_RBRACE')
    -->     Type: shift
    -->     LA: 'T_LBRACE' 
    --> __________________
    --> #155: catchProduction => K_CATCH [ ('T_LPARAN') @ [ assignable ] ('T_RPARAN') ] block
    -->     Type: pass
    -->     LA: 'T_LPARAN' 

** State #131: objectLiteral => @ ('T_LBRACE') [ propertyAssignments ] [ ('T_COMMA') ] ('T_RBRACE')
    --> __________________
    --> #156: objectLiteral => ('T_LBRACE') @ [ propertyAssignments ] [ ('T_COMMA') ] ('T_RBRACE')
    -->     Type: pass
    -->     LA: 'T_LBRACE' 

** [FINAL] State #132: assignable => ( #ID# @ | arrayLiteral | objectLiteral )
    --> __________________
    --> #157: catchProduction => K_CATCH [ ('T_LPARAN') [ assignable @ ] ('T_RPARAN') ] block
    -->     Type: reduce
    -->     Reduce: catchProduction => K_CATCH [ ('T_LPARAN') @ [ assignable ] ('T_RPARAN') ] block
    --> __________________
    --> #158: formalParameterArg => assignable @
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #159: formalParameterList => [ formalParameterList ('T_COMMA') ] assignable @
    -->     Type: reduce
    -->     Reduce: formalParameterList => [ @ formalParameterList ('T_COMMA') ] assignable
    --> __________________
    --> #159: formalParameterList => [ formalParameterList ('T_COMMA') ] assignable @
    -->     Type: reduce
    -->     Reduce: formalParameterList => [ formalParameterList ('T_COMMA') @ ] assignable
    --> __________________
    --> #160: variableDeclaration => assignable @ [ 'T_ASSIGN' singleExpression ]
    -->     Type: reduce
    -->     Reduce: variableDeclaration => @ assignable [ 'T_ASSIGN' singleExpression ]

** State #133: arrayLiteral => @ ('T_LSQUARE') [ elementList ] ('T_RSQUARE')
    --> __________________
    --> #161: arrayLiteral => ('T_LSQUARE') @ [ elementList ] ('T_RSQUARE')
    -->     Type: pass
    -->     LA: 'T_LSQUARE' 

** State #134: classElements => [ classElements ('T_COMMA') @ ] classElement
    --> __________________
    --> #162: classElement => @ ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' singleExpression )
    -->     Type: shift
    -->     LA: K_SUPER K_TRY K_FUNCTION K_WITH K_DELETE 
    -->     LA: K_ELSE K_BREAK K_IF K_VOID K_INSTANCEOF 
    -->     LA: K_FOR K_FINALLY K_RETURN K_DO K_LET 
    -->     LA: K_CONTINUE K_SWITCH K_NEW K_WHILE K_DEBUGGER 
    -->     LA: K_DEFAULT K_TRUE K_FALSE K_CLASS K_THROW 
    -->     LA: #ID# K_THIS K_IN K_VAR 'T_LSQUARE' 
    -->     LA: K_TYPEOF #NUMBER# K_CASE 'T_SHARP' K_CATCH 
    -->     LA: #STRING# 'T_SEMI' 

** [FINAL] State #135: classTail => ('T_LBRACE') classElements ('T_RBRACE') @
    --> __________________
    --> #163: classDeclaration => K_CLASS #ID# classTail @
    -->     Type: reduce
    -->     Reduce: classDeclaration => K_CLASS #ID# @ classTail
    --> __________________
    --> #164: classExpression => K_CLASS (#ID#) classTail @
    -->     Type: reduce
    -->     Reduce(exp): classExpression => K_CLASS (#ID#) @ classTail

** State #136: doStatement => K_DO statement K_WHILE ('T_LPARAN') @ expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #25: expressionSequence => [ @ expressionSequence ('T_COMMA') ] singleExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #137: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement @ | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    --> __________________
    --> #70: doStatement => K_DO statement @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    -->     Type: reduce
    -->     Reduce: doStatement => K_DO @ statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #71: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #72: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') @ statement
    --> __________________
    --> #73: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement @ [ K_ELSE statement ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement [ K_ELSE statement ]
    --> __________________
    --> #74: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement @ ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE @ statement ]
    --> __________________
    --> #75: labelledStatement => #ID# 'T_COLON' statement @
    -->     Type: reduce
    -->     Reduce: labelledStatement => #ID# 'T_COLON' @ statement
    --> __________________
    --> #76: sourceElement => statement @
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #77: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ @ sourceElements ] statement
    --> __________________
    --> #77: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ sourceElements @ ] statement
    --> __________________
    --> #78: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ @ statementList ] statement
    --> __________________
    --> #78: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ statementList @ ] statement
    --> __________________
    --> #79: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #80: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement

** State #138: anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody @ ] ('T_RBRACE')
    --> __________________
    --> #165: anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE') @
    -->     Type: pass
    -->     LA: 'T_RBRACE' 

** State #139: arrowFunctionBody => ( singleExpression | 'T_LBRACE' [ functionBody @ ] 'T_RBRACE' )
    --> __________________
    --> #166: arrowFunctionBody => ( singleExpression | 'T_LBRACE' [ functionBody ] 'T_RBRACE' @ )
    -->     Type: move
    -->     LA: 'T_RBRACE' 

** State #140: functionBody => [ functionBody @ ] sourceElements
    --> __________________
    --> #1: sourceElements => [ @ sourceElements ] statement
    -->     Type: shift
    -->     LA: K_BREAK 'T_INC' 'T_LBRACE' K_DO K_WHILE 
    -->     LA: K_NEW K_FOR 'T_LPARAN' K_SUPER K_IF 
    -->     LA: K_FALSE #REGEX# K_VOID K_DELETE K_FUNCTION 
    -->     LA: K_THIS K_NULL 'T_DEC' 'T_SUB' K_TRUE 
    -->     LA: K_CLASS 'T_BIT_NOT' 'T_ADD' #STRING# 'T_SEMI' 
    -->     LA: K_SWITCH K_CONTINUE K_RETURN K_TRY 'T_LSQUARE' 
    -->     LA: K_VAR #ID# K_THROW K_DEBUGGER #NUMBER# 
    -->     LA: K_TYPEOF 'T_LOG_NOT' K_WITH 

** State #141: functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody @ ] ('T_RBRACE')
    --> __________________
    --> #153: functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE') @
    -->     Type: pass
    -->     LA: 'T_RBRACE' 

** State #142: methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody @ ] ('T_RBRACE')
    --> __________________
    --> #167: methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE') @
    -->     Type: pass
    -->     LA: 'T_RBRACE' 

** [FINAL] State #143: caseClauses => caseClause @ [ caseClauses ]
    --> __________________
    --> #168: caseClauses => @ caseClause [ caseClauses ]
    -->     Type: shift
    -->     LA: K_CASE 
    --> __________________
    --> #169: caseBlock => ('T_LBRACE') [ caseClauses @ ] [ defaultClause [ caseClauses ] ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: caseBlock => ('T_LBRACE') @ [ caseClauses ] [ defaultClause [ caseClauses ] ] ('T_RBRACE')
    --> __________________
    --> #170: caseBlock => ('T_LBRACE') [ caseClauses ] [ defaultClause [ caseClauses @ ] ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: caseBlock => ('T_LBRACE') [ caseClauses ] [ defaultClause @ [ caseClauses ] ] ('T_RBRACE')
    --> __________________
    --> #171: caseClauses => caseClause [ caseClauses @ ]
    -->     Type: reduce
    -->     Reduce: caseClauses => caseClause @ [ caseClauses ]

** State #144: caseBlock => ('T_LBRACE') [ caseClauses ] [ defaultClause @ [ caseClauses ] ] ('T_RBRACE')
    --> __________________
    --> #172: caseBlock => ('T_LBRACE') [ caseClauses ] [ defaultClause [ caseClauses ] ] ('T_RBRACE') @
    -->     Type: pass
    -->     LA: 'T_RBRACE' 
    --> __________________
    --> #168: caseClauses => @ caseClause [ caseClauses ]
    -->     Type: shift
    -->     LA: K_CASE 

** State #145: classElements => [ @ classElements ('T_COMMA') ] classElement
    --> __________________
    --> #162: classElement => @ ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' singleExpression )
    -->     Type: shift
    -->     LA: K_SUPER K_TRY K_FUNCTION K_WITH K_DELETE 
    -->     LA: K_ELSE K_BREAK K_IF K_VOID K_INSTANCEOF 
    -->     LA: K_FOR K_FINALLY K_RETURN K_DO K_LET 
    -->     LA: K_CONTINUE K_SWITCH K_NEW K_WHILE K_DEBUGGER 
    -->     LA: K_DEFAULT K_TRUE K_FALSE K_CLASS K_THROW 
    -->     LA: #ID# K_THIS K_IN K_VAR 'T_LSQUARE' 
    -->     LA: K_TYPEOF #NUMBER# K_CASE 'T_SHARP' K_CATCH 
    -->     LA: #STRING# 'T_SEMI' 

** State #146: ternaryExpression => @ logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' singleExpression ]
    --> __________________
    --> #173: logicalOrExpression => [ @ logicalOrExpression 'T_LOG_OR' ] logicalAndExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #147: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' @ [ expressionSequence ] ('T_RPARAN') statement
    --> __________________
    --> #174: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') @ statement
    -->     Type: pass
    -->     LA: 'T_RPARAN' 
    --> __________________
    --> #25: expressionSequence => [ @ expressionSequence ('T_COMMA') ] singleExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #148: iterationStatement => ( doStatement @ | whileStatement | forStatement | forInStatement )
    --> __________________
    --> #137: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement @ | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** [FINAL] State #149: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement @ | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    --> __________________
    --> #70: doStatement => K_DO statement @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    -->     Type: reduce
    -->     Reduce: doStatement => K_DO @ statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #71: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #72: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') @ statement
    --> __________________
    --> #73: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement @ [ K_ELSE statement ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement [ K_ELSE statement ]
    --> __________________
    --> #74: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement @ ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE @ statement ]
    --> __________________
    --> #75: labelledStatement => #ID# 'T_COLON' statement @
    -->     Type: reduce
    -->     Reduce: labelledStatement => #ID# 'T_COLON' @ statement
    --> __________________
    --> #76: sourceElement => statement @
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #77: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ @ sourceElements ] statement
    --> __________________
    --> #77: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ sourceElements @ ] statement
    --> __________________
    --> #78: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ @ statementList ] statement
    --> __________________
    --> #78: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ statementList @ ] statement
    --> __________________
    --> #79: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #80: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement

** [FINAL] State #150: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement @ | tryStatement | debuggerStatement | functionDeclaration )
    --> __________________
    --> #70: doStatement => K_DO statement @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    -->     Type: reduce
    -->     Reduce: doStatement => K_DO @ statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #71: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #72: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') @ statement
    --> __________________
    --> #73: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement @ [ K_ELSE statement ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement [ K_ELSE statement ]
    --> __________________
    --> #74: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement @ ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE @ statement ]
    --> __________________
    --> #75: labelledStatement => #ID# 'T_COLON' statement @
    -->     Type: reduce
    -->     Reduce: labelledStatement => #ID# 'T_COLON' @ statement
    --> __________________
    --> #76: sourceElement => statement @
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #77: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ @ sourceElements ] statement
    --> __________________
    --> #77: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ sourceElements @ ] statement
    --> __________________
    --> #78: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ @ statementList ] statement
    --> __________________
    --> #78: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ statementList @ ] statement
    --> __________________
    --> #79: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #80: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement

** [FINAL] State #151: declaration => ( variableStatement @ | classDeclaration | functionDeclaration )

** [FINAL] State #152: statement => ( block | variableStatement @ | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    --> __________________
    --> #70: doStatement => K_DO statement @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    -->     Type: reduce
    -->     Reduce: doStatement => K_DO @ statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #71: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #72: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') @ statement
    --> __________________
    --> #73: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement @ [ K_ELSE statement ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement [ K_ELSE statement ]
    --> __________________
    --> #74: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement @ ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE @ statement ]
    --> __________________
    --> #75: labelledStatement => #ID# 'T_COLON' statement @
    -->     Type: reduce
    -->     Reduce: labelledStatement => #ID# 'T_COLON' @ statement
    --> __________________
    --> #76: sourceElement => statement @
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #77: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ @ sourceElements ] statement
    --> __________________
    --> #77: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ sourceElements @ ] statement
    --> __________________
    --> #78: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ @ statementList ] statement
    --> __________________
    --> #78: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ statementList @ ] statement
    --> __________________
    --> #79: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #80: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement

** [FINAL] State #153: functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE') @
    --> __________________
    --> #175: declaration => ( variableStatement | classDeclaration | functionDeclaration @ )
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #176: functionDecl => functionDeclaration @
    -->     Type: reduce
    -->     Reduce: functionDecl => @ functionDeclaration
    --> __________________
    --> #177: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration @ )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** State #154: functionBody => [ @ functionBody ] sourceElements
    --> __________________
    --> #1: sourceElements => [ @ sourceElements ] statement
    -->     Type: shift
    -->     LA: K_BREAK 'T_INC' 'T_LBRACE' K_DO K_WHILE 
    -->     LA: K_NEW K_FOR 'T_LPARAN' K_SUPER K_IF 
    -->     LA: K_FALSE #REGEX# K_VOID K_DELETE K_FUNCTION 
    -->     LA: K_THIS K_NULL 'T_DEC' 'T_SUB' K_TRUE 
    -->     LA: K_CLASS 'T_BIT_NOT' 'T_ADD' #STRING# 'T_SEMI' 
    -->     LA: K_SWITCH K_CONTINUE K_RETURN K_TRY 'T_LSQUARE' 
    -->     LA: K_VAR #ID# K_THROW K_DEBUGGER #NUMBER# 
    -->     LA: K_TYPEOF 'T_LOG_NOT' K_WITH 

** State #155: catchProduction => K_CATCH [ ('T_LPARAN') @ [ assignable ] ('T_RPARAN') ] block
    --> __________________
    --> #178: catchProduction => K_CATCH [ ('T_LPARAN') [ assignable ] ('T_RPARAN') @ ] block
    -->     Type: pass
    -->     LA: 'T_RPARAN' 
    --> __________________
    --> #95: assignable => @ ( #ID# | arrayLiteral | objectLiteral )
    -->     Type: shift
    -->     LA: #ID# 'T_LBRACE' 'T_LSQUARE' 

** State #156: objectLiteral => ('T_LBRACE') @ [ propertyAssignments ] [ ('T_COMMA') ] ('T_RBRACE')
    --> __________________
    --> #179: objectLiteral => ('T_LBRACE') [ propertyAssignments ] [ ('T_COMMA') ] ('T_RBRACE') @
    -->     Type: pass
    -->     LA: 'T_RBRACE' 
    --> __________________
    --> #180: propertyAssignments => [ @ propertyAssignments ('T_COMMA') ] propertyAssignment
    -->     Type: shift
    -->     LA: K_DO K_WITH K_THROW #REGEX# K_BREAK 
    -->     LA: K_CATCH K_FUNCTION K_CASE K_FINALLY K_IF 
    -->     LA: K_RETURN #ID# 'T_LSQUARE' K_IN K_LET 
    -->     LA: K_VOID K_ELSE K_DEBUGGER K_SWITCH #STRING# 
    -->     LA: K_WHILE K_DEFAULT 'T_LOG_NOT' 'T_LBRACE' K_TRY 
    -->     LA: 'T_ELLIPSIS' K_FALSE K_VAR K_TYPEOF 'T_ADD' 
    -->     LA: 'T_BIT_NOT' K_TRUE 'T_SUB' 'T_DEC' K_NULL 
    -->     LA: 'T_INC' K_CONTINUE K_THIS K_NEW K_INSTANCEOF 
    -->     LA: K_DELETE 'T_LPARAN' K_CLASS #NUMBER# K_SUPER 
    -->     LA: K_FOR 
    --> __________________
    --> #181: objectLiteral => ('T_LBRACE') [ propertyAssignments ] [ ('T_COMMA') @ ] ('T_RBRACE')
    -->     Type: pass
    -->     LA: 'T_COMMA' 

** State #157: catchProduction => K_CATCH [ ('T_LPARAN') [ assignable @ ] ('T_RPARAN') ] block
    --> __________________
    --> #178: catchProduction => K_CATCH [ ('T_LPARAN') [ assignable ] ('T_RPARAN') @ ] block
    -->     Type: pass
    -->     LA: 'T_RPARAN' 

** [FINAL] State #158: formalParameterArg => assignable @

** [FINAL] State #159: formalParameterList => [ formalParameterList ('T_COMMA') ] assignable @
    --> __________________
    --> #182: anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') [ formalParameterList @ ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') @ [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #183: arrowFunctionParameters => ( #ID# | ('T_LPARAN') [ formalParameterList @ ] ('T_RPARAN') )
    -->     Type: reduce
    -->     Reduce: arrowFunctionParameters => ( #ID# | ('T_LPARAN') @ [ formalParameterList ] ('T_RPARAN') )
    --> __________________
    --> #184: formalParameterList => [ formalParameterList @ ('T_COMMA') ] assignable
    -->     Type: recursion
    -->     LA: 'T_COMMA' 
    --> __________________
    --> #185: functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList @ ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') @ [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #186: methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList @ ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') @ [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')

** [FINAL] State #160: variableDeclaration => assignable @ [ 'T_ASSIGN' singleExpression ]
    --> __________________
    --> #187: variableDeclaration => assignable [ 'T_ASSIGN' @ singleExpression ]
    -->     Type: move
    -->     LA: 'T_ASSIGN' 
    --> __________________
    --> #188: variableDeclarationList => [ variableDeclarationList ('T_COMMA') ] variableDeclaration @
    -->     Type: reduce
    -->     Reduce: variableDeclarationList => [ @ variableDeclarationList ('T_COMMA') ] variableDeclaration
    --> __________________
    --> #188: variableDeclarationList => [ variableDeclarationList ('T_COMMA') ] variableDeclaration @
    -->     Type: reduce
    -->     Reduce: variableDeclarationList => [ variableDeclarationList ('T_COMMA') @ ] variableDeclaration

** State #161: arrayLiteral => ('T_LSQUARE') @ [ elementList ] ('T_RSQUARE')
    --> __________________
    --> #189: arrayLiteral => ('T_LSQUARE') [ elementList ] ('T_RSQUARE') @
    -->     Type: pass
    -->     LA: 'T_RSQUARE' 
    --> __________________
    --> #190: elementList => [ @ elementList ('T_COMMA') ] arrayElement
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 'T_ELLIPSIS' 

** State #162: classElement => @ ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' singleExpression )
    --> __________________
    --> #191: propertyName => @ ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') )
    -->     Type: shift
    -->     LA: #NUMBER# 'T_LSQUARE' #STRING# K_THIS #ID# 
    -->     LA: K_CLASS K_FALSE K_TRUE K_DEFAULT K_DEBUGGER 
    -->     LA: K_VAR K_WHILE K_SWITCH K_CONTINUE K_VOID 
    -->     LA: K_LET K_IN K_RETURN K_TYPEOF K_FINALLY 
    -->     LA: K_NEW K_FOR K_INSTANCEOF K_CASE K_CATCH 
    -->     LA: K_ELSE K_IF K_BREAK K_THROW K_DELETE 
    -->     LA: K_WITH K_DO K_FUNCTION K_TRY K_SUPER 
    --> __________________
    --> #192: methodDefinition => [ @ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: shift
    -->     LA: 'T_SHARP' K_CASE #NUMBER# 'T_LSQUARE' #STRING# 
    -->     LA: K_THIS #ID# K_CLASS K_FALSE K_TRUE 
    -->     LA: K_DEFAULT K_DEBUGGER K_VAR K_WHILE K_SWITCH 
    -->     LA: K_CONTINUE K_VOID K_LET K_IN K_RETURN 
    -->     LA: K_TYPEOF K_FINALLY K_NEW K_FOR K_INSTANCEOF 
    -->     LA: K_CATCH K_ELSE K_IF K_BREAK K_THROW 
    -->     LA: K_DELETE K_WITH K_DO K_FUNCTION K_TRY 
    -->     LA: K_SUPER 
    --> __________________
    --> #6: emptyStatement => @ 'T_SEMI'
    -->     Type: shift
    -->     LA: 'T_SEMI' 
    --> __________________
    --> #193: classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' @ ] propertyName 'T_ASSIGN' singleExpression )
    -->     Type: move
    -->     LA: 'T_SHARP' 

** [FINAL] State #163: classDeclaration => K_CLASS #ID# classTail @
    --> __________________
    --> #194: declaration => ( variableStatement | classDeclaration @ | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #195: statement => ( block | variableStatement | emptyStatement | classDeclaration @ | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** [FINAL] State #164: classExpression => K_CLASS (#ID#) classTail @
    --> __________________
    --> #196: functionExpression => ( anonymousFunction | classExpression @ | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
    -->     Type: reduce
    -->     Reduce(exp): functionExpression => @ ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )

** [FINAL] State #165: anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE') @
    --> __________________
    --> #197: anonymousFunction => ( functionDecl | anoymousFunctionDecl @ | arrowFunction )
    -->     Type: reduce
    -->     Reduce: anonymousFunction => @ ( functionDecl | anoymousFunctionDecl | arrowFunction )

** [FINAL] State #166: arrowFunctionBody => ( singleExpression | 'T_LBRACE' [ functionBody ] 'T_RBRACE' @ )
    --> __________________
    --> #198: arrowFunction => arrowFunctionParameters ('T_ARROW') arrowFunctionBody @
    -->     Type: reduce
    -->     Reduce: arrowFunction => arrowFunctionParameters ('T_ARROW') @ arrowFunctionBody

** [FINAL] State #167: methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE') @
    --> __________________
    --> #199: classElement => ( methodDefinition @ | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' singleExpression )
    -->     Type: reduce
    -->     Reduce: classElement => @ ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' singleExpression )

** State #168: caseClauses => @ caseClause [ caseClauses ]
    --> __________________
    --> #200: caseClause => @ K_CASE expressionSequence 'T_COLON' [ statementList ]
    -->     Type: shift
    -->     LA: K_CASE 

** State #169: caseBlock => ('T_LBRACE') [ caseClauses @ ] [ defaultClause [ caseClauses ] ] ('T_RBRACE')
    --> __________________
    --> #172: caseBlock => ('T_LBRACE') [ caseClauses ] [ defaultClause [ caseClauses ] ] ('T_RBRACE') @
    -->     Type: pass
    -->     LA: 'T_RBRACE' 
    --> __________________
    --> #201: defaultClause => @ K_DEFAULT 'T_COLON' [ statementList ]
    -->     Type: shift
    -->     LA: K_DEFAULT 

** State #170: caseBlock => ('T_LBRACE') [ caseClauses ] [ defaultClause [ caseClauses @ ] ] ('T_RBRACE')
    --> __________________
    --> #172: caseBlock => ('T_LBRACE') [ caseClauses ] [ defaultClause [ caseClauses ] ] ('T_RBRACE') @
    -->     Type: pass
    -->     LA: 'T_RBRACE' 

** [FINAL] State #171: caseClauses => caseClause [ caseClauses @ ]
    --> __________________
    --> #169: caseBlock => ('T_LBRACE') [ caseClauses @ ] [ defaultClause [ caseClauses ] ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: caseBlock => ('T_LBRACE') @ [ caseClauses ] [ defaultClause [ caseClauses ] ] ('T_RBRACE')
    --> __________________
    --> #170: caseBlock => ('T_LBRACE') [ caseClauses ] [ defaultClause [ caseClauses @ ] ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: caseBlock => ('T_LBRACE') [ caseClauses ] [ defaultClause @ [ caseClauses ] ] ('T_RBRACE')
    --> __________________
    --> #171: caseClauses => caseClause [ caseClauses @ ]
    -->     Type: reduce
    -->     Reduce: caseClauses => caseClause @ [ caseClauses ]

** [FINAL] State #172: caseBlock => ('T_LBRACE') [ caseClauses ] [ defaultClause [ caseClauses ] ] ('T_RBRACE') @
    --> __________________
    --> #202: switchStatement => K_SWITCH ('T_LPARAN') expressionSequence ('T_RPARAN') caseBlock @
    -->     Type: reduce
    -->     Reduce: switchStatement => K_SWITCH ('T_LPARAN') expressionSequence ('T_RPARAN') @ caseBlock

** State #173: logicalOrExpression => [ @ logicalOrExpression 'T_LOG_OR' ] logicalAndExpression
    --> __________________
    --> #203: logicalAndExpression => [ @ logicalAndExpression 'T_LOG_AND' ] bitOrExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #174: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') @ statement
    --> __________________
    --> #2: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: shift
    -->     LA: K_TRY K_WITH 'T_LOG_NOT' K_TYPEOF #NUMBER# 
    -->     LA: K_DEBUGGER K_THROW #ID# K_VAR 'T_LSQUARE' 
    -->     LA: K_RETURN K_CONTINUE K_FUNCTION K_SWITCH 'T_SEMI' 
    -->     LA: #STRING# 'T_ADD' K_CLASS 'T_BIT_NOT' K_TRUE 
    -->     LA: 'T_SUB' 'T_DEC' K_NULL K_THIS K_VOID 
    -->     LA: K_DELETE #REGEX# K_SUPER K_FALSE K_IF 
    -->     LA: 'T_LPARAN' K_FOR K_NEW K_WHILE K_DO 
    -->     LA: 'T_LBRACE' 'T_INC' K_BREAK 

** [FINAL] State #175: declaration => ( variableStatement | classDeclaration | functionDeclaration @ )

** [FINAL] State #176: functionDecl => functionDeclaration @
    --> __________________
    --> #204: anonymousFunction => ( functionDecl @ | anoymousFunctionDecl | arrowFunction )
    -->     Type: reduce
    -->     Reduce: anonymousFunction => @ ( functionDecl | anoymousFunctionDecl | arrowFunction )

** [FINAL] State #177: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration @ )
    --> __________________
    --> #70: doStatement => K_DO statement @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    -->     Type: reduce
    -->     Reduce: doStatement => K_DO @ statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #71: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #72: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') @ statement
    --> __________________
    --> #73: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement @ [ K_ELSE statement ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement [ K_ELSE statement ]
    --> __________________
    --> #74: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement @ ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE @ statement ]
    --> __________________
    --> #75: labelledStatement => #ID# 'T_COLON' statement @
    -->     Type: reduce
    -->     Reduce: labelledStatement => #ID# 'T_COLON' @ statement
    --> __________________
    --> #76: sourceElement => statement @
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #77: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ @ sourceElements ] statement
    --> __________________
    --> #77: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ sourceElements @ ] statement
    --> __________________
    --> #78: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ @ statementList ] statement
    --> __________________
    --> #78: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ statementList @ ] statement
    --> __________________
    --> #79: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #80: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement

** State #178: catchProduction => K_CATCH [ ('T_LPARAN') [ assignable ] ('T_RPARAN') @ ] block
    --> __________________
    --> #4: block => @ ('T_LBRACE') [ statementList ] ('T_RBRACE')
    -->     Type: shift
    -->     LA: 'T_LBRACE' 

** [FINAL] State #179: objectLiteral => ('T_LBRACE') [ propertyAssignments ] [ ('T_COMMA') ] ('T_RBRACE') @
    --> __________________
    --> #205: assignable => ( #ID# | arrayLiteral | objectLiteral @ )
    -->     Type: reduce
    -->     Reduce: assignable => @ ( #ID# | arrayLiteral | objectLiteral )
    --> __________________
    --> #206: objectLiteralExpression => objectLiteral @
    -->     Type: reduce
    -->     Reduce(exp): objectLiteralExpression => @ objectLiteral

** State #180: propertyAssignments => [ @ propertyAssignments ('T_COMMA') ] propertyAssignment
    --> __________________
    --> #207: propertyAssignment => @ ( propertyExpressionAssignment | computedPropertyExpressionAssignment | propertyShorthand )
    -->     Type: shift
    -->     LA: K_FOR K_SUPER #NUMBER# K_CLASS #REGEX# 
    -->     LA: 'T_LPARAN' K_DELETE K_INSTANCEOF K_NEW K_THIS 
    -->     LA: K_FUNCTION K_CONTINUE 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' K_TRUE 'T_BIT_NOT' 'T_ADD' K_TYPEOF 
    -->     LA: K_VAR K_FALSE 'T_ELLIPSIS' K_TRY 'T_LBRACE' 
    -->     LA: 'T_LOG_NOT' K_DEFAULT K_DEBUGGER K_WHILE #STRING# 
    -->     LA: K_SWITCH K_ELSE K_VOID K_LET K_IN 
    -->     LA: 'T_LSQUARE' #ID# K_RETURN K_IF K_FINALLY 
    -->     LA: K_CASE K_CATCH K_BREAK K_THROW K_WITH 
    -->     LA: K_DO 

** State #181: objectLiteral => ('T_LBRACE') [ propertyAssignments ] [ ('T_COMMA') @ ] ('T_RBRACE')
    --> __________________
    --> #179: objectLiteral => ('T_LBRACE') [ propertyAssignments ] [ ('T_COMMA') ] ('T_RBRACE') @
    -->     Type: pass
    -->     LA: 'T_RBRACE' 

** State #182: anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') [ formalParameterList @ ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #208: anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') @ ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: pass
    -->     LA: 'T_RPARAN' 

** State #183: arrowFunctionParameters => ( #ID# | ('T_LPARAN') [ formalParameterList @ ] ('T_RPARAN') )
    --> __________________
    --> #209: arrowFunctionParameters => ( #ID# | ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') @ )
    -->     Type: pass
    -->     LA: 'T_RPARAN' 

** State #184: formalParameterList => [ formalParameterList @ ('T_COMMA') ] assignable
    --> __________________
    --> #210: formalParameterList => [ formalParameterList ('T_COMMA') @ ] assignable
    -->     Type: pass
    -->     LA: 'T_COMMA' 

** State #185: functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList @ ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #88: functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') @ ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: pass
    -->     LA: 'T_RPARAN' 

** State #186: methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList @ ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #211: methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') @ ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: pass
    -->     LA: 'T_RPARAN' 

** State #187: variableDeclaration => assignable [ 'T_ASSIGN' @ singleExpression ]
    --> __________________
    --> #47: singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #188: variableDeclarationList => [ variableDeclarationList ('T_COMMA') ] variableDeclaration @
    --> __________________
    --> #212: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList @ ) ] K_IN expressionSequence ('T_RPARAN') statement
    -->     Type: reduce
    -->     Reduce: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR @ variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement
    --> __________________
    --> #213: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList @ ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
    -->     Type: reduce
    -->     Reduce: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR @ variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
    --> __________________
    --> #214: variableDeclarationList => [ variableDeclarationList @ ('T_COMMA') ] variableDeclaration
    -->     Type: recursion
    -->     LA: 'T_COMMA' 
    --> __________________
    --> #215: variableStatement => K_VAR variableDeclarationList @ [ eos ]
    -->     Type: reduce
    -->     Reduce: variableStatement => K_VAR @ variableDeclarationList [ eos ]

** [FINAL] State #189: arrayLiteral => ('T_LSQUARE') [ elementList ] ('T_RSQUARE') @
    --> __________________
    --> #216: arrayLiteralExpression => arrayLiteral @
    -->     Type: reduce
    -->     Reduce(exp): arrayLiteralExpression => @ arrayLiteral
    --> __________________
    --> #217: assignable => ( #ID# | arrayLiteral @ | objectLiteral )
    -->     Type: reduce
    -->     Reduce: assignable => @ ( #ID# | arrayLiteral | objectLiteral )

** State #190: elementList => [ @ elementList ('T_COMMA') ] arrayElement
    --> __________________
    --> #218: arrayElement => [ @ 'T_ELLIPSIS' ] singleExpression
    -->     Type: shift
    -->     LA: 'T_ELLIPSIS' 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 
    -->     LA: 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_THIS 
    -->     LA: K_TYPEOF K_NEW K_VOID #NUMBER# 'T_LBRACE' 
    -->     LA: K_DELETE K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' 
    -->     LA: #REGEX# K_CLASS K_SUPER #STRING# K_FALSE 

** State #191: propertyName => @ ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') )
    --> __________________
    --> #219: propertyName => ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') @ singleExpression ('T_RSQUARE') )
    -->     Type: pass
    -->     LA: 'T_LSQUARE' 
    --> __________________
    --> #220: identifierName => @ ( #ID# | reservedWord )
    -->     Type: shift
    -->     LA: #ID# K_CLASS K_FALSE K_TRUE K_DEFAULT 
    -->     LA: K_DEBUGGER K_VAR K_WHILE K_SWITCH K_CONTINUE 
    -->     LA: K_VOID K_LET K_IN K_RETURN K_TYPEOF 
    -->     LA: K_FINALLY K_NEW K_FOR K_INSTANCEOF K_CASE 
    -->     LA: K_CATCH K_ELSE K_THIS K_IF K_BREAK 
    -->     LA: K_THROW K_DELETE K_WITH K_DO K_FUNCTION 
    -->     LA: K_TRY K_SUPER 
    --> __________________
    --> #221: propertyName => ( identifierName | #STRING# @ | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') )
    -->     Type: move
    -->     LA: #STRING# 
    --> __________________
    --> #222: numericLiteral => @ #NUMBER#
    -->     Type: shift
    -->     LA: #NUMBER# 

** State #192: methodDefinition => [ @ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #223: methodDefinition => [ 'T_SHARP' @ ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: move
    -->     LA: 'T_SHARP' 
    --> __________________
    --> #191: propertyName => @ ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') )
    -->     Type: shift
    -->     LA: #NUMBER# 'T_LSQUARE' #STRING# K_THIS #ID# 
    -->     LA: K_CLASS K_FALSE K_TRUE K_DEFAULT K_DEBUGGER 
    -->     LA: K_VAR K_WHILE K_SWITCH K_CONTINUE K_VOID 
    -->     LA: K_LET K_IN K_RETURN K_TYPEOF K_FINALLY 
    -->     LA: K_NEW K_FOR K_INSTANCEOF K_CASE K_CATCH 
    -->     LA: K_ELSE K_IF K_BREAK K_THROW K_DELETE 
    -->     LA: K_WITH K_DO K_FUNCTION K_TRY K_SUPER 

** State #193: classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' @ ] propertyName 'T_ASSIGN' singleExpression )
    --> __________________
    --> #191: propertyName => @ ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') )
    -->     Type: shift
    -->     LA: #NUMBER# 'T_LSQUARE' #STRING# K_THIS #ID# 
    -->     LA: K_CLASS K_FALSE K_TRUE K_DEFAULT K_DEBUGGER 
    -->     LA: K_VAR K_WHILE K_SWITCH K_CONTINUE K_VOID 
    -->     LA: K_LET K_IN K_RETURN K_TYPEOF K_FINALLY 
    -->     LA: K_NEW K_FOR K_INSTANCEOF K_CASE K_CATCH 
    -->     LA: K_ELSE K_IF K_BREAK K_THROW K_DELETE 
    -->     LA: K_WITH K_DO K_FUNCTION K_TRY K_SUPER 

** [FINAL] State #194: declaration => ( variableStatement | classDeclaration @ | functionDeclaration )

** [FINAL] State #195: statement => ( block | variableStatement | emptyStatement | classDeclaration @ | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    --> __________________
    --> #70: doStatement => K_DO statement @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    -->     Type: reduce
    -->     Reduce: doStatement => K_DO @ statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #71: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #72: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') @ statement
    --> __________________
    --> #73: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement @ [ K_ELSE statement ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement [ K_ELSE statement ]
    --> __________________
    --> #74: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement @ ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE @ statement ]
    --> __________________
    --> #75: labelledStatement => #ID# 'T_COLON' statement @
    -->     Type: reduce
    -->     Reduce: labelledStatement => #ID# 'T_COLON' @ statement
    --> __________________
    --> #76: sourceElement => statement @
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #77: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ @ sourceElements ] statement
    --> __________________
    --> #77: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ sourceElements @ ] statement
    --> __________________
    --> #78: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ @ statementList ] statement
    --> __________________
    --> #78: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ statementList @ ] statement
    --> __________________
    --> #79: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #80: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement

** [FINAL] State #196: functionExpression => ( anonymousFunction | classExpression @ | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
    --> __________________
    --> #224: postfixExpression => ( postfixExpression ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): postfixExpression => @ ( postfixExpression ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )

** [FINAL] State #197: anonymousFunction => ( functionDecl | anoymousFunctionDecl @ | arrowFunction )
    --> __________________
    --> #225: functionExpression => ( anonymousFunction @ | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
    -->     Type: reduce
    -->     Reduce(exp): functionExpression => @ ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )

** [FINAL] State #198: arrowFunction => arrowFunctionParameters ('T_ARROW') arrowFunctionBody @
    --> __________________
    --> #226: anonymousFunction => ( functionDecl | anoymousFunctionDecl | arrowFunction @ )
    -->     Type: reduce
    -->     Reduce: anonymousFunction => @ ( functionDecl | anoymousFunctionDecl | arrowFunction )

** [FINAL] State #199: classElement => ( methodDefinition @ | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' singleExpression )
    --> __________________
    --> #69: classElements => [ classElements ('T_COMMA') ] classElement @
    -->     Type: reduce
    -->     Reduce: classElements => [ @ classElements ('T_COMMA') ] classElement
    --> __________________
    --> #69: classElements => [ classElements ('T_COMMA') ] classElement @
    -->     Type: reduce
    -->     Reduce: classElements => [ classElements ('T_COMMA') @ ] classElement

** State #200: caseClause => @ K_CASE expressionSequence 'T_COLON' [ statementList ]
    --> __________________
    --> #227: caseClause => K_CASE @ expressionSequence 'T_COLON' [ statementList ]
    -->     Type: move
    -->     LA: K_CASE 

** State #201: defaultClause => @ K_DEFAULT 'T_COLON' [ statementList ]
    --> __________________
    --> #228: defaultClause => K_DEFAULT @ 'T_COLON' [ statementList ]
    -->     Type: move
    -->     LA: K_DEFAULT 

** [FINAL] State #202: switchStatement => K_SWITCH ('T_LPARAN') expressionSequence ('T_RPARAN') caseBlock @
    --> __________________
    --> #229: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement @ | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** State #203: logicalAndExpression => [ @ logicalAndExpression 'T_LOG_AND' ] bitOrExpression
    --> __________________
    --> #230: bitOrExpression => [ @ bitOrExpression 'T_BIT_OR' ] bitXOrExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #204: anonymousFunction => ( functionDecl @ | anoymousFunctionDecl | arrowFunction )
    --> __________________
    --> #225: functionExpression => ( anonymousFunction @ | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
    -->     Type: reduce
    -->     Reduce(exp): functionExpression => @ ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )

** [FINAL] State #205: assignable => ( #ID# | arrayLiteral | objectLiteral @ )
    --> __________________
    --> #157: catchProduction => K_CATCH [ ('T_LPARAN') [ assignable @ ] ('T_RPARAN') ] block
    -->     Type: reduce
    -->     Reduce: catchProduction => K_CATCH [ ('T_LPARAN') @ [ assignable ] ('T_RPARAN') ] block
    --> __________________
    --> #158: formalParameterArg => assignable @
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #159: formalParameterList => [ formalParameterList ('T_COMMA') ] assignable @
    -->     Type: reduce
    -->     Reduce: formalParameterList => [ @ formalParameterList ('T_COMMA') ] assignable
    --> __________________
    --> #159: formalParameterList => [ formalParameterList ('T_COMMA') ] assignable @
    -->     Type: reduce
    -->     Reduce: formalParameterList => [ formalParameterList ('T_COMMA') @ ] assignable
    --> __________________
    --> #160: variableDeclaration => assignable @ [ 'T_ASSIGN' singleExpression ]
    -->     Type: reduce
    -->     Reduce: variableDeclaration => @ assignable [ 'T_ASSIGN' singleExpression ]

** [FINAL] State #206: objectLiteralExpression => objectLiteral @
    --> __________________
    --> #231: functionExpression => ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression @ | parenthesizedExpression )
    -->     Type: reduce
    -->     Reduce(exp): functionExpression => @ ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )

** State #207: propertyAssignment => @ ( propertyExpressionAssignment | computedPropertyExpressionAssignment | propertyShorthand )
    --> __________________
    --> #232: propertyShorthand => [ @ 'T_ELLIPSIS' ] singleExpression
    -->     Type: shift
    -->     LA: 'T_ELLIPSIS' 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 
    -->     LA: 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_THIS 
    -->     LA: K_TYPEOF K_NEW K_VOID #NUMBER# 'T_LBRACE' 
    -->     LA: K_DELETE K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' 
    -->     LA: #REGEX# K_CLASS K_SUPER #STRING# K_FALSE 
    --> __________________
    --> #233: propertyExpressionAssignment => @ propertyName ('T_COLON') singleExpression
    -->     Type: shift
    -->     LA: #NUMBER# 'T_LSQUARE' #STRING# K_THIS #ID# 
    -->     LA: K_CLASS K_FALSE K_TRUE K_DEFAULT K_DEBUGGER 
    -->     LA: K_VAR K_WHILE K_SWITCH K_CONTINUE K_VOID 
    -->     LA: K_LET K_IN K_RETURN K_TYPEOF K_FINALLY 
    -->     LA: K_NEW K_FOR K_INSTANCEOF K_CASE K_CATCH 
    -->     LA: K_ELSE K_IF K_BREAK K_THROW K_DELETE 
    -->     LA: K_WITH K_DO K_FUNCTION K_TRY K_SUPER 
    --> __________________
    --> #234: computedPropertyExpressionAssignment => @ ('T_LPARAN') singleExpression ('T_RPARAN') ('T_COLON') singleExpression
    -->     Type: shift
    -->     LA: 'T_LPARAN' 

** State #208: anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') @ ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #235: anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') @ [ functionBody ] ('T_RBRACE')
    -->     Type: pass
    -->     LA: 'T_LBRACE' 

** [FINAL] State #209: arrowFunctionParameters => ( #ID# | ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') @ )
    --> __________________
    --> #236: arrowFunction => arrowFunctionParameters @ ('T_ARROW') arrowFunctionBody
    -->     Type: reduce
    -->     Reduce: arrowFunction => @ arrowFunctionParameters ('T_ARROW') arrowFunctionBody

** State #210: formalParameterList => [ formalParameterList ('T_COMMA') @ ] assignable
    --> __________________
    --> #95: assignable => @ ( #ID# | arrayLiteral | objectLiteral )
    -->     Type: shift
    -->     LA: #ID# 'T_LBRACE' 'T_LSQUARE' 

** State #211: methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') @ ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #237: methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') @ [ functionBody ] ('T_RBRACE')
    -->     Type: pass
    -->     LA: 'T_LBRACE' 

** State #212: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList @ ) ] K_IN expressionSequence ('T_RPARAN') statement
    --> __________________
    --> #115: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN @ expressionSequence ('T_RPARAN') statement
    -->     Type: move
    -->     LA: K_IN 

** State #213: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList @ ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
    --> __________________
    --> #117: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' @ [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
    -->     Type: move
    -->     LA: 'T_SEMI' 

** State #214: variableDeclarationList => [ variableDeclarationList @ ('T_COMMA') ] variableDeclaration
    --> __________________
    --> #238: variableDeclarationList => [ variableDeclarationList ('T_COMMA') @ ] variableDeclaration
    -->     Type: pass
    -->     LA: 'T_COMMA' 

** [FINAL] State #215: variableStatement => K_VAR variableDeclarationList @ [ eos ]
    --> __________________
    --> #53: eos => @ ( 'T_SEMI' | #END# )
    -->     Type: shift
    -->     LA: 'T_SEMI' #END# 
    --> __________________
    --> #151: declaration => ( variableStatement @ | classDeclaration | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #152: statement => ( block | variableStatement @ | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** [FINAL] State #216: arrayLiteralExpression => arrayLiteral @
    --> __________________
    --> #239: functionExpression => ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression @ | objectLiteralExpression | parenthesizedExpression )
    -->     Type: reduce
    -->     Reduce(exp): functionExpression => @ ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )

** [FINAL] State #217: assignable => ( #ID# | arrayLiteral @ | objectLiteral )
    --> __________________
    --> #157: catchProduction => K_CATCH [ ('T_LPARAN') [ assignable @ ] ('T_RPARAN') ] block
    -->     Type: reduce
    -->     Reduce: catchProduction => K_CATCH [ ('T_LPARAN') @ [ assignable ] ('T_RPARAN') ] block
    --> __________________
    --> #158: formalParameterArg => assignable @
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #159: formalParameterList => [ formalParameterList ('T_COMMA') ] assignable @
    -->     Type: reduce
    -->     Reduce: formalParameterList => [ @ formalParameterList ('T_COMMA') ] assignable
    --> __________________
    --> #159: formalParameterList => [ formalParameterList ('T_COMMA') ] assignable @
    -->     Type: reduce
    -->     Reduce: formalParameterList => [ formalParameterList ('T_COMMA') @ ] assignable
    --> __________________
    --> #160: variableDeclaration => assignable @ [ 'T_ASSIGN' singleExpression ]
    -->     Type: reduce
    -->     Reduce: variableDeclaration => @ assignable [ 'T_ASSIGN' singleExpression ]

** State #218: arrayElement => [ @ 'T_ELLIPSIS' ] singleExpression
    --> __________________
    --> #240: arrayElement => [ 'T_ELLIPSIS' @ ] singleExpression
    -->     Type: move
    -->     LA: 'T_ELLIPSIS' 
    --> __________________
    --> #47: singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #219: propertyName => ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') @ singleExpression ('T_RSQUARE') )
    --> __________________
    --> #47: singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #220: identifierName => @ ( #ID# | reservedWord )
    --> __________________
    --> #241: reservedWord => @ ( keyword | K_TRUE | K_FALSE )
    -->     Type: shift
    -->     LA: K_FALSE K_TRUE K_DEFAULT K_DEBUGGER K_VAR 
    -->     LA: K_WHILE K_SWITCH K_CONTINUE K_VOID K_LET 
    -->     LA: K_IN K_RETURN K_TYPEOF K_FINALLY K_NEW 
    -->     LA: K_FOR K_INSTANCEOF K_CASE K_CATCH K_ELSE 
    -->     LA: K_THIS K_IF K_BREAK K_THROW K_DELETE 
    -->     LA: K_WITH K_DO K_FUNCTION K_TRY K_CLASS 
    -->     LA: K_SUPER 
    --> __________________
    --> #242: identifierName => ( #ID# @ | reservedWord )
    -->     Type: move
    -->     LA: #ID# 

** [FINAL] State #221: propertyName => ( identifierName | #STRING# @ | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') )
    --> __________________
    --> #243: classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName @ 'T_ASSIGN' singleExpression )
    -->     Type: reduce
    -->     Reduce: classElement => @ ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' singleExpression )
    --> __________________
    --> #243: classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName @ 'T_ASSIGN' singleExpression )
    -->     Type: reduce
    -->     Reduce: classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' @ ] propertyName 'T_ASSIGN' singleExpression )
    --> __________________
    --> #244: methodDefinition => [ 'T_SHARP' ] propertyName @ ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: methodDefinition => [ @ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #244: methodDefinition => [ 'T_SHARP' ] propertyName @ ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: methodDefinition => [ 'T_SHARP' @ ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #245: propertyExpressionAssignment => propertyName @ ('T_COLON') singleExpression
    -->     Type: reduce
    -->     Reduce: propertyExpressionAssignment => @ propertyName ('T_COLON') singleExpression

** State #222: numericLiteral => @ #NUMBER#
    --> __________________
    --> #246: numericLiteral => #NUMBER# @
    -->     Type: move
    -->     LA: #NUMBER# 

** State #223: methodDefinition => [ 'T_SHARP' @ ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #191: propertyName => @ ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') )
    -->     Type: shift
    -->     LA: #NUMBER# 'T_LSQUARE' #STRING# K_THIS #ID# 
    -->     LA: K_CLASS K_FALSE K_TRUE K_DEFAULT K_DEBUGGER 
    -->     LA: K_VAR K_WHILE K_SWITCH K_CONTINUE K_VOID 
    -->     LA: K_LET K_IN K_RETURN K_TYPEOF K_FINALLY 
    -->     LA: K_NEW K_FOR K_INSTANCEOF K_CASE K_CATCH 
    -->     LA: K_ELSE K_IF K_BREAK K_THROW K_DELETE 
    -->     LA: K_WITH K_DO K_FUNCTION K_TRY K_SUPER 

** [FINAL] State #224: postfixExpression => ( postfixExpression ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression @ )
    --> __________________
    --> #247: newExpression => ( K_NEW singleExpression [ arguments ] | postfixExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): newExpression => @ ( K_NEW singleExpression [ arguments ] | postfixExpression )
    --> __________________
    --> #248: postfixExpression => ( postfixExpression @ ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )
    -->     Type: recursion

** [FINAL] State #225: functionExpression => ( anonymousFunction @ | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
    --> __________________
    --> #224: postfixExpression => ( postfixExpression ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): postfixExpression => @ ( postfixExpression ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )

** [FINAL] State #226: anonymousFunction => ( functionDecl | anoymousFunctionDecl | arrowFunction @ )
    --> __________________
    --> #225: functionExpression => ( anonymousFunction @ | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
    -->     Type: reduce
    -->     Reduce(exp): functionExpression => @ ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )

** State #227: caseClause => K_CASE @ expressionSequence 'T_COLON' [ statementList ]
    --> __________________
    --> #25: expressionSequence => [ @ expressionSequence ('T_COMMA') ] singleExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #228: defaultClause => K_DEFAULT @ 'T_COLON' [ statementList ]
    --> __________________
    --> #249: defaultClause => K_DEFAULT 'T_COLON' @ [ statementList ]
    -->     Type: move
    -->     LA: 'T_COLON' 

** [FINAL] State #229: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement @ | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    --> __________________
    --> #70: doStatement => K_DO statement @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    -->     Type: reduce
    -->     Reduce: doStatement => K_DO @ statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #71: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #72: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') @ statement
    --> __________________
    --> #73: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement @ [ K_ELSE statement ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement [ K_ELSE statement ]
    --> __________________
    --> #74: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement @ ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE @ statement ]
    --> __________________
    --> #75: labelledStatement => #ID# 'T_COLON' statement @
    -->     Type: reduce
    -->     Reduce: labelledStatement => #ID# 'T_COLON' @ statement
    --> __________________
    --> #76: sourceElement => statement @
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #77: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ @ sourceElements ] statement
    --> __________________
    --> #77: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ sourceElements @ ] statement
    --> __________________
    --> #78: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ @ statementList ] statement
    --> __________________
    --> #78: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ statementList @ ] statement
    --> __________________
    --> #79: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #80: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement

** State #230: bitOrExpression => [ @ bitOrExpression 'T_BIT_OR' ] bitXOrExpression
    --> __________________
    --> #250: bitXOrExpression => [ @ bitXOrExpression 'T_BIT_XOR' ] bitAndExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #231: functionExpression => ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression @ | parenthesizedExpression )
    --> __________________
    --> #224: postfixExpression => ( postfixExpression ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): postfixExpression => @ ( postfixExpression ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )

** State #232: propertyShorthand => [ @ 'T_ELLIPSIS' ] singleExpression
    --> __________________
    --> #251: propertyShorthand => [ 'T_ELLIPSIS' @ ] singleExpression
    -->     Type: move
    -->     LA: 'T_ELLIPSIS' 
    --> __________________
    --> #47: singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #233: propertyExpressionAssignment => @ propertyName ('T_COLON') singleExpression
    --> __________________
    --> #191: propertyName => @ ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') )
    -->     Type: shift
    -->     LA: #NUMBER# 'T_LSQUARE' #STRING# K_THIS #ID# 
    -->     LA: K_CLASS K_FALSE K_TRUE K_DEFAULT K_DEBUGGER 
    -->     LA: K_VAR K_WHILE K_SWITCH K_CONTINUE K_VOID 
    -->     LA: K_LET K_IN K_RETURN K_TYPEOF K_FINALLY 
    -->     LA: K_NEW K_FOR K_INSTANCEOF K_CASE K_CATCH 
    -->     LA: K_ELSE K_IF K_BREAK K_THROW K_DELETE 
    -->     LA: K_WITH K_DO K_FUNCTION K_TRY K_SUPER 

** State #234: computedPropertyExpressionAssignment => @ ('T_LPARAN') singleExpression ('T_RPARAN') ('T_COLON') singleExpression
    --> __________________
    --> #252: computedPropertyExpressionAssignment => ('T_LPARAN') @ singleExpression ('T_RPARAN') ('T_COLON') singleExpression
    -->     Type: pass
    -->     LA: 'T_LPARAN' 

** State #235: anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') @ [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #165: anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE') @
    -->     Type: pass
    -->     LA: 'T_RBRACE' 
    --> __________________
    --> #154: functionBody => [ @ functionBody ] sourceElements
    -->     Type: shift
    -->     LA: K_BREAK 'T_INC' 'T_LBRACE' K_DO K_WHILE 
    -->     LA: K_NEW K_FOR 'T_LPARAN' K_SUPER K_IF 
    -->     LA: K_FALSE #REGEX# K_VOID K_DELETE K_FUNCTION 
    -->     LA: K_THIS K_NULL 'T_DEC' 'T_SUB' K_TRUE 
    -->     LA: K_CLASS 'T_BIT_NOT' 'T_ADD' #STRING# 'T_SEMI' 
    -->     LA: K_SWITCH K_CONTINUE K_RETURN K_TRY 'T_LSQUARE' 
    -->     LA: K_VAR #ID# K_THROW K_DEBUGGER #NUMBER# 
    -->     LA: K_TYPEOF 'T_LOG_NOT' K_WITH 

** State #236: arrowFunction => arrowFunctionParameters @ ('T_ARROW') arrowFunctionBody
    --> __________________
    --> #253: arrowFunction => arrowFunctionParameters ('T_ARROW') @ arrowFunctionBody
    -->     Type: pass
    -->     LA: 'T_ARROW' 

** State #237: methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') @ [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #167: methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE') @
    -->     Type: pass
    -->     LA: 'T_RBRACE' 
    --> __________________
    --> #154: functionBody => [ @ functionBody ] sourceElements
    -->     Type: shift
    -->     LA: K_BREAK 'T_INC' 'T_LBRACE' K_DO K_WHILE 
    -->     LA: K_NEW K_FOR 'T_LPARAN' K_SUPER K_IF 
    -->     LA: K_FALSE #REGEX# K_VOID K_DELETE K_FUNCTION 
    -->     LA: K_THIS K_NULL 'T_DEC' 'T_SUB' K_TRUE 
    -->     LA: K_CLASS 'T_BIT_NOT' 'T_ADD' #STRING# 'T_SEMI' 
    -->     LA: K_SWITCH K_CONTINUE K_RETURN K_TRY 'T_LSQUARE' 
    -->     LA: K_VAR #ID# K_THROW K_DEBUGGER #NUMBER# 
    -->     LA: K_TYPEOF 'T_LOG_NOT' K_WITH 

** State #238: variableDeclarationList => [ variableDeclarationList ('T_COMMA') @ ] variableDeclaration
    --> __________________
    --> #68: variableDeclaration => @ assignable [ 'T_ASSIGN' singleExpression ]
    -->     Type: shift
    -->     LA: #ID# 'T_LBRACE' 'T_LSQUARE' 

** [FINAL] State #239: functionExpression => ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression @ | objectLiteralExpression | parenthesizedExpression )
    --> __________________
    --> #224: postfixExpression => ( postfixExpression ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): postfixExpression => @ ( postfixExpression ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )

** State #240: arrayElement => [ 'T_ELLIPSIS' @ ] singleExpression
    --> __________________
    --> #47: singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #241: reservedWord => @ ( keyword | K_TRUE | K_FALSE )
    --> __________________
    --> #254: reservedWord => ( keyword | K_TRUE | K_FALSE @ )
    -->     Type: move
    -->     LA: K_FALSE 
    --> __________________
    --> #255: keyword => @ ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: shift
    -->     LA: K_DEFAULT K_DEBUGGER K_SWITCH K_CONTINUE K_VOID 
    -->     LA: K_LET K_RETURN K_TYPEOF K_VAR K_FINALLY 
    -->     LA: K_INSTANCEOF K_NEW K_CASE K_CATCH K_ELSE 
    -->     LA: K_FOR K_THIS K_IF K_BREAK K_THROW 
    -->     LA: K_DELETE K_WITH K_IN K_DO K_FUNCTION 
    -->     LA: K_TRY K_CLASS K_WHILE K_SUPER 
    --> __________________
    --> #256: reservedWord => ( keyword | K_TRUE @ | K_FALSE )
    -->     Type: move
    -->     LA: K_TRUE 

** [FINAL] State #242: identifierName => ( #ID# @ | reservedWord )
    --> __________________
    --> #257: memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' [ 'T_SHARP' ] identifierName @
    -->     Type: reduce
    -->     Reduce(exp): memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' @ [ 'T_SHARP' ] identifierName
    --> __________________
    --> #257: memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' [ 'T_SHARP' ] identifierName @
    -->     Type: reduce
    -->     Reduce(exp): memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' [ 'T_SHARP' @ ] identifierName
    --> __________________
    --> #258: propertyName => ( identifierName @ | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') )
    -->     Type: reduce
    -->     Reduce: propertyName => @ ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') )

** State #243: classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName @ 'T_ASSIGN' singleExpression )
    --> __________________
    --> #259: classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' @ singleExpression )
    -->     Type: move
    -->     LA: 'T_ASSIGN' 

** State #244: methodDefinition => [ 'T_SHARP' ] propertyName @ ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #260: methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') @ [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: pass
    -->     LA: 'T_LPARAN' 

** State #245: propertyExpressionAssignment => propertyName @ ('T_COLON') singleExpression
    --> __________________
    --> #261: propertyExpressionAssignment => propertyName ('T_COLON') @ singleExpression
    -->     Type: pass
    -->     LA: 'T_COLON' 

** [FINAL] State #246: numericLiteral => #NUMBER# @
    --> __________________
    --> #262: propertyName => ( identifierName | #STRING# | numericLiteral @ | ('T_LSQUARE') singleExpression ('T_RSQUARE') )
    -->     Type: reduce
    -->     Reduce: propertyName => @ ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') )

** [FINAL] State #247: newExpression => ( K_NEW singleExpression [ arguments ] | postfixExpression @ )
    --> __________________
    --> #263: deleteExpression => ( K_DELETE deleteExpression | newExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): deleteExpression => @ ( K_DELETE deleteExpression | newExpression )

** State #248: postfixExpression => ( postfixExpression @ ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )
    --> __________________
    --> #264: postDecreaseExpression => [ @ postDecreaseExpression ] 'T_DEC'
    -->     Type: shift
    -->     LA: 'T_DEC' 
    --> __________________
    --> #265: memberIndexExpression => [ @ memberIndexExpression ] 'T_LSQUARE' expressionSequence 'T_RSQUARE'
    -->     Type: shift
    -->     LA: 'T_LSQUARE' 
    --> __________________
    --> #266: memberDotExpression => [ @ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' [ 'T_SHARP' ] identifierName
    -->     Type: shift
    -->     LA: 'T_QUERY' 'T_DOT' 
    --> __________________
    --> #267: argumentsExpression => [ @ argumentsExpression ] arguments
    -->     Type: shift
    -->     LA: 'T_LPARAN' 
    --> __________________
    --> #268: postIncrementExpression => [ @ postIncrementExpression ] 'T_INC'
    -->     Type: shift
    -->     LA: 'T_INC' 

** [FINAL] State #249: defaultClause => K_DEFAULT 'T_COLON' @ [ statementList ]
    --> __________________
    --> #42: statementList => [ @ statementList ] statement
    -->     Type: shift
    -->     LA: K_BREAK 'T_INC' 'T_LBRACE' K_DO K_WHILE 
    -->     LA: K_NEW K_FOR 'T_LPARAN' K_SUPER K_IF 
    -->     LA: K_FALSE #REGEX# K_VOID K_DELETE K_FUNCTION 
    -->     LA: K_THIS K_NULL 'T_DEC' 'T_SUB' K_TRUE 
    -->     LA: K_CLASS 'T_BIT_NOT' 'T_ADD' #STRING# 'T_SEMI' 
    -->     LA: K_SWITCH K_CONTINUE K_RETURN K_TRY 'T_LSQUARE' 
    -->     LA: K_VAR #ID# K_THROW K_DEBUGGER #NUMBER# 
    -->     LA: K_TYPEOF 'T_LOG_NOT' K_WITH 
    --> __________________
    --> #144: caseBlock => ('T_LBRACE') [ caseClauses ] [ defaultClause @ [ caseClauses ] ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: caseBlock => ('T_LBRACE') @ [ caseClauses ] [ defaultClause [ caseClauses ] ] ('T_RBRACE')
    --> __________________
    --> #144: caseBlock => ('T_LBRACE') [ caseClauses ] [ defaultClause @ [ caseClauses ] ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: caseBlock => ('T_LBRACE') [ caseClauses @ ] [ defaultClause [ caseClauses ] ] ('T_RBRACE')

** State #250: bitXOrExpression => [ @ bitXOrExpression 'T_BIT_XOR' ] bitAndExpression
    --> __________________
    --> #269: bitAndExpression => [ @ bitAndExpression 'T_BIT_AND' ] equalityExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #251: propertyShorthand => [ 'T_ELLIPSIS' @ ] singleExpression
    --> __________________
    --> #47: singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #252: computedPropertyExpressionAssignment => ('T_LPARAN') @ singleExpression ('T_RPARAN') ('T_COLON') singleExpression
    --> __________________
    --> #47: singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #253: arrowFunction => arrowFunctionParameters ('T_ARROW') @ arrowFunctionBody
    --> __________________
    --> #270: arrowFunctionBody => @ ( singleExpression | 'T_LBRACE' [ functionBody ] 'T_RBRACE' )
    -->     Type: shift
    -->     LA: 'T_LBRACE' 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 
    -->     LA: 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_THIS 
    -->     LA: K_TYPEOF K_NEW K_VOID #NUMBER# K_DELETE 
    -->     LA: K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# 
    -->     LA: K_CLASS K_SUPER #STRING# K_FALSE 

** [FINAL] State #254: reservedWord => ( keyword | K_TRUE | K_FALSE @ )
    --> __________________
    --> #271: identifierName => ( #ID# | reservedWord @ )
    -->     Type: reduce
    -->     Reduce: identifierName => @ ( #ID# | reservedWord )

** State #255: keyword => @ ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #272: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET @ )
    -->     Type: move
    -->     LA: K_LET 
    --> __________________
    --> #273: keyword => ( K_BREAK @ | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_BREAK 
    --> __________________
    --> #274: keyword => ( K_BREAK | K_DO @ | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_DO 
    --> __________________
    --> #275: keyword => ( K_BREAK | K_DO | K_INSTANCEOF @ | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_INSTANCEOF 
    --> __________________
    --> #276: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF @ | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_TYPEOF 
    --> __________________
    --> #277: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE @ | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_CASE 
    --> __________________
    --> #278: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE @ | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_ELSE 
    --> __________________
    --> #279: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW @ | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_NEW 
    --> __________________
    --> #280: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR @ | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_VAR 
    --> __________________
    --> #281: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH @ | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_CATCH 
    --> __________________
    --> #282: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY @ | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_FINALLY 
    --> __________________
    --> #283: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN @ | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_RETURN 
    --> __________________
    --> #284: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID @ | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_VOID 
    --> __________________
    --> #285: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE @ | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_CONTINUE 
    --> __________________
    --> #286: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR @ | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_FOR 
    --> __________________
    --> #287: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH @ | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_SWITCH 
    --> __________________
    --> #288: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE @ | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_WHILE 
    --> __________________
    --> #289: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER @ | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_DEBUGGER 
    --> __________________
    --> #290: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION @ | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_FUNCTION 
    --> __________________
    --> #291: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS @ | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_THIS 
    --> __________________
    --> #292: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH @ | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_WITH 
    --> __________________
    --> #293: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT @ | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_DEFAULT 
    --> __________________
    --> #294: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF @ | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_IF 
    --> __________________
    --> #295: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW @ | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_THROW 
    --> __________________
    --> #296: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE @ | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_DELETE 
    --> __________________
    --> #297: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN @ | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_IN 
    --> __________________
    --> #298: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY @ | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_TRY 
    --> __________________
    --> #299: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS @ | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_CLASS 
    --> __________________
    --> #300: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER @ | K_LET )
    -->     Type: move
    -->     LA: K_SUPER 

** [FINAL] State #256: reservedWord => ( keyword | K_TRUE @ | K_FALSE )
    --> __________________
    --> #271: identifierName => ( #ID# | reservedWord @ )
    -->     Type: reduce
    -->     Reduce: identifierName => @ ( #ID# | reservedWord )

** [FINAL] State #257: memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' [ 'T_SHARP' ] identifierName @
    --> __________________
    --> #301: memberDotExpression => [ memberDotExpression @ ] [ 'T_QUERY' ] 'T_DOT' [ 'T_SHARP' ] identifierName
    -->     Type: recursion
    -->     LA: 'T_QUERY' 'T_DOT' 
    --> __________________
    --> #302: postfixExpression => ( postfixExpression ( memberIndexExpression | memberDotExpression @ | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )
    -->     Type: reduce
    -->     Reduce(exp): postfixExpression => ( postfixExpression @ ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )

** [FINAL] State #258: propertyName => ( identifierName @ | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') )
    --> __________________
    --> #243: classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName @ 'T_ASSIGN' singleExpression )
    -->     Type: reduce
    -->     Reduce: classElement => @ ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' singleExpression )
    --> __________________
    --> #243: classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName @ 'T_ASSIGN' singleExpression )
    -->     Type: reduce
    -->     Reduce: classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' @ ] propertyName 'T_ASSIGN' singleExpression )
    --> __________________
    --> #244: methodDefinition => [ 'T_SHARP' ] propertyName @ ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: methodDefinition => [ @ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #244: methodDefinition => [ 'T_SHARP' ] propertyName @ ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: methodDefinition => [ 'T_SHARP' @ ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #245: propertyExpressionAssignment => propertyName @ ('T_COLON') singleExpression
    -->     Type: reduce
    -->     Reduce: propertyExpressionAssignment => @ propertyName ('T_COLON') singleExpression

** State #259: classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' @ singleExpression )
    --> __________________
    --> #47: singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #260: methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') @ [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #211: methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') @ ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: pass
    -->     LA: 'T_RPARAN' 
    --> __________________
    --> #89: formalParameterList => [ @ formalParameterList ('T_COMMA') ] assignable
    -->     Type: shift
    -->     LA: 'T_LSQUARE' 'T_LBRACE' #ID# 

** State #261: propertyExpressionAssignment => propertyName ('T_COLON') @ singleExpression
    --> __________________
    --> #47: singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #262: propertyName => ( identifierName | #STRING# | numericLiteral @ | ('T_LSQUARE') singleExpression ('T_RSQUARE') )
    --> __________________
    --> #243: classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName @ 'T_ASSIGN' singleExpression )
    -->     Type: reduce
    -->     Reduce: classElement => @ ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' singleExpression )
    --> __________________
    --> #243: classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName @ 'T_ASSIGN' singleExpression )
    -->     Type: reduce
    -->     Reduce: classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' @ ] propertyName 'T_ASSIGN' singleExpression )
    --> __________________
    --> #244: methodDefinition => [ 'T_SHARP' ] propertyName @ ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: methodDefinition => [ @ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #244: methodDefinition => [ 'T_SHARP' ] propertyName @ ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: methodDefinition => [ 'T_SHARP' @ ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #245: propertyExpressionAssignment => propertyName @ ('T_COLON') singleExpression
    -->     Type: reduce
    -->     Reduce: propertyExpressionAssignment => @ propertyName ('T_COLON') singleExpression

** [FINAL] State #263: deleteExpression => ( K_DELETE deleteExpression | newExpression @ )
    --> __________________
    --> #303: deleteExpression => ( K_DELETE deleteExpression @ | newExpression )
    -->     Type: reduce
    -->     Reduce(exp): deleteExpression => ( K_DELETE @ deleteExpression | newExpression )
    --> __________________
    --> #304: voidExpression => ( K_VOID voidExpression | deleteExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): voidExpression => @ ( K_VOID voidExpression | deleteExpression )

** State #264: postDecreaseExpression => [ @ postDecreaseExpression ] 'T_DEC'
    --> __________________
    --> #305: postDecreaseExpression => [ postDecreaseExpression ] 'T_DEC' @
    -->     Type: move
    -->     LA: 'T_DEC' 

** State #265: memberIndexExpression => [ @ memberIndexExpression ] 'T_LSQUARE' expressionSequence 'T_RSQUARE'
    --> __________________
    --> #306: memberIndexExpression => [ memberIndexExpression ] 'T_LSQUARE' @ expressionSequence 'T_RSQUARE'
    -->     Type: move
    -->     LA: 'T_LSQUARE' 

** State #266: memberDotExpression => [ @ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' [ 'T_SHARP' ] identifierName
    --> __________________
    --> #307: memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' @ ] 'T_DOT' [ 'T_SHARP' ] identifierName
    -->     Type: move
    -->     LA: 'T_QUERY' 
    --> __________________
    --> #308: memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' @ [ 'T_SHARP' ] identifierName
    -->     Type: move
    -->     LA: 'T_DOT' 

** State #267: argumentsExpression => [ @ argumentsExpression ] arguments
    --> __________________
    --> #309: arguments => @ ('T_LPARAN') [ argument ] ('T_RPARAN')
    -->     Type: shift
    -->     LA: 'T_LPARAN' 

** State #268: postIncrementExpression => [ @ postIncrementExpression ] 'T_INC'
    --> __________________
    --> #310: postIncrementExpression => [ postIncrementExpression ] 'T_INC' @
    -->     Type: move
    -->     LA: 'T_INC' 

** State #269: bitAndExpression => [ @ bitAndExpression 'T_BIT_AND' ] equalityExpression
    --> __________________
    --> #311: equalityExpression => [ @ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #270: arrowFunctionBody => @ ( singleExpression | 'T_LBRACE' [ functionBody ] 'T_RBRACE' )
    --> __________________
    --> #312: arrowFunctionBody => ( singleExpression | 'T_LBRACE' @ [ functionBody ] 'T_RBRACE' )
    -->     Type: move
    -->     LA: 'T_LBRACE' 
    --> __________________
    --> #47: singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #271: identifierName => ( #ID# | reservedWord @ )
    --> __________________
    --> #257: memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' [ 'T_SHARP' ] identifierName @
    -->     Type: reduce
    -->     Reduce(exp): memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' @ [ 'T_SHARP' ] identifierName
    --> __________________
    --> #257: memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' [ 'T_SHARP' ] identifierName @
    -->     Type: reduce
    -->     Reduce(exp): memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' [ 'T_SHARP' @ ] identifierName
    --> __________________
    --> #258: propertyName => ( identifierName @ | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') )
    -->     Type: reduce
    -->     Reduce: propertyName => @ ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') )

** [FINAL] State #272: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET @ )
    --> __________________
    --> #313: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #273: keyword => ( K_BREAK @ | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #313: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #274: keyword => ( K_BREAK | K_DO @ | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #313: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #275: keyword => ( K_BREAK | K_DO | K_INSTANCEOF @ | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #313: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #276: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF @ | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #313: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #277: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE @ | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #313: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #278: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE @ | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #313: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #279: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW @ | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #313: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #280: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR @ | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #313: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #281: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH @ | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #313: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #282: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY @ | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #313: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #283: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN @ | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #313: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #284: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID @ | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #313: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #285: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE @ | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #313: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #286: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR @ | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #313: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #287: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH @ | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #313: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #288: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE @ | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #313: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #289: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER @ | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #313: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #290: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION @ | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #313: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #291: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS @ | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #313: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #292: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH @ | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #313: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #293: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT @ | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #313: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #294: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF @ | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #313: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #295: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW @ | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #313: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #296: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE @ | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #313: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #297: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN @ | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #313: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #298: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY @ | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #313: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #299: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS @ | K_SUPER | K_LET )
    --> __________________
    --> #313: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #300: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER @ | K_LET )
    --> __________________
    --> #313: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** State #301: memberDotExpression => [ memberDotExpression @ ] [ 'T_QUERY' ] 'T_DOT' [ 'T_SHARP' ] identifierName
    --> __________________
    --> #308: memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' @ [ 'T_SHARP' ] identifierName
    -->     Type: move
    -->     LA: 'T_DOT' 
    --> __________________
    --> #307: memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' @ ] 'T_DOT' [ 'T_SHARP' ] identifierName
    -->     Type: move
    -->     LA: 'T_QUERY' 

** [FINAL] State #302: postfixExpression => ( postfixExpression ( memberIndexExpression | memberDotExpression @ | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )
    --> __________________
    --> #247: newExpression => ( K_NEW singleExpression [ arguments ] | postfixExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): newExpression => @ ( K_NEW singleExpression [ arguments ] | postfixExpression )
    --> __________________
    --> #248: postfixExpression => ( postfixExpression @ ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )
    -->     Type: recursion
    -->     LA: 'T_INC' 'T_LPARAN' 'T_LSQUARE' 'T_DOT' 'T_DEC' 
    -->     LA: 'T_QUERY' 

** [FINAL] State #303: deleteExpression => ( K_DELETE deleteExpression @ | newExpression )
    --> __________________
    --> #303: deleteExpression => ( K_DELETE deleteExpression @ | newExpression )
    -->     Type: reduce
    -->     Reduce(exp): deleteExpression => ( K_DELETE @ deleteExpression | newExpression )
    --> __________________
    --> #304: voidExpression => ( K_VOID voidExpression | deleteExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): voidExpression => @ ( K_VOID voidExpression | deleteExpression )

** [FINAL] State #304: voidExpression => ( K_VOID voidExpression | deleteExpression @ )
    --> __________________
    --> #314: typeofExpression => ( K_TYPEOF typeofExpression | voidExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): typeofExpression => @ ( K_TYPEOF typeofExpression | voidExpression )
    --> __________________
    --> #315: voidExpression => ( K_VOID voidExpression @ | deleteExpression )
    -->     Type: reduce
    -->     Reduce(exp): voidExpression => ( K_VOID @ voidExpression | deleteExpression )

** [FINAL] State #305: postDecreaseExpression => [ postDecreaseExpression ] 'T_DEC' @
    --> __________________
    --> #316: postDecreaseExpression => [ postDecreaseExpression @ ] 'T_DEC'
    -->     Type: recursion
    -->     LA: 'T_DEC' 
    --> __________________
    --> #317: postfixExpression => ( postfixExpression ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression @ ) | functionExpression )
    -->     Type: reduce
    -->     Reduce(exp): postfixExpression => ( postfixExpression @ ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )

** State #306: memberIndexExpression => [ memberIndexExpression ] 'T_LSQUARE' @ expressionSequence 'T_RSQUARE'
    --> __________________
    --> #25: expressionSequence => [ @ expressionSequence ('T_COMMA') ] singleExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #307: memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' @ ] 'T_DOT' [ 'T_SHARP' ] identifierName
    --> __________________
    --> #308: memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' @ [ 'T_SHARP' ] identifierName
    -->     Type: move
    -->     LA: 'T_DOT' 

** State #308: memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' @ [ 'T_SHARP' ] identifierName
    --> __________________
    --> #220: identifierName => @ ( #ID# | reservedWord )
    -->     Type: shift
    -->     LA: #ID# K_CLASS K_FALSE K_TRUE K_DEFAULT 
    -->     LA: K_DEBUGGER K_VAR K_WHILE K_SWITCH K_CONTINUE 
    -->     LA: K_VOID K_LET K_IN K_RETURN K_TYPEOF 
    -->     LA: K_FINALLY K_NEW K_FOR K_INSTANCEOF K_CASE 
    -->     LA: K_CATCH K_ELSE K_THIS K_IF K_BREAK 
    -->     LA: K_THROW K_DELETE K_WITH K_DO K_FUNCTION 
    -->     LA: K_TRY K_SUPER 
    --> __________________
    --> #318: memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' [ 'T_SHARP' @ ] identifierName
    -->     Type: move
    -->     LA: 'T_SHARP' 

** State #309: arguments => @ ('T_LPARAN') [ argument ] ('T_RPARAN')
    --> __________________
    --> #319: arguments => ('T_LPARAN') @ [ argument ] ('T_RPARAN')
    -->     Type: pass
    -->     LA: 'T_LPARAN' 

** [FINAL] State #310: postIncrementExpression => [ postIncrementExpression ] 'T_INC' @
    --> __________________
    --> #320: postIncrementExpression => [ postIncrementExpression @ ] 'T_INC'
    -->     Type: recursion
    -->     LA: 'T_INC' 
    --> __________________
    --> #321: postfixExpression => ( postfixExpression ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression @ | postDecreaseExpression ) | functionExpression )
    -->     Type: reduce
    -->     Reduce(exp): postfixExpression => ( postfixExpression @ ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )

** State #311: equalityExpression => [ @ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression
    --> __________________
    --> #322: inExpression => [ @ inExpression K_IN ] instanceofExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #312: arrowFunctionBody => ( singleExpression | 'T_LBRACE' @ [ functionBody ] 'T_RBRACE' )
    --> __________________
    --> #166: arrowFunctionBody => ( singleExpression | 'T_LBRACE' [ functionBody ] 'T_RBRACE' @ )
    -->     Type: move
    -->     LA: 'T_RBRACE' 
    --> __________________
    --> #154: functionBody => [ @ functionBody ] sourceElements
    -->     Type: shift
    -->     LA: K_BREAK 'T_INC' 'T_LBRACE' K_DO K_WHILE 
    -->     LA: K_NEW K_FOR 'T_LPARAN' K_SUPER K_IF 
    -->     LA: K_FALSE #REGEX# K_VOID K_DELETE K_FUNCTION 
    -->     LA: K_THIS K_NULL 'T_DEC' 'T_SUB' K_TRUE 
    -->     LA: K_CLASS 'T_BIT_NOT' 'T_ADD' #STRING# 'T_SEMI' 
    -->     LA: K_SWITCH K_CONTINUE K_RETURN K_TRY 'T_LSQUARE' 
    -->     LA: K_VAR #ID# K_THROW K_DEBUGGER #NUMBER# 
    -->     LA: K_TYPEOF 'T_LOG_NOT' K_WITH 

** [FINAL] State #313: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    --> __________________
    --> #271: identifierName => ( #ID# | reservedWord @ )
    -->     Type: reduce
    -->     Reduce: identifierName => @ ( #ID# | reservedWord )

** [FINAL] State #314: typeofExpression => ( K_TYPEOF typeofExpression | voidExpression @ )
    --> __________________
    --> #323: preIncrementExpression => ( 'T_INC' preIncrementExpression | typeofExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): preIncrementExpression => @ ( 'T_INC' preIncrementExpression | typeofExpression )
    --> __________________
    --> #324: typeofExpression => ( K_TYPEOF typeofExpression @ | voidExpression )
    -->     Type: reduce
    -->     Reduce(exp): typeofExpression => ( K_TYPEOF @ typeofExpression | voidExpression )

** [FINAL] State #315: voidExpression => ( K_VOID voidExpression @ | deleteExpression )
    --> __________________
    --> #314: typeofExpression => ( K_TYPEOF typeofExpression | voidExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): typeofExpression => @ ( K_TYPEOF typeofExpression | voidExpression )
    --> __________________
    --> #315: voidExpression => ( K_VOID voidExpression @ | deleteExpression )
    -->     Type: reduce
    -->     Reduce(exp): voidExpression => ( K_VOID @ voidExpression | deleteExpression )

** State #316: postDecreaseExpression => [ postDecreaseExpression @ ] 'T_DEC'
    --> __________________
    --> #305: postDecreaseExpression => [ postDecreaseExpression ] 'T_DEC' @
    -->     Type: move
    -->     LA: 'T_DEC' 

** [FINAL] State #317: postfixExpression => ( postfixExpression ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression @ ) | functionExpression )
    --> __________________
    --> #247: newExpression => ( K_NEW singleExpression [ arguments ] | postfixExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): newExpression => @ ( K_NEW singleExpression [ arguments ] | postfixExpression )
    --> __________________
    --> #248: postfixExpression => ( postfixExpression @ ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )
    -->     Type: recursion
    -->     LA: 'T_INC' 'T_LPARAN' 'T_LSQUARE' 'T_DOT' 'T_DEC' 
    -->     LA: 'T_QUERY' 

** State #318: memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' [ 'T_SHARP' @ ] identifierName
    --> __________________
    --> #220: identifierName => @ ( #ID# | reservedWord )
    -->     Type: shift
    -->     LA: #ID# K_CLASS K_FALSE K_TRUE K_DEFAULT 
    -->     LA: K_DEBUGGER K_VAR K_WHILE K_SWITCH K_CONTINUE 
    -->     LA: K_VOID K_LET K_IN K_RETURN K_TYPEOF 
    -->     LA: K_FINALLY K_NEW K_FOR K_INSTANCEOF K_CASE 
    -->     LA: K_CATCH K_ELSE K_THIS K_IF K_BREAK 
    -->     LA: K_THROW K_DELETE K_WITH K_DO K_FUNCTION 
    -->     LA: K_TRY K_SUPER 

** State #319: arguments => ('T_LPARAN') @ [ argument ] ('T_RPARAN')
    --> __________________
    --> #325: arguments => ('T_LPARAN') [ argument ] ('T_RPARAN') @
    -->     Type: pass
    -->     LA: 'T_RPARAN' 
    --> __________________
    --> #326: argument => [ @ argument ('T_COMMA') ] [ ('T_ELLIPSIS') ] ( singleExpression | #ID# )
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LPARAN' K_TRUE 'T_LBRACE' #NUMBER# 
    -->     LA: K_VOID K_NEW K_TYPEOF K_THIS K_FUNCTION 
    -->     LA: 'T_INC' K_NULL 'T_DEC' 'T_SUB' 'T_BIT_NOT' 
    -->     LA: 'T_ADD' 'T_LOG_NOT' 'T_ELLIPSIS' #ID# 'T_LSQUARE' 

** State #320: postIncrementExpression => [ postIncrementExpression @ ] 'T_INC'
    --> __________________
    --> #310: postIncrementExpression => [ postIncrementExpression ] 'T_INC' @
    -->     Type: move
    -->     LA: 'T_INC' 

** [FINAL] State #321: postfixExpression => ( postfixExpression ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression @ | postDecreaseExpression ) | functionExpression )
    --> __________________
    --> #247: newExpression => ( K_NEW singleExpression [ arguments ] | postfixExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): newExpression => @ ( K_NEW singleExpression [ arguments ] | postfixExpression )
    --> __________________
    --> #248: postfixExpression => ( postfixExpression @ ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )
    -->     Type: recursion
    -->     LA: 'T_INC' 'T_LPARAN' 'T_LSQUARE' 'T_DOT' 'T_DEC' 
    -->     LA: 'T_QUERY' 

** State #322: inExpression => [ @ inExpression K_IN ] instanceofExpression
    --> __________________
    --> #327: instanceofExpression => [ @ instanceofExpression K_INSTANCEOF ] relationalExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #323: preIncrementExpression => ( 'T_INC' preIncrementExpression | typeofExpression @ )
    --> __________________
    --> #328: preDecreaseExpression => ( 'T_DEC' preDecreaseExpression | preIncrementExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): preDecreaseExpression => @ ( 'T_DEC' preDecreaseExpression | preIncrementExpression )
    --> __________________
    --> #329: preIncrementExpression => ( 'T_INC' preIncrementExpression @ | typeofExpression )
    -->     Type: reduce
    -->     Reduce(exp): preIncrementExpression => ( 'T_INC' @ preIncrementExpression | typeofExpression )

** [FINAL] State #324: typeofExpression => ( K_TYPEOF typeofExpression @ | voidExpression )
    --> __________________
    --> #323: preIncrementExpression => ( 'T_INC' preIncrementExpression | typeofExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): preIncrementExpression => @ ( 'T_INC' preIncrementExpression | typeofExpression )
    --> __________________
    --> #324: typeofExpression => ( K_TYPEOF typeofExpression @ | voidExpression )
    -->     Type: reduce
    -->     Reduce(exp): typeofExpression => ( K_TYPEOF @ typeofExpression | voidExpression )

** [FINAL] State #325: arguments => ('T_LPARAN') [ argument ] ('T_RPARAN') @
    --> __________________
    --> #330: argumentsExpression => [ argumentsExpression ] arguments @
    -->     Type: reduce
    -->     Reduce(exp): argumentsExpression => [ @ argumentsExpression ] arguments
    --> __________________
    --> #330: argumentsExpression => [ argumentsExpression ] arguments @
    -->     Type: reduce
    -->     Reduce(exp): argumentsExpression => [ argumentsExpression @ ] arguments
    --> __________________
    --> #331: newExpression => ( K_NEW singleExpression [ arguments @ ] | postfixExpression )
    -->     Type: reduce
    -->     Reduce(exp): newExpression => ( K_NEW singleExpression @ [ arguments ] | postfixExpression )

** State #326: argument => [ @ argument ('T_COMMA') ] [ ('T_ELLIPSIS') ] ( singleExpression | #ID# )
    --> __________________
    --> #332: argument => [ argument ('T_COMMA') ] [ ('T_ELLIPSIS') @ ] ( singleExpression | #ID# )
    -->     Type: pass
    -->     LA: 'T_ELLIPSIS' 
    --> __________________
    --> #47: singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 
    --> __________________
    --> #333: argument => [ argument ('T_COMMA') ] [ ('T_ELLIPSIS') ] ( singleExpression | #ID# @ )
    -->     Type: move
    -->     LA: #ID# 

** State #327: instanceofExpression => [ @ instanceofExpression K_INSTANCEOF ] relationalExpression
    --> __________________
    --> #334: relationalExpression => [ @ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #328: preDecreaseExpression => ( 'T_DEC' preDecreaseExpression | preIncrementExpression @ )
    --> __________________
    --> #335: preDecreaseExpression => ( 'T_DEC' preDecreaseExpression @ | preIncrementExpression )
    -->     Type: reduce
    -->     Reduce(exp): preDecreaseExpression => ( 'T_DEC' @ preDecreaseExpression | preIncrementExpression )
    --> __________________
    --> #336: unaryPlusExpression => ( 'T_ADD' unaryPlusExpression | preDecreaseExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): unaryPlusExpression => @ ( 'T_ADD' unaryPlusExpression | preDecreaseExpression )

** [FINAL] State #329: preIncrementExpression => ( 'T_INC' preIncrementExpression @ | typeofExpression )
    --> __________________
    --> #328: preDecreaseExpression => ( 'T_DEC' preDecreaseExpression | preIncrementExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): preDecreaseExpression => @ ( 'T_DEC' preDecreaseExpression | preIncrementExpression )
    --> __________________
    --> #329: preIncrementExpression => ( 'T_INC' preIncrementExpression @ | typeofExpression )
    -->     Type: reduce
    -->     Reduce(exp): preIncrementExpression => ( 'T_INC' @ preIncrementExpression | typeofExpression )

** [FINAL] State #330: argumentsExpression => [ argumentsExpression ] arguments @
    --> __________________
    --> #337: argumentsExpression => [ argumentsExpression @ ] arguments
    -->     Type: recursion
    -->     LA: 'T_LPARAN' 
    --> __________________
    --> #338: postfixExpression => ( postfixExpression ( memberIndexExpression | memberDotExpression | argumentsExpression @ | postIncrementExpression | postDecreaseExpression ) | functionExpression )
    -->     Type: reduce
    -->     Reduce(exp): postfixExpression => ( postfixExpression @ ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )

** [FINAL] State #331: newExpression => ( K_NEW singleExpression [ arguments @ ] | postfixExpression )
    --> __________________
    --> #263: deleteExpression => ( K_DELETE deleteExpression | newExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): deleteExpression => @ ( K_DELETE deleteExpression | newExpression )

** State #332: argument => [ argument ('T_COMMA') ] [ ('T_ELLIPSIS') @ ] ( singleExpression | #ID# )
    --> __________________
    --> #333: argument => [ argument ('T_COMMA') ] [ ('T_ELLIPSIS') ] ( singleExpression | #ID# @ )
    -->     Type: move
    -->     LA: #ID# 
    --> __________________
    --> #47: singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #333: argument => [ argument ('T_COMMA') ] [ ('T_ELLIPSIS') ] ( singleExpression | #ID# @ )
    --> __________________
    --> #339: argument => [ argument @ ('T_COMMA') ] [ ('T_ELLIPSIS') ] ( singleExpression | #ID# )
    -->     Type: recursion
    -->     LA: 'T_COMMA' 
    --> __________________
    --> #340: arguments => ('T_LPARAN') [ argument @ ] ('T_RPARAN')
    -->     Type: reduce
    -->     Reduce: arguments => ('T_LPARAN') @ [ argument ] ('T_RPARAN')

** State #334: relationalExpression => [ @ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression
    --> __________________
    --> #341: bitShiftExpression => [ @ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #335: preDecreaseExpression => ( 'T_DEC' preDecreaseExpression @ | preIncrementExpression )
    --> __________________
    --> #335: preDecreaseExpression => ( 'T_DEC' preDecreaseExpression @ | preIncrementExpression )
    -->     Type: reduce
    -->     Reduce(exp): preDecreaseExpression => ( 'T_DEC' @ preDecreaseExpression | preIncrementExpression )
    --> __________________
    --> #336: unaryPlusExpression => ( 'T_ADD' unaryPlusExpression | preDecreaseExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): unaryPlusExpression => @ ( 'T_ADD' unaryPlusExpression | preDecreaseExpression )

** [FINAL] State #336: unaryPlusExpression => ( 'T_ADD' unaryPlusExpression | preDecreaseExpression @ )
    --> __________________
    --> #342: unaryMinusExpression => ( 'T_SUB' unaryMinusExpression | unaryPlusExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): unaryMinusExpression => @ ( 'T_SUB' unaryMinusExpression | unaryPlusExpression )
    --> __________________
    --> #343: unaryPlusExpression => ( 'T_ADD' unaryPlusExpression @ | preDecreaseExpression )
    -->     Type: reduce
    -->     Reduce(exp): unaryPlusExpression => ( 'T_ADD' @ unaryPlusExpression | preDecreaseExpression )

** State #337: argumentsExpression => [ argumentsExpression @ ] arguments
    --> __________________
    --> #309: arguments => @ ('T_LPARAN') [ argument ] ('T_RPARAN')
    -->     Type: shift
    -->     LA: 'T_LPARAN' 

** [FINAL] State #338: postfixExpression => ( postfixExpression ( memberIndexExpression | memberDotExpression | argumentsExpression @ | postIncrementExpression | postDecreaseExpression ) | functionExpression )
    --> __________________
    --> #247: newExpression => ( K_NEW singleExpression [ arguments ] | postfixExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): newExpression => @ ( K_NEW singleExpression [ arguments ] | postfixExpression )
    --> __________________
    --> #248: postfixExpression => ( postfixExpression @ ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )
    -->     Type: recursion
    -->     LA: 'T_INC' 'T_LPARAN' 'T_LSQUARE' 'T_DOT' 'T_DEC' 
    -->     LA: 'T_QUERY' 

** State #339: argument => [ argument @ ('T_COMMA') ] [ ('T_ELLIPSIS') ] ( singleExpression | #ID# )
    --> __________________
    --> #344: argument => [ argument ('T_COMMA') @ ] [ ('T_ELLIPSIS') ] ( singleExpression | #ID# )
    -->     Type: pass
    -->     LA: 'T_COMMA' 

** State #340: arguments => ('T_LPARAN') [ argument @ ] ('T_RPARAN')
    --> __________________
    --> #325: arguments => ('T_LPARAN') [ argument ] ('T_RPARAN') @
    -->     Type: pass
    -->     LA: 'T_RPARAN' 

** State #341: bitShiftExpression => [ @ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression
    --> __________________
    --> #345: coalesceExpression => [ @ coalesceExpression 'T_COALESCE' ] additiveExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #342: unaryMinusExpression => ( 'T_SUB' unaryMinusExpression | unaryPlusExpression @ )
    --> __________________
    --> #346: bitNotExpression => ( 'T_BIT_NOT' bitNotExpression | unaryMinusExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): bitNotExpression => @ ( 'T_BIT_NOT' bitNotExpression | unaryMinusExpression )
    --> __________________
    --> #347: unaryMinusExpression => ( 'T_SUB' unaryMinusExpression @ | unaryPlusExpression )
    -->     Type: reduce
    -->     Reduce(exp): unaryMinusExpression => ( 'T_SUB' @ unaryMinusExpression | unaryPlusExpression )

** [FINAL] State #343: unaryPlusExpression => ( 'T_ADD' unaryPlusExpression @ | preDecreaseExpression )
    --> __________________
    --> #342: unaryMinusExpression => ( 'T_SUB' unaryMinusExpression | unaryPlusExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): unaryMinusExpression => @ ( 'T_SUB' unaryMinusExpression | unaryPlusExpression )
    --> __________________
    --> #343: unaryPlusExpression => ( 'T_ADD' unaryPlusExpression @ | preDecreaseExpression )
    -->     Type: reduce
    -->     Reduce(exp): unaryPlusExpression => ( 'T_ADD' @ unaryPlusExpression | preDecreaseExpression )

** State #344: argument => [ argument ('T_COMMA') @ ] [ ('T_ELLIPSIS') ] ( singleExpression | #ID# )
    --> __________________
    --> #333: argument => [ argument ('T_COMMA') ] [ ('T_ELLIPSIS') ] ( singleExpression | #ID# @ )
    -->     Type: move
    -->     LA: #ID# 
    --> __________________
    --> #332: argument => [ argument ('T_COMMA') ] [ ('T_ELLIPSIS') @ ] ( singleExpression | #ID# )
    -->     Type: pass
    -->     LA: 'T_ELLIPSIS' 
    --> __________________
    --> #47: singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #345: coalesceExpression => [ @ coalesceExpression 'T_COALESCE' ] additiveExpression
    --> __________________
    --> #348: additiveExpression => [ @ additiveExpression ( 'T_ADD' | 'T_SUB' ) ] multiplicativeExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #346: bitNotExpression => ( 'T_BIT_NOT' bitNotExpression | unaryMinusExpression @ )
    --> __________________
    --> #349: bitNotExpression => ( 'T_BIT_NOT' bitNotExpression @ | unaryMinusExpression )
    -->     Type: reduce
    -->     Reduce(exp): bitNotExpression => ( 'T_BIT_NOT' @ bitNotExpression | unaryMinusExpression )
    --> __________________
    --> #350: notExpression => ( 'T_LOG_NOT' notExpression | bitNotExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): notExpression => @ ( 'T_LOG_NOT' notExpression | bitNotExpression )

** [FINAL] State #347: unaryMinusExpression => ( 'T_SUB' unaryMinusExpression @ | unaryPlusExpression )
    --> __________________
    --> #346: bitNotExpression => ( 'T_BIT_NOT' bitNotExpression | unaryMinusExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): bitNotExpression => @ ( 'T_BIT_NOT' bitNotExpression | unaryMinusExpression )
    --> __________________
    --> #347: unaryMinusExpression => ( 'T_SUB' unaryMinusExpression @ | unaryPlusExpression )
    -->     Type: reduce
    -->     Reduce(exp): unaryMinusExpression => ( 'T_SUB' @ unaryMinusExpression | unaryPlusExpression )

** State #348: additiveExpression => [ @ additiveExpression ( 'T_ADD' | 'T_SUB' ) ] multiplicativeExpression
    --> __________________
    --> #351: multiplicativeExpression => [ @ multiplicativeExpression ( 'T_MUL' | 'T_DIV' | 'T_MOD' ) ] powerExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #349: bitNotExpression => ( 'T_BIT_NOT' bitNotExpression @ | unaryMinusExpression )
    --> __________________
    --> #349: bitNotExpression => ( 'T_BIT_NOT' bitNotExpression @ | unaryMinusExpression )
    -->     Type: reduce
    -->     Reduce(exp): bitNotExpression => ( 'T_BIT_NOT' @ bitNotExpression | unaryMinusExpression )
    --> __________________
    --> #350: notExpression => ( 'T_LOG_NOT' notExpression | bitNotExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): notExpression => @ ( 'T_LOG_NOT' notExpression | bitNotExpression )

** [FINAL] State #350: notExpression => ( 'T_LOG_NOT' notExpression | bitNotExpression @ )
    --> __________________
    --> #352: notExpression => ( 'T_LOG_NOT' notExpression @ | bitNotExpression )
    -->     Type: reduce
    -->     Reduce(exp): notExpression => ( 'T_LOG_NOT' @ notExpression | bitNotExpression )
    --> __________________
    --> #353: powerExpression => [ powerExpression 'T_POWER' ] notExpression @
    -->     Type: reduce
    -->     Reduce(exp): powerExpression => [ @ powerExpression 'T_POWER' ] notExpression
    --> __________________
    --> #353: powerExpression => [ powerExpression 'T_POWER' ] notExpression @
    -->     Type: reduce
    -->     Reduce(exp): powerExpression => [ powerExpression 'T_POWER' @ ] notExpression

** State #351: multiplicativeExpression => [ @ multiplicativeExpression ( 'T_MUL' | 'T_DIV' | 'T_MOD' ) ] powerExpression
    --> __________________
    --> #354: powerExpression => [ @ powerExpression 'T_POWER' ] notExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #352: notExpression => ( 'T_LOG_NOT' notExpression @ | bitNotExpression )
    --> __________________
    --> #352: notExpression => ( 'T_LOG_NOT' notExpression @ | bitNotExpression )
    -->     Type: reduce
    -->     Reduce(exp): notExpression => ( 'T_LOG_NOT' @ notExpression | bitNotExpression )
    --> __________________
    --> #353: powerExpression => [ powerExpression 'T_POWER' ] notExpression @
    -->     Type: reduce
    -->     Reduce(exp): powerExpression => [ @ powerExpression 'T_POWER' ] notExpression
    --> __________________
    --> #353: powerExpression => [ powerExpression 'T_POWER' ] notExpression @
    -->     Type: reduce
    -->     Reduce(exp): powerExpression => [ powerExpression 'T_POWER' @ ] notExpression

** [FINAL] State #353: powerExpression => [ powerExpression 'T_POWER' ] notExpression @
    --> __________________
    --> #355: multiplicativeExpression => [ multiplicativeExpression ( 'T_MUL' | 'T_DIV' | 'T_MOD' ) ] powerExpression @
    -->     Type: reduce
    -->     Reduce(exp): multiplicativeExpression => [ @ multiplicativeExpression ( 'T_MUL' | 'T_DIV' | 'T_MOD' ) ] powerExpression
    --> __________________
    --> #355: multiplicativeExpression => [ multiplicativeExpression ( 'T_MUL' | 'T_DIV' | 'T_MOD' ) ] powerExpression @
    -->     Type: reduce
    -->     Reduce(exp): multiplicativeExpression => [ multiplicativeExpression ( 'T_MUL' | 'T_DIV' | 'T_MOD' @ ) ] powerExpression
    --> __________________
    --> #355: multiplicativeExpression => [ multiplicativeExpression ( 'T_MUL' | 'T_DIV' | 'T_MOD' ) ] powerExpression @
    -->     Type: reduce
    -->     Reduce(exp): multiplicativeExpression => [ multiplicativeExpression ( 'T_MUL' @ | 'T_DIV' | 'T_MOD' ) ] powerExpression
    --> __________________
    --> #355: multiplicativeExpression => [ multiplicativeExpression ( 'T_MUL' | 'T_DIV' | 'T_MOD' ) ] powerExpression @
    -->     Type: reduce
    -->     Reduce(exp): multiplicativeExpression => [ multiplicativeExpression ( 'T_MUL' | 'T_DIV' @ | 'T_MOD' ) ] powerExpression
    --> __________________
    --> #356: powerExpression => [ powerExpression @ 'T_POWER' ] notExpression
    -->     Type: recursion
    -->     LA: 'T_POWER' 

** State #354: powerExpression => [ @ powerExpression 'T_POWER' ] notExpression
    --> __________________
    --> #357: notExpression => @ ( 'T_LOG_NOT' notExpression | bitNotExpression )
    -->     Type: shift
    -->     LA: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' 
    -->     LA: K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF 
    -->     LA: K_NEW K_VOID #NUMBER# 'T_LBRACE' K_DELETE 
    -->     LA: K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# 
    -->     LA: K_CLASS K_SUPER #STRING# K_FALSE 

** [FINAL] State #355: multiplicativeExpression => [ multiplicativeExpression ( 'T_MUL' | 'T_DIV' | 'T_MOD' ) ] powerExpression @
    --> __________________
    --> #358: additiveExpression => [ additiveExpression ( 'T_ADD' | 'T_SUB' ) ] multiplicativeExpression @
    -->     Type: reduce
    -->     Reduce(exp): additiveExpression => [ @ additiveExpression ( 'T_ADD' | 'T_SUB' ) ] multiplicativeExpression
    --> __________________
    --> #358: additiveExpression => [ additiveExpression ( 'T_ADD' | 'T_SUB' ) ] multiplicativeExpression @
    -->     Type: reduce
    -->     Reduce(exp): additiveExpression => [ additiveExpression ( 'T_ADD' | 'T_SUB' @ ) ] multiplicativeExpression
    --> __________________
    --> #358: additiveExpression => [ additiveExpression ( 'T_ADD' | 'T_SUB' ) ] multiplicativeExpression @
    -->     Type: reduce
    -->     Reduce(exp): additiveExpression => [ additiveExpression ( 'T_ADD' @ | 'T_SUB' ) ] multiplicativeExpression
    --> __________________
    --> #359: multiplicativeExpression => [ multiplicativeExpression @ ( 'T_MUL' | 'T_DIV' | 'T_MOD' ) ] powerExpression
    -->     Type: recursion
    -->     LA: 'T_DIV' 'T_MUL' 'T_MOD' 

** State #356: powerExpression => [ powerExpression @ 'T_POWER' ] notExpression
    --> __________________
    --> #360: powerExpression => [ powerExpression 'T_POWER' @ ] notExpression
    -->     Type: move
    -->     LA: 'T_POWER' 

** State #357: notExpression => @ ( 'T_LOG_NOT' notExpression | bitNotExpression )
    --> __________________
    --> #361: bitNotExpression => @ ( 'T_BIT_NOT' bitNotExpression | unaryMinusExpression )
    -->     Type: shift
    -->     LA: 'T_BIT_NOT' 'T_SUB' 'T_ADD' 'T_DEC' K_NULL 
    -->     LA: 'T_INC' K_FUNCTION K_THIS K_TYPEOF K_NEW 
    -->     LA: K_VOID #NUMBER# 'T_LBRACE' K_DELETE K_TRUE 
    -->     LA: 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# K_CLASS 
    -->     LA: K_SUPER #STRING# K_FALSE 
    --> __________________
    --> #362: notExpression => ( 'T_LOG_NOT' @ notExpression | bitNotExpression )
    -->     Type: move
    -->     LA: 'T_LOG_NOT' 

** [FINAL] State #358: additiveExpression => [ additiveExpression ( 'T_ADD' | 'T_SUB' ) ] multiplicativeExpression @
    --> __________________
    --> #363: additiveExpression => [ additiveExpression @ ( 'T_ADD' | 'T_SUB' ) ] multiplicativeExpression
    -->     Type: recursion
    -->     LA: 'T_ADD' 'T_SUB' 
    --> __________________
    --> #364: coalesceExpression => [ coalesceExpression 'T_COALESCE' ] additiveExpression @
    -->     Type: reduce
    -->     Reduce(exp): coalesceExpression => [ @ coalesceExpression 'T_COALESCE' ] additiveExpression
    --> __________________
    --> #364: coalesceExpression => [ coalesceExpression 'T_COALESCE' ] additiveExpression @
    -->     Type: reduce
    -->     Reduce(exp): coalesceExpression => [ coalesceExpression 'T_COALESCE' @ ] additiveExpression

** State #359: multiplicativeExpression => [ multiplicativeExpression @ ( 'T_MUL' | 'T_DIV' | 'T_MOD' ) ] powerExpression
    --> __________________
    --> #365: multiplicativeExpression => [ multiplicativeExpression ( 'T_MUL' | 'T_DIV' | 'T_MOD' @ ) ] powerExpression
    -->     Type: move
    -->     LA: 'T_MOD' 
    --> __________________
    --> #366: multiplicativeExpression => [ multiplicativeExpression ( 'T_MUL' @ | 'T_DIV' | 'T_MOD' ) ] powerExpression
    -->     Type: move
    -->     LA: 'T_MUL' 
    --> __________________
    --> #367: multiplicativeExpression => [ multiplicativeExpression ( 'T_MUL' | 'T_DIV' @ | 'T_MOD' ) ] powerExpression
    -->     Type: move
    -->     LA: 'T_DIV' 

** State #360: powerExpression => [ powerExpression 'T_POWER' @ ] notExpression
    --> __________________
    --> #357: notExpression => @ ( 'T_LOG_NOT' notExpression | bitNotExpression )
    -->     Type: shift
    -->     LA: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' 
    -->     LA: K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF 
    -->     LA: K_NEW K_VOID #NUMBER# 'T_LBRACE' K_DELETE 
    -->     LA: K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# 
    -->     LA: K_CLASS K_SUPER #STRING# K_FALSE 

** State #361: bitNotExpression => @ ( 'T_BIT_NOT' bitNotExpression | unaryMinusExpression )
    --> __________________
    --> #368: unaryMinusExpression => @ ( 'T_SUB' unaryMinusExpression | unaryPlusExpression )
    -->     Type: shift
    -->     LA: 'T_SUB' 'T_ADD' 'T_DEC' K_NULL 'T_INC' 
    -->     LA: K_FUNCTION K_TYPEOF K_VOID #NUMBER# 'T_LBRACE' 
    -->     LA: K_DELETE K_NEW K_THIS K_TRUE 'T_LPARAN' 
    -->     LA: #ID# #REGEX# K_SUPER #STRING# K_FALSE 
    -->     LA: 'T_LSQUARE' K_CLASS 
    --> __________________
    --> #369: bitNotExpression => ( 'T_BIT_NOT' @ bitNotExpression | unaryMinusExpression )
    -->     Type: move
    -->     LA: 'T_BIT_NOT' 

** State #362: notExpression => ( 'T_LOG_NOT' @ notExpression | bitNotExpression )
    --> __________________
    --> #357: notExpression => @ ( 'T_LOG_NOT' notExpression | bitNotExpression )
    -->     Type: shift
    -->     LA: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' 
    -->     LA: K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF 
    -->     LA: K_NEW K_VOID #NUMBER# 'T_LBRACE' K_DELETE 
    -->     LA: K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# 
    -->     LA: K_CLASS K_SUPER #STRING# K_FALSE 

** State #363: additiveExpression => [ additiveExpression @ ( 'T_ADD' | 'T_SUB' ) ] multiplicativeExpression
    --> __________________
    --> #370: additiveExpression => [ additiveExpression ( 'T_ADD' | 'T_SUB' @ ) ] multiplicativeExpression
    -->     Type: move
    -->     LA: 'T_SUB' 
    --> __________________
    --> #371: additiveExpression => [ additiveExpression ( 'T_ADD' @ | 'T_SUB' ) ] multiplicativeExpression
    -->     Type: move
    -->     LA: 'T_ADD' 

** [FINAL] State #364: coalesceExpression => [ coalesceExpression 'T_COALESCE' ] additiveExpression @
    --> __________________
    --> #372: bitShiftExpression => [ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression @
    -->     Type: reduce
    -->     Reduce(exp): bitShiftExpression => [ @ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression
    --> __________________
    --> #372: bitShiftExpression => [ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression @
    -->     Type: reduce
    -->     Reduce(exp): bitShiftExpression => [ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' @ ) ] coalesceExpression
    --> __________________
    --> #372: bitShiftExpression => [ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression @
    -->     Type: reduce
    -->     Reduce(exp): bitShiftExpression => [ bitShiftExpression ( 'T_LSHIFT' @ | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression
    --> __________________
    --> #372: bitShiftExpression => [ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression @
    -->     Type: reduce
    -->     Reduce(exp): bitShiftExpression => [ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' @ | 'T_URSHIFT' ) ] coalesceExpression
    --> __________________
    --> #373: coalesceExpression => [ coalesceExpression @ 'T_COALESCE' ] additiveExpression
    -->     Type: recursion
    -->     LA: 'T_COALESCE' 

** State #365: multiplicativeExpression => [ multiplicativeExpression ( 'T_MUL' | 'T_DIV' | 'T_MOD' @ ) ] powerExpression
    --> __________________
    --> #354: powerExpression => [ @ powerExpression 'T_POWER' ] notExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #366: multiplicativeExpression => [ multiplicativeExpression ( 'T_MUL' @ | 'T_DIV' | 'T_MOD' ) ] powerExpression
    --> __________________
    --> #354: powerExpression => [ @ powerExpression 'T_POWER' ] notExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #367: multiplicativeExpression => [ multiplicativeExpression ( 'T_MUL' | 'T_DIV' @ | 'T_MOD' ) ] powerExpression
    --> __________________
    --> #354: powerExpression => [ @ powerExpression 'T_POWER' ] notExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #368: unaryMinusExpression => @ ( 'T_SUB' unaryMinusExpression | unaryPlusExpression )
    --> __________________
    --> #374: unaryPlusExpression => @ ( 'T_ADD' unaryPlusExpression | preDecreaseExpression )
    -->     Type: shift
    -->     LA: 'T_ADD' 'T_DEC' K_NULL 'T_INC' K_FUNCTION 
    -->     LA: K_TYPEOF K_VOID #NUMBER# 'T_LBRACE' K_DELETE 
    -->     LA: K_NEW K_THIS K_TRUE 'T_LPARAN' #ID# 
    -->     LA: #REGEX# K_SUPER #STRING# K_FALSE 'T_LSQUARE' 
    -->     LA: K_CLASS 
    --> __________________
    --> #375: unaryMinusExpression => ( 'T_SUB' @ unaryMinusExpression | unaryPlusExpression )
    -->     Type: move
    -->     LA: 'T_SUB' 

** State #369: bitNotExpression => ( 'T_BIT_NOT' @ bitNotExpression | unaryMinusExpression )
    --> __________________
    --> #361: bitNotExpression => @ ( 'T_BIT_NOT' bitNotExpression | unaryMinusExpression )
    -->     Type: shift
    -->     LA: 'T_BIT_NOT' 'T_SUB' 'T_ADD' 'T_DEC' K_NULL 
    -->     LA: 'T_INC' K_FUNCTION K_THIS K_TYPEOF K_NEW 
    -->     LA: K_VOID #NUMBER# 'T_LBRACE' K_DELETE K_TRUE 
    -->     LA: 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# K_CLASS 
    -->     LA: K_SUPER #STRING# K_FALSE 

** State #370: additiveExpression => [ additiveExpression ( 'T_ADD' | 'T_SUB' @ ) ] multiplicativeExpression
    --> __________________
    --> #351: multiplicativeExpression => [ @ multiplicativeExpression ( 'T_MUL' | 'T_DIV' | 'T_MOD' ) ] powerExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #371: additiveExpression => [ additiveExpression ( 'T_ADD' @ | 'T_SUB' ) ] multiplicativeExpression
    --> __________________
    --> #351: multiplicativeExpression => [ @ multiplicativeExpression ( 'T_MUL' | 'T_DIV' | 'T_MOD' ) ] powerExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #372: bitShiftExpression => [ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression @
    --> __________________
    --> #376: bitShiftExpression => [ bitShiftExpression @ ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression
    -->     Type: recursion
    -->     LA: 'T_RSHIFT' 'T_LSHIFT' 'T_URSHIFT' 
    --> __________________
    --> #377: relationalExpression => [ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression @
    -->     Type: reduce
    -->     Reduce(exp): relationalExpression => [ @ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression
    --> __________________
    --> #377: relationalExpression => [ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression @
    -->     Type: reduce
    -->     Reduce(exp): relationalExpression => [ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' @ ) ] bitShiftExpression
    --> __________________
    --> #377: relationalExpression => [ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression @
    -->     Type: reduce
    -->     Reduce(exp): relationalExpression => [ relationalExpression ( 'T_LESS' @ | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression
    --> __________________
    --> #377: relationalExpression => [ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression @
    -->     Type: reduce
    -->     Reduce(exp): relationalExpression => [ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' @ | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression
    --> __________________
    --> #377: relationalExpression => [ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression @
    -->     Type: reduce
    -->     Reduce(exp): relationalExpression => [ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' @ | 'T_GREATER_EQUAL' ) ] bitShiftExpression

** State #373: coalesceExpression => [ coalesceExpression @ 'T_COALESCE' ] additiveExpression
    --> __________________
    --> #378: coalesceExpression => [ coalesceExpression 'T_COALESCE' @ ] additiveExpression
    -->     Type: move
    -->     LA: 'T_COALESCE' 

** State #374: unaryPlusExpression => @ ( 'T_ADD' unaryPlusExpression | preDecreaseExpression )
    --> __________________
    --> #379: preDecreaseExpression => @ ( 'T_DEC' preDecreaseExpression | preIncrementExpression )
    -->     Type: shift
    -->     LA: 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_TYPEOF 
    -->     LA: K_VOID #NUMBER# 'T_LBRACE' K_DELETE K_NEW 
    -->     LA: K_THIS K_TRUE 'T_LPARAN' #ID# #REGEX# 
    -->     LA: K_SUPER #STRING# K_FALSE 'T_LSQUARE' K_CLASS 
    --> __________________
    --> #380: unaryPlusExpression => ( 'T_ADD' @ unaryPlusExpression | preDecreaseExpression )
    -->     Type: move
    -->     LA: 'T_ADD' 

** State #375: unaryMinusExpression => ( 'T_SUB' @ unaryMinusExpression | unaryPlusExpression )
    --> __________________
    --> #368: unaryMinusExpression => @ ( 'T_SUB' unaryMinusExpression | unaryPlusExpression )
    -->     Type: shift
    -->     LA: 'T_SUB' 'T_ADD' 'T_DEC' K_NULL 'T_INC' 
    -->     LA: K_FUNCTION K_TYPEOF K_VOID #NUMBER# 'T_LBRACE' 
    -->     LA: K_DELETE K_NEW K_THIS K_TRUE 'T_LPARAN' 
    -->     LA: #ID# #REGEX# K_SUPER #STRING# K_FALSE 
    -->     LA: 'T_LSQUARE' K_CLASS 

** State #376: bitShiftExpression => [ bitShiftExpression @ ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression
    --> __________________
    --> #381: bitShiftExpression => [ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' @ ) ] coalesceExpression
    -->     Type: move
    -->     LA: 'T_URSHIFT' 
    --> __________________
    --> #382: bitShiftExpression => [ bitShiftExpression ( 'T_LSHIFT' @ | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression
    -->     Type: move
    -->     LA: 'T_LSHIFT' 
    --> __________________
    --> #383: bitShiftExpression => [ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' @ | 'T_URSHIFT' ) ] coalesceExpression
    -->     Type: move
    -->     LA: 'T_RSHIFT' 

** [FINAL] State #377: relationalExpression => [ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression @
    --> __________________
    --> #384: instanceofExpression => [ instanceofExpression K_INSTANCEOF ] relationalExpression @
    -->     Type: reduce
    -->     Reduce(exp): instanceofExpression => [ @ instanceofExpression K_INSTANCEOF ] relationalExpression
    --> __________________
    --> #384: instanceofExpression => [ instanceofExpression K_INSTANCEOF ] relationalExpression @
    -->     Type: reduce
    -->     Reduce(exp): instanceofExpression => [ instanceofExpression K_INSTANCEOF @ ] relationalExpression
    --> __________________
    --> #385: relationalExpression => [ relationalExpression @ ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression
    -->     Type: recursion
    -->     LA: 'T_GREATER' 'T_LESS_EQUAL' 'T_LESS' 'T_GREATER_EQUAL' 

** State #378: coalesceExpression => [ coalesceExpression 'T_COALESCE' @ ] additiveExpression
    --> __________________
    --> #348: additiveExpression => [ @ additiveExpression ( 'T_ADD' | 'T_SUB' ) ] multiplicativeExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #379: preDecreaseExpression => @ ( 'T_DEC' preDecreaseExpression | preIncrementExpression )
    --> __________________
    --> #386: preIncrementExpression => @ ( 'T_INC' preIncrementExpression | typeofExpression )
    -->     Type: shift
    -->     LA: 'T_INC' K_FUNCTION K_TYPEOF K_VOID #NUMBER# 
    -->     LA: 'T_LBRACE' K_DELETE K_NEW K_THIS K_TRUE 
    -->     LA: 'T_LPARAN' #ID# #REGEX# K_SUPER #STRING# 
    -->     LA: K_FALSE K_NULL 'T_LSQUARE' K_CLASS 
    --> __________________
    --> #387: preDecreaseExpression => ( 'T_DEC' @ preDecreaseExpression | preIncrementExpression )
    -->     Type: move
    -->     LA: 'T_DEC' 

** State #380: unaryPlusExpression => ( 'T_ADD' @ unaryPlusExpression | preDecreaseExpression )
    --> __________________
    --> #374: unaryPlusExpression => @ ( 'T_ADD' unaryPlusExpression | preDecreaseExpression )
    -->     Type: shift
    -->     LA: 'T_ADD' 'T_DEC' K_NULL 'T_INC' K_FUNCTION 
    -->     LA: K_TYPEOF K_VOID #NUMBER# 'T_LBRACE' K_DELETE 
    -->     LA: K_NEW K_THIS K_TRUE 'T_LPARAN' #ID# 
    -->     LA: #REGEX# K_SUPER #STRING# K_FALSE 'T_LSQUARE' 
    -->     LA: K_CLASS 

** State #381: bitShiftExpression => [ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' @ ) ] coalesceExpression
    --> __________________
    --> #345: coalesceExpression => [ @ coalesceExpression 'T_COALESCE' ] additiveExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #382: bitShiftExpression => [ bitShiftExpression ( 'T_LSHIFT' @ | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression
    --> __________________
    --> #345: coalesceExpression => [ @ coalesceExpression 'T_COALESCE' ] additiveExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #383: bitShiftExpression => [ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' @ | 'T_URSHIFT' ) ] coalesceExpression
    --> __________________
    --> #345: coalesceExpression => [ @ coalesceExpression 'T_COALESCE' ] additiveExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #384: instanceofExpression => [ instanceofExpression K_INSTANCEOF ] relationalExpression @
    --> __________________
    --> #388: inExpression => [ inExpression K_IN ] instanceofExpression @
    -->     Type: reduce
    -->     Reduce(exp): inExpression => [ @ inExpression K_IN ] instanceofExpression
    --> __________________
    --> #388: inExpression => [ inExpression K_IN ] instanceofExpression @
    -->     Type: reduce
    -->     Reduce(exp): inExpression => [ inExpression K_IN @ ] instanceofExpression
    --> __________________
    --> #389: instanceofExpression => [ instanceofExpression @ K_INSTANCEOF ] relationalExpression
    -->     Type: recursion
    -->     LA: K_INSTANCEOF 

** State #385: relationalExpression => [ relationalExpression @ ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression
    --> __________________
    --> #390: relationalExpression => [ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' @ ) ] bitShiftExpression
    -->     Type: move
    -->     LA: 'T_GREATER_EQUAL' 
    --> __________________
    --> #391: relationalExpression => [ relationalExpression ( 'T_LESS' @ | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression
    -->     Type: move
    -->     LA: 'T_LESS' 
    --> __________________
    --> #392: relationalExpression => [ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' @ | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression
    -->     Type: move
    -->     LA: 'T_LESS_EQUAL' 
    --> __________________
    --> #393: relationalExpression => [ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' @ | 'T_GREATER_EQUAL' ) ] bitShiftExpression
    -->     Type: move
    -->     LA: 'T_GREATER' 

** State #386: preIncrementExpression => @ ( 'T_INC' preIncrementExpression | typeofExpression )
    --> __________________
    --> #394: typeofExpression => @ ( K_TYPEOF typeofExpression | voidExpression )
    -->     Type: shift
    -->     LA: K_TYPEOF K_VOID K_DELETE K_NEW K_TRUE 
    -->     LA: #REGEX# K_SUPER #NUMBER# 'T_LBRACE' #STRING# 
    -->     LA: 'T_LPARAN' #ID# K_FALSE K_NULL 'T_LSQUARE' 
    -->     LA: K_FUNCTION K_CLASS K_THIS 
    --> __________________
    --> #395: preIncrementExpression => ( 'T_INC' @ preIncrementExpression | typeofExpression )
    -->     Type: move
    -->     LA: 'T_INC' 

** State #387: preDecreaseExpression => ( 'T_DEC' @ preDecreaseExpression | preIncrementExpression )
    --> __________________
    --> #379: preDecreaseExpression => @ ( 'T_DEC' preDecreaseExpression | preIncrementExpression )
    -->     Type: shift
    -->     LA: 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_TYPEOF 
    -->     LA: K_VOID #NUMBER# 'T_LBRACE' K_DELETE K_NEW 
    -->     LA: K_THIS K_TRUE 'T_LPARAN' #ID# #REGEX# 
    -->     LA: K_SUPER #STRING# K_FALSE 'T_LSQUARE' K_CLASS 

** [FINAL] State #388: inExpression => [ inExpression K_IN ] instanceofExpression @
    --> __________________
    --> #396: equalityExpression => [ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression @
    -->     Type: reduce
    -->     Reduce(exp): equalityExpression => [ @ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression
    --> __________________
    --> #396: equalityExpression => [ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression @
    -->     Type: reduce
    -->     Reduce(exp): equalityExpression => [ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' @ ) ] inExpression
    --> __________________
    --> #396: equalityExpression => [ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression @
    -->     Type: reduce
    -->     Reduce(exp): equalityExpression => [ equalityExpression ( 'T_EQUAL' @ | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression
    --> __________________
    --> #396: equalityExpression => [ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression @
    -->     Type: reduce
    -->     Reduce(exp): equalityExpression => [ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' @ | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression
    --> __________________
    --> #396: equalityExpression => [ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression @
    -->     Type: reduce
    -->     Reduce(exp): equalityExpression => [ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' @ | 'T_FNOT_EQUAL' ) ] inExpression
    --> __________________
    --> #397: inExpression => [ inExpression @ K_IN ] instanceofExpression
    -->     Type: recursion
    -->     LA: K_IN 

** State #389: instanceofExpression => [ instanceofExpression @ K_INSTANCEOF ] relationalExpression
    --> __________________
    --> #398: instanceofExpression => [ instanceofExpression K_INSTANCEOF @ ] relationalExpression
    -->     Type: move
    -->     LA: K_INSTANCEOF 

** State #390: relationalExpression => [ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' @ ) ] bitShiftExpression
    --> __________________
    --> #341: bitShiftExpression => [ @ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #391: relationalExpression => [ relationalExpression ( 'T_LESS' @ | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression
    --> __________________
    --> #341: bitShiftExpression => [ @ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #392: relationalExpression => [ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' @ | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression
    --> __________________
    --> #341: bitShiftExpression => [ @ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #393: relationalExpression => [ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' @ | 'T_GREATER_EQUAL' ) ] bitShiftExpression
    --> __________________
    --> #341: bitShiftExpression => [ @ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #394: typeofExpression => @ ( K_TYPEOF typeofExpression | voidExpression )
    --> __________________
    --> #399: voidExpression => @ ( K_VOID voidExpression | deleteExpression )
    -->     Type: shift
    -->     LA: K_VOID K_DELETE K_NEW K_TRUE #REGEX# 
    -->     LA: K_SUPER #NUMBER# 'T_LBRACE' #STRING# 'T_LPARAN' 
    -->     LA: #ID# K_FALSE K_NULL 'T_LSQUARE' K_FUNCTION 
    -->     LA: K_CLASS K_THIS 
    --> __________________
    --> #400: typeofExpression => ( K_TYPEOF @ typeofExpression | voidExpression )
    -->     Type: move
    -->     LA: K_TYPEOF 

** State #395: preIncrementExpression => ( 'T_INC' @ preIncrementExpression | typeofExpression )
    --> __________________
    --> #386: preIncrementExpression => @ ( 'T_INC' preIncrementExpression | typeofExpression )
    -->     Type: shift
    -->     LA: 'T_INC' K_FUNCTION K_TYPEOF K_VOID #NUMBER# 
    -->     LA: 'T_LBRACE' K_DELETE K_NEW K_THIS K_TRUE 
    -->     LA: 'T_LPARAN' #ID# #REGEX# K_SUPER #STRING# 
    -->     LA: K_FALSE K_NULL 'T_LSQUARE' K_CLASS 

** [FINAL] State #396: equalityExpression => [ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression @
    --> __________________
    --> #401: bitAndExpression => [ bitAndExpression 'T_BIT_AND' ] equalityExpression @
    -->     Type: reduce
    -->     Reduce(exp): bitAndExpression => [ @ bitAndExpression 'T_BIT_AND' ] equalityExpression
    --> __________________
    --> #401: bitAndExpression => [ bitAndExpression 'T_BIT_AND' ] equalityExpression @
    -->     Type: reduce
    -->     Reduce(exp): bitAndExpression => [ bitAndExpression 'T_BIT_AND' @ ] equalityExpression
    --> __________________
    --> #402: equalityExpression => [ equalityExpression @ ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression
    -->     Type: recursion
    -->     LA: 'T_FEQUAL' 'T_NOT_EQUAL' 'T_EQUAL' 'T_FNOT_EQUAL' 

** State #397: inExpression => [ inExpression @ K_IN ] instanceofExpression
    --> __________________
    --> #403: inExpression => [ inExpression K_IN @ ] instanceofExpression
    -->     Type: move
    -->     LA: K_IN 

** State #398: instanceofExpression => [ instanceofExpression K_INSTANCEOF @ ] relationalExpression
    --> __________________
    --> #334: relationalExpression => [ @ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #399: voidExpression => @ ( K_VOID voidExpression | deleteExpression )
    --> __________________
    --> #404: deleteExpression => @ ( K_DELETE deleteExpression | newExpression )
    -->     Type: shift
    -->     LA: K_DELETE K_NEW #REGEX# K_SUPER #NUMBER# 
    -->     LA: 'T_LBRACE' K_TRUE 'T_LPARAN' #ID# K_FALSE 
    -->     LA: K_NULL #STRING# 'T_LSQUARE' K_FUNCTION K_CLASS 
    -->     LA: K_THIS 
    --> __________________
    --> #405: voidExpression => ( K_VOID @ voidExpression | deleteExpression )
    -->     Type: move
    -->     LA: K_VOID 

** State #400: typeofExpression => ( K_TYPEOF @ typeofExpression | voidExpression )
    --> __________________
    --> #394: typeofExpression => @ ( K_TYPEOF typeofExpression | voidExpression )
    -->     Type: shift
    -->     LA: K_TYPEOF K_VOID K_DELETE K_NEW K_TRUE 
    -->     LA: #REGEX# K_SUPER #NUMBER# 'T_LBRACE' #STRING# 
    -->     LA: 'T_LPARAN' #ID# K_FALSE K_NULL 'T_LSQUARE' 
    -->     LA: K_FUNCTION K_CLASS K_THIS 

** [FINAL] State #401: bitAndExpression => [ bitAndExpression 'T_BIT_AND' ] equalityExpression @
    --> __________________
    --> #406: bitAndExpression => [ bitAndExpression @ 'T_BIT_AND' ] equalityExpression
    -->     Type: recursion
    -->     LA: 'T_BIT_AND' 
    --> __________________
    --> #407: bitXOrExpression => [ bitXOrExpression 'T_BIT_XOR' ] bitAndExpression @
    -->     Type: reduce
    -->     Reduce(exp): bitXOrExpression => [ @ bitXOrExpression 'T_BIT_XOR' ] bitAndExpression
    --> __________________
    --> #407: bitXOrExpression => [ bitXOrExpression 'T_BIT_XOR' ] bitAndExpression @
    -->     Type: reduce
    -->     Reduce(exp): bitXOrExpression => [ bitXOrExpression 'T_BIT_XOR' @ ] bitAndExpression

** State #402: equalityExpression => [ equalityExpression @ ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression
    --> __________________
    --> #408: equalityExpression => [ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' @ ) ] inExpression
    -->     Type: move
    -->     LA: 'T_FNOT_EQUAL' 
    --> __________________
    --> #409: equalityExpression => [ equalityExpression ( 'T_EQUAL' @ | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression
    -->     Type: move
    -->     LA: 'T_EQUAL' 
    --> __________________
    --> #410: equalityExpression => [ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' @ | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression
    -->     Type: move
    -->     LA: 'T_NOT_EQUAL' 
    --> __________________
    --> #411: equalityExpression => [ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' @ | 'T_FNOT_EQUAL' ) ] inExpression
    -->     Type: move
    -->     LA: 'T_FEQUAL' 

** State #403: inExpression => [ inExpression K_IN @ ] instanceofExpression
    --> __________________
    --> #327: instanceofExpression => [ @ instanceofExpression K_INSTANCEOF ] relationalExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #404: deleteExpression => @ ( K_DELETE deleteExpression | newExpression )
    --> __________________
    --> #412: newExpression => @ ( K_NEW singleExpression [ arguments ] | postfixExpression )
    -->     Type: shift
    -->     LA: K_NEW #REGEX# K_SUPER #NUMBER# 'T_LBRACE' 
    -->     LA: K_TRUE 'T_LPARAN' #ID# K_FALSE K_NULL 
    -->     LA: #STRING# 'T_LSQUARE' K_FUNCTION K_CLASS K_THIS 
    --> __________________
    --> #413: deleteExpression => ( K_DELETE @ deleteExpression | newExpression )
    -->     Type: move
    -->     LA: K_DELETE 

** State #405: voidExpression => ( K_VOID @ voidExpression | deleteExpression )
    --> __________________
    --> #399: voidExpression => @ ( K_VOID voidExpression | deleteExpression )
    -->     Type: shift
    -->     LA: K_VOID K_DELETE K_NEW K_TRUE #REGEX# 
    -->     LA: K_SUPER #NUMBER# 'T_LBRACE' #STRING# 'T_LPARAN' 
    -->     LA: #ID# K_FALSE K_NULL 'T_LSQUARE' K_FUNCTION 
    -->     LA: K_CLASS K_THIS 

** State #406: bitAndExpression => [ bitAndExpression @ 'T_BIT_AND' ] equalityExpression
    --> __________________
    --> #414: bitAndExpression => [ bitAndExpression 'T_BIT_AND' @ ] equalityExpression
    -->     Type: move
    -->     LA: 'T_BIT_AND' 

** [FINAL] State #407: bitXOrExpression => [ bitXOrExpression 'T_BIT_XOR' ] bitAndExpression @
    --> __________________
    --> #415: bitOrExpression => [ bitOrExpression 'T_BIT_OR' ] bitXOrExpression @
    -->     Type: reduce
    -->     Reduce(exp): bitOrExpression => [ @ bitOrExpression 'T_BIT_OR' ] bitXOrExpression
    --> __________________
    --> #415: bitOrExpression => [ bitOrExpression 'T_BIT_OR' ] bitXOrExpression @
    -->     Type: reduce
    -->     Reduce(exp): bitOrExpression => [ bitOrExpression 'T_BIT_OR' @ ] bitXOrExpression
    --> __________________
    --> #416: bitXOrExpression => [ bitXOrExpression @ 'T_BIT_XOR' ] bitAndExpression
    -->     Type: recursion
    -->     LA: 'T_BIT_XOR' 

** State #408: equalityExpression => [ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' @ ) ] inExpression
    --> __________________
    --> #322: inExpression => [ @ inExpression K_IN ] instanceofExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #409: equalityExpression => [ equalityExpression ( 'T_EQUAL' @ | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression
    --> __________________
    --> #322: inExpression => [ @ inExpression K_IN ] instanceofExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #410: equalityExpression => [ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' @ | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression
    --> __________________
    --> #322: inExpression => [ @ inExpression K_IN ] instanceofExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #411: equalityExpression => [ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' @ | 'T_FNOT_EQUAL' ) ] inExpression
    --> __________________
    --> #322: inExpression => [ @ inExpression K_IN ] instanceofExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #412: newExpression => @ ( K_NEW singleExpression [ arguments ] | postfixExpression )
    --> __________________
    --> #417: postfixExpression => @ ( postfixExpression ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )
    -->     Type: shift
    -->     LA: K_THIS #ID# K_CLASS K_FUNCTION 'T_LSQUARE' 
    -->     LA: #STRING# K_NULL K_FALSE #REGEX# 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_SUPER 
    --> __________________
    --> #418: newExpression => ( K_NEW @ singleExpression [ arguments ] | postfixExpression )
    -->     Type: move
    -->     LA: K_NEW 

** State #413: deleteExpression => ( K_DELETE @ deleteExpression | newExpression )
    --> __________________
    --> #404: deleteExpression => @ ( K_DELETE deleteExpression | newExpression )
    -->     Type: shift
    -->     LA: K_DELETE K_NEW #REGEX# K_SUPER #NUMBER# 
    -->     LA: 'T_LBRACE' K_TRUE 'T_LPARAN' #ID# K_FALSE 
    -->     LA: K_NULL #STRING# 'T_LSQUARE' K_FUNCTION K_CLASS 
    -->     LA: K_THIS 

** State #414: bitAndExpression => [ bitAndExpression 'T_BIT_AND' @ ] equalityExpression
    --> __________________
    --> #311: equalityExpression => [ @ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #415: bitOrExpression => [ bitOrExpression 'T_BIT_OR' ] bitXOrExpression @
    --> __________________
    --> #419: bitOrExpression => [ bitOrExpression @ 'T_BIT_OR' ] bitXOrExpression
    -->     Type: recursion
    -->     LA: 'T_BIT_OR' 
    --> __________________
    --> #420: logicalAndExpression => [ logicalAndExpression 'T_LOG_AND' ] bitOrExpression @
    -->     Type: reduce
    -->     Reduce(exp): logicalAndExpression => [ @ logicalAndExpression 'T_LOG_AND' ] bitOrExpression
    --> __________________
    --> #420: logicalAndExpression => [ logicalAndExpression 'T_LOG_AND' ] bitOrExpression @
    -->     Type: reduce
    -->     Reduce(exp): logicalAndExpression => [ logicalAndExpression 'T_LOG_AND' @ ] bitOrExpression

** State #416: bitXOrExpression => [ bitXOrExpression @ 'T_BIT_XOR' ] bitAndExpression
    --> __________________
    --> #421: bitXOrExpression => [ bitXOrExpression 'T_BIT_XOR' @ ] bitAndExpression
    -->     Type: move
    -->     LA: 'T_BIT_XOR' 

** State #417: postfixExpression => @ ( postfixExpression ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )
    --> __________________
    --> #422: functionExpression => @ ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
    -->     Type: shift
    -->     LA: K_SUPER #NUMBER# 'T_LBRACE' K_TRUE 'T_LPARAN' 
    -->     LA: #ID# #REGEX# K_FALSE K_NULL #STRING# 
    -->     LA: 'T_LSQUARE' K_FUNCTION K_CLASS K_THIS 

** State #418: newExpression => ( K_NEW @ singleExpression [ arguments ] | postfixExpression )
    --> __________________
    --> #47: singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #419: bitOrExpression => [ bitOrExpression @ 'T_BIT_OR' ] bitXOrExpression
    --> __________________
    --> #423: bitOrExpression => [ bitOrExpression 'T_BIT_OR' @ ] bitXOrExpression
    -->     Type: move
    -->     LA: 'T_BIT_OR' 

** [FINAL] State #420: logicalAndExpression => [ logicalAndExpression 'T_LOG_AND' ] bitOrExpression @
    --> __________________
    --> #424: logicalAndExpression => [ logicalAndExpression @ 'T_LOG_AND' ] bitOrExpression
    -->     Type: recursion
    -->     LA: 'T_LOG_AND' 
    --> __________________
    --> #425: logicalOrExpression => [ logicalOrExpression 'T_LOG_OR' ] logicalAndExpression @
    -->     Type: reduce
    -->     Reduce(exp): logicalOrExpression => [ @ logicalOrExpression 'T_LOG_OR' ] logicalAndExpression
    --> __________________
    --> #425: logicalOrExpression => [ logicalOrExpression 'T_LOG_OR' ] logicalAndExpression @
    -->     Type: reduce
    -->     Reduce(exp): logicalOrExpression => [ logicalOrExpression 'T_LOG_OR' @ ] logicalAndExpression

** State #421: bitXOrExpression => [ bitXOrExpression 'T_BIT_XOR' @ ] bitAndExpression
    --> __________________
    --> #269: bitAndExpression => [ @ bitAndExpression 'T_BIT_AND' ] equalityExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #422: functionExpression => @ ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
    --> __________________
    --> #426: parenthesizedExpression => @ ('T_LPARAN') expressionSequence ('T_RPARAN')
    -->     Type: shift
    -->     LA: 'T_LPARAN' 
    --> __________________
    --> #430: identifierExpression => @ #ID#
    -->     Type: shift
    -->     LA: #ID# 
    --> __________________
    --> #428: classExpression => @ K_CLASS (#ID#) classTail
    -->     Type: shift
    -->     LA: K_CLASS 
    --> __________________
    --> #429: thisExpression => @ K_THIS
    -->     Type: shift
    -->     LA: K_THIS 
    --> __________________
    --> #427: anonymousFunction => @ ( functionDecl | anoymousFunctionDecl | arrowFunction )
    -->     Type: shift
    -->     LA: 'T_LPARAN' #ID# K_FUNCTION 
    --> __________________
    --> #431: superExpression => @ K_SUPER
    -->     Type: shift
    -->     LA: K_SUPER 
    --> __________________
    --> #432: literalExpression => @ literal
    -->     Type: shift
    -->     LA: #STRING# K_FALSE #REGEX# K_TRUE K_NULL 
    -->     LA: #NUMBER# 
    --> __________________
    --> #433: arrayLiteralExpression => @ arrayLiteral
    -->     Type: shift
    -->     LA: 'T_LSQUARE' 
    --> __________________
    --> #434: objectLiteralExpression => @ objectLiteral
    -->     Type: shift
    -->     LA: 'T_LBRACE' 

** State #423: bitOrExpression => [ bitOrExpression 'T_BIT_OR' @ ] bitXOrExpression
    --> __________________
    --> #250: bitXOrExpression => [ @ bitXOrExpression 'T_BIT_XOR' ] bitAndExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #424: logicalAndExpression => [ logicalAndExpression @ 'T_LOG_AND' ] bitOrExpression
    --> __________________
    --> #435: logicalAndExpression => [ logicalAndExpression 'T_LOG_AND' @ ] bitOrExpression
    -->     Type: move
    -->     LA: 'T_LOG_AND' 

** [FINAL] State #425: logicalOrExpression => [ logicalOrExpression 'T_LOG_OR' ] logicalAndExpression @
    --> __________________
    --> #436: logicalOrExpression => [ logicalOrExpression @ 'T_LOG_OR' ] logicalAndExpression
    -->     Type: recursion
    -->     LA: 'T_LOG_OR' 
    --> __________________
    --> #437: ternaryExpression => logicalOrExpression @ [ 'T_QUERY' singleExpression 'T_COLON' singleExpression ]
    -->     Type: reduce
    -->     Reduce(exp): ternaryExpression => @ logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' singleExpression ]

** State #426: parenthesizedExpression => @ ('T_LPARAN') expressionSequence ('T_RPARAN')
    --> __________________
    --> #438: parenthesizedExpression => ('T_LPARAN') @ expressionSequence ('T_RPARAN')
    -->     Type: pass
    -->     LA: 'T_LPARAN' 

** State #427: anonymousFunction => @ ( functionDecl | anoymousFunctionDecl | arrowFunction )
    --> __________________
    --> #439: arrowFunction => @ arrowFunctionParameters ('T_ARROW') arrowFunctionBody
    -->     Type: shift
    -->     LA: #ID# 'T_LPARAN' 
    --> __________________
    --> #440: functionDecl => @ functionDeclaration
    -->     Type: shift
    -->     LA: K_FUNCTION 
    --> __________________
    --> #441: anoymousFunctionDecl => @ K_FUNCTION ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: shift
    -->     LA: K_FUNCTION 

** State #428: classExpression => @ K_CLASS (#ID#) classTail
    --> __________________
    --> #442: classExpression => K_CLASS @ (#ID#) classTail
    -->     Type: move
    -->     LA: K_CLASS 

** State #429: thisExpression => @ K_THIS
    --> __________________
    --> #443: thisExpression => K_THIS @
    -->     Type: move
    -->     LA: K_THIS 

** State #430: identifierExpression => @ #ID#
    --> __________________
    --> #444: identifierExpression => #ID# @
    -->     Type: move
    -->     LA: #ID# 

** State #431: superExpression => @ K_SUPER
    --> __________________
    --> #445: superExpression => K_SUPER @
    -->     Type: move
    -->     LA: K_SUPER 

** State #432: literalExpression => @ literal
    --> __________________
    --> #446: literal => @ ( K_NULL | K_TRUE | K_FALSE | #STRING# | #REGEX# | #NUMBER# )
    -->     Type: shift
    -->     LA: #STRING# K_FALSE #REGEX# K_TRUE K_NULL 
    -->     LA: #NUMBER# 

** State #433: arrayLiteralExpression => @ arrayLiteral
    --> __________________
    --> #133: arrayLiteral => @ ('T_LSQUARE') [ elementList ] ('T_RSQUARE')
    -->     Type: shift
    -->     LA: 'T_LSQUARE' 

** State #434: objectLiteralExpression => @ objectLiteral
    --> __________________
    --> #131: objectLiteral => @ ('T_LBRACE') [ propertyAssignments ] [ ('T_COMMA') ] ('T_RBRACE')
    -->     Type: shift
    -->     LA: 'T_LBRACE' 

** State #435: logicalAndExpression => [ logicalAndExpression 'T_LOG_AND' @ ] bitOrExpression
    --> __________________
    --> #230: bitOrExpression => [ @ bitOrExpression 'T_BIT_OR' ] bitXOrExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #436: logicalOrExpression => [ logicalOrExpression @ 'T_LOG_OR' ] logicalAndExpression
    --> __________________
    --> #447: logicalOrExpression => [ logicalOrExpression 'T_LOG_OR' @ ] logicalAndExpression
    -->     Type: move
    -->     LA: 'T_LOG_OR' 

** [FINAL] State #437: ternaryExpression => logicalOrExpression @ [ 'T_QUERY' singleExpression 'T_COLON' singleExpression ]
    --> __________________
    --> #448: ternaryExpression => logicalOrExpression [ 'T_QUERY' @ singleExpression 'T_COLON' singleExpression ]
    -->     Type: move
    -->     LA: 'T_QUERY' 
    --> __________________
    --> #449: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ @ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #449: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' @ ) ] ternaryExpression
    --> __________________
    --> #449: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' @ | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #449: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' @ | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #449: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' @ | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #449: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' @ | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #449: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' @ | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #449: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' @ | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #449: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' @ | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #449: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' @ | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #449: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' @ | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #449: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' @ | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #449: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' @ | 'T_ASSIGN_POWER' ) ] ternaryExpression

** State #438: parenthesizedExpression => ('T_LPARAN') @ expressionSequence ('T_RPARAN')
    --> __________________
    --> #25: expressionSequence => [ @ expressionSequence ('T_COMMA') ] singleExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #439: arrowFunction => @ arrowFunctionParameters ('T_ARROW') arrowFunctionBody
    --> __________________
    --> #450: arrowFunctionParameters => @ ( #ID# | ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') )
    -->     Type: shift
    -->     LA: #ID# 'T_LPARAN' 

** State #440: functionDecl => @ functionDeclaration
    --> __________________
    --> #3: functionDeclaration => @ K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: shift
    -->     LA: K_FUNCTION 

** State #441: anoymousFunctionDecl => @ K_FUNCTION ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #451: anoymousFunctionDecl => K_FUNCTION @ ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: move
    -->     LA: K_FUNCTION 

** State #442: classExpression => K_CLASS @ (#ID#) classTail
    --> __________________
    --> #452: classExpression => K_CLASS (#ID#) @ classTail
    -->     Type: pass
    -->     LA: #ID# 

** [FINAL] State #443: thisExpression => K_THIS @
    --> __________________
    --> #453: functionExpression => ( anonymousFunction | classExpression | thisExpression @ | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
    -->     Type: reduce
    -->     Reduce(exp): functionExpression => @ ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )

** [FINAL] State #444: identifierExpression => #ID# @
    --> __________________
    --> #454: functionExpression => ( anonymousFunction | classExpression | thisExpression | identifierExpression @ | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
    -->     Type: reduce
    -->     Reduce(exp): functionExpression => @ ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )

** [FINAL] State #445: superExpression => K_SUPER @
    --> __________________
    --> #455: functionExpression => ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression @ | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
    -->     Type: reduce
    -->     Reduce(exp): functionExpression => @ ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )

** State #446: literal => @ ( K_NULL | K_TRUE | K_FALSE | #STRING# | #REGEX# | #NUMBER# )
    --> __________________
    --> #456: literal => ( K_NULL | K_TRUE | K_FALSE | #STRING# | #REGEX# | #NUMBER# @ )
    -->     Type: move
    -->     LA: #NUMBER# 
    --> __________________
    --> #457: literal => ( K_NULL @ | K_TRUE | K_FALSE | #STRING# | #REGEX# | #NUMBER# )
    -->     Type: move
    -->     LA: K_NULL 
    --> __________________
    --> #458: literal => ( K_NULL | K_TRUE @ | K_FALSE | #STRING# | #REGEX# | #NUMBER# )
    -->     Type: move
    -->     LA: K_TRUE 
    --> __________________
    --> #459: literal => ( K_NULL | K_TRUE | K_FALSE @ | #STRING# | #REGEX# | #NUMBER# )
    -->     Type: move
    -->     LA: K_FALSE 
    --> __________________
    --> #460: literal => ( K_NULL | K_TRUE | K_FALSE | #STRING# @ | #REGEX# | #NUMBER# )
    -->     Type: move
    -->     LA: #STRING# 
    --> __________________
    --> #461: literal => ( K_NULL | K_TRUE | K_FALSE | #STRING# | #REGEX# @ | #NUMBER# )
    -->     Type: move
    -->     LA: #REGEX# 

** State #447: logicalOrExpression => [ logicalOrExpression 'T_LOG_OR' @ ] logicalAndExpression
    --> __________________
    --> #203: logicalAndExpression => [ @ logicalAndExpression 'T_LOG_AND' ] bitOrExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #448: ternaryExpression => logicalOrExpression [ 'T_QUERY' @ singleExpression 'T_COLON' singleExpression ]
    --> __________________
    --> #47: singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #449: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    --> __________________
    --> #462: assignmentExpression => [ assignmentExpression 'T_ASSIGN' ] assignmentOperatorExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentExpression => [ @ assignmentExpression 'T_ASSIGN' ] assignmentOperatorExpression
    --> __________________
    --> #462: assignmentExpression => [ assignmentExpression 'T_ASSIGN' ] assignmentOperatorExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentExpression => [ assignmentExpression 'T_ASSIGN' @ ] assignmentOperatorExpression
    --> __________________
    --> #463: assignmentOperatorExpression => [ assignmentOperatorExpression @ ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    -->     Type: recursion
    -->     LA: 'T_ASSIGN_XOR' 'T_ASSIGN_OR' 'T_ASSIGN_MUL' 'T_ASSIGN_ADD' 'T_ASSIGN_POWER' 
    -->     LA: 'T_ASSIGN_SUB' 'T_ASSIGN_DIV' 'T_ASSIGN_MOD' 'T_ASSIGN_LSHIFT' 'T_ASSIGN_RSHIFT' 
    -->     LA: 'T_ASSIGN_URSHIFT' 'T_ASSIGN_AND' 

** State #450: arrowFunctionParameters => @ ( #ID# | ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') )
    --> __________________
    --> #464: arrowFunctionParameters => ( #ID# | ('T_LPARAN') @ [ formalParameterList ] ('T_RPARAN') )
    -->     Type: pass
    -->     LA: 'T_LPARAN' 
    --> __________________
    --> #465: arrowFunctionParameters => ( #ID# @ | ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') )
    -->     Type: move
    -->     LA: #ID# 

** State #451: anoymousFunctionDecl => K_FUNCTION @ ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #466: anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') @ [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: pass
    -->     LA: 'T_LPARAN' 

** State #452: classExpression => K_CLASS (#ID#) @ classTail
    --> __________________
    --> #81: classTail => @ ('T_LBRACE') classElements ('T_RBRACE')
    -->     Type: shift
    -->     LA: 'T_LBRACE' 

** [FINAL] State #453: functionExpression => ( anonymousFunction | classExpression | thisExpression @ | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
    --> __________________
    --> #224: postfixExpression => ( postfixExpression ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): postfixExpression => @ ( postfixExpression ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )

** [FINAL] State #454: functionExpression => ( anonymousFunction | classExpression | thisExpression | identifierExpression @ | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
    --> __________________
    --> #224: postfixExpression => ( postfixExpression ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): postfixExpression => @ ( postfixExpression ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )

** [FINAL] State #455: functionExpression => ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression @ | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
    --> __________________
    --> #224: postfixExpression => ( postfixExpression ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): postfixExpression => @ ( postfixExpression ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )

** [FINAL] State #456: literal => ( K_NULL | K_TRUE | K_FALSE | #STRING# | #REGEX# | #NUMBER# @ )
    --> __________________
    --> #467: literalExpression => literal @
    -->     Type: reduce
    -->     Reduce(exp): literalExpression => @ literal

** [FINAL] State #457: literal => ( K_NULL @ | K_TRUE | K_FALSE | #STRING# | #REGEX# | #NUMBER# )
    --> __________________
    --> #467: literalExpression => literal @
    -->     Type: reduce
    -->     Reduce(exp): literalExpression => @ literal

** [FINAL] State #458: literal => ( K_NULL | K_TRUE @ | K_FALSE | #STRING# | #REGEX# | #NUMBER# )
    --> __________________
    --> #467: literalExpression => literal @
    -->     Type: reduce
    -->     Reduce(exp): literalExpression => @ literal

** [FINAL] State #459: literal => ( K_NULL | K_TRUE | K_FALSE @ | #STRING# | #REGEX# | #NUMBER# )
    --> __________________
    --> #467: literalExpression => literal @
    -->     Type: reduce
    -->     Reduce(exp): literalExpression => @ literal

** [FINAL] State #460: literal => ( K_NULL | K_TRUE | K_FALSE | #STRING# @ | #REGEX# | #NUMBER# )
    --> __________________
    --> #467: literalExpression => literal @
    -->     Type: reduce
    -->     Reduce(exp): literalExpression => @ literal

** [FINAL] State #461: literal => ( K_NULL | K_TRUE | K_FALSE | #STRING# | #REGEX# @ | #NUMBER# )
    --> __________________
    --> #467: literalExpression => literal @
    -->     Type: reduce
    -->     Reduce(exp): literalExpression => @ literal

** [FINAL] State #462: assignmentExpression => [ assignmentExpression 'T_ASSIGN' ] assignmentOperatorExpression @
    --> __________________
    --> #468: assignmentExpression => [ assignmentExpression @ 'T_ASSIGN' ] assignmentOperatorExpression
    -->     Type: recursion
    -->     LA: 'T_ASSIGN' 
    --> __________________
    --> #469: singleExpression => [ singleExpression ('T_COMMA') ] assignmentExpression @
    -->     Type: reduce
    -->     Reduce(exp): singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    --> __________________
    --> #469: singleExpression => [ singleExpression ('T_COMMA') ] assignmentExpression @
    -->     Type: reduce
    -->     Reduce(exp): singleExpression => [ singleExpression ('T_COMMA') @ ] assignmentExpression

** State #463: assignmentOperatorExpression => [ assignmentOperatorExpression @ ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #470: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' @ ) ] ternaryExpression
    -->     Type: move
    -->     LA: 'T_ASSIGN_POWER' 
    --> __________________
    --> #471: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' @ | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    -->     Type: move
    -->     LA: 'T_ASSIGN_ADD' 
    --> __________________
    --> #472: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' @ | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    -->     Type: move
    -->     LA: 'T_ASSIGN_SUB' 
    --> __________________
    --> #473: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' @ | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    -->     Type: move
    -->     LA: 'T_ASSIGN_MUL' 
    --> __________________
    --> #474: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' @ | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    -->     Type: move
    -->     LA: 'T_ASSIGN_DIV' 
    --> __________________
    --> #475: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' @ | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    -->     Type: move
    -->     LA: 'T_ASSIGN_MOD' 
    --> __________________
    --> #476: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' @ | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    -->     Type: move
    -->     LA: 'T_ASSIGN_LSHIFT' 
    --> __________________
    --> #477: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' @ | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    -->     Type: move
    -->     LA: 'T_ASSIGN_RSHIFT' 
    --> __________________
    --> #478: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' @ | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    -->     Type: move
    -->     LA: 'T_ASSIGN_URSHIFT' 
    --> __________________
    --> #479: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' @ | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    -->     Type: move
    -->     LA: 'T_ASSIGN_AND' 
    --> __________________
    --> #480: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' @ | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    -->     Type: move
    -->     LA: 'T_ASSIGN_OR' 
    --> __________________
    --> #481: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' @ | 'T_ASSIGN_POWER' ) ] ternaryExpression
    -->     Type: move
    -->     LA: 'T_ASSIGN_XOR' 

** State #464: arrowFunctionParameters => ( #ID# | ('T_LPARAN') @ [ formalParameterList ] ('T_RPARAN') )
    --> __________________
    --> #209: arrowFunctionParameters => ( #ID# | ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') @ )
    -->     Type: pass
    -->     LA: 'T_RPARAN' 
    --> __________________
    --> #89: formalParameterList => [ @ formalParameterList ('T_COMMA') ] assignable
    -->     Type: shift
    -->     LA: 'T_LSQUARE' 'T_LBRACE' #ID# 

** [FINAL] State #465: arrowFunctionParameters => ( #ID# @ | ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') )
    --> __________________
    --> #236: arrowFunction => arrowFunctionParameters @ ('T_ARROW') arrowFunctionBody
    -->     Type: reduce
    -->     Reduce: arrowFunction => @ arrowFunctionParameters ('T_ARROW') arrowFunctionBody

** State #466: anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') @ [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #208: anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') @ ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: pass
    -->     LA: 'T_RPARAN' 
    --> __________________
    --> #89: formalParameterList => [ @ formalParameterList ('T_COMMA') ] assignable
    -->     Type: shift
    -->     LA: 'T_LSQUARE' 'T_LBRACE' #ID# 

** [FINAL] State #467: literalExpression => literal @
    --> __________________
    --> #482: functionExpression => ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression @ | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
    -->     Type: reduce
    -->     Reduce(exp): functionExpression => @ ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )

** State #468: assignmentExpression => [ assignmentExpression @ 'T_ASSIGN' ] assignmentOperatorExpression
    --> __________________
    --> #483: assignmentExpression => [ assignmentExpression 'T_ASSIGN' @ ] assignmentOperatorExpression
    -->     Type: move
    -->     LA: 'T_ASSIGN' 

** [FINAL] State #469: singleExpression => [ singleExpression ('T_COMMA') ] assignmentExpression @
    --> __________________
    --> #484: argument => [ argument ('T_COMMA') ] [ ('T_ELLIPSIS') ] ( singleExpression @ | #ID# )
    -->     Type: reduce
    -->     Reduce: argument => [ @ argument ('T_COMMA') ] [ ('T_ELLIPSIS') ] ( singleExpression | #ID# )
    --> __________________
    --> #484: argument => [ argument ('T_COMMA') ] [ ('T_ELLIPSIS') ] ( singleExpression @ | #ID# )
    -->     Type: reduce
    -->     Reduce: argument => [ argument ('T_COMMA') ] [ ('T_ELLIPSIS') @ ] ( singleExpression | #ID# )
    --> __________________
    --> #484: argument => [ argument ('T_COMMA') ] [ ('T_ELLIPSIS') ] ( singleExpression @ | #ID# )
    -->     Type: reduce
    -->     Reduce: argument => [ argument ('T_COMMA') @ ] [ ('T_ELLIPSIS') ] ( singleExpression | #ID# )
    --> __________________
    --> #485: arrayElement => [ 'T_ELLIPSIS' ] singleExpression @
    -->     Type: reduce
    -->     Reduce: arrayElement => [ @ 'T_ELLIPSIS' ] singleExpression
    --> __________________
    --> #485: arrayElement => [ 'T_ELLIPSIS' ] singleExpression @
    -->     Type: reduce
    -->     Reduce: arrayElement => [ 'T_ELLIPSIS' @ ] singleExpression
    --> __________________
    --> #486: arrowFunctionBody => ( singleExpression @ | 'T_LBRACE' [ functionBody ] 'T_RBRACE' )
    -->     Type: reduce
    -->     Reduce: arrowFunctionBody => @ ( singleExpression | 'T_LBRACE' [ functionBody ] 'T_RBRACE' )
    --> __________________
    --> #487: classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' singleExpression @ )
    -->     Type: reduce
    -->     Reduce: classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' @ singleExpression )
    --> __________________
    --> #488: computedPropertyExpressionAssignment => ('T_LPARAN') singleExpression @ ('T_RPARAN') ('T_COLON') singleExpression
    -->     Type: reduce
    -->     Reduce: computedPropertyExpressionAssignment => ('T_LPARAN') @ singleExpression ('T_RPARAN') ('T_COLON') singleExpression
    --> __________________
    --> #489: computedPropertyExpressionAssignment => ('T_LPARAN') singleExpression ('T_RPARAN') ('T_COLON') singleExpression @
    -->     Type: reduce
    -->     Reduce: computedPropertyExpressionAssignment => ('T_LPARAN') singleExpression ('T_RPARAN') ('T_COLON') @ singleExpression
    --> __________________
    --> #490: expressionSequence => [ expressionSequence ('T_COMMA') ] singleExpression @
    -->     Type: reduce
    -->     Reduce: expressionSequence => [ @ expressionSequence ('T_COMMA') ] singleExpression
    --> __________________
    --> #490: expressionSequence => [ expressionSequence ('T_COMMA') ] singleExpression @
    -->     Type: reduce
    -->     Reduce: expressionSequence => [ expressionSequence ('T_COMMA') @ ] singleExpression
    --> __________________
    --> #491: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression @ | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement
    -->     Type: reduce
    -->     Reduce: forInStatement => K_FOR ('T_LPARAN') @ [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement
    --> __________________
    --> #492: newExpression => ( K_NEW singleExpression @ [ arguments ] | postfixExpression )
    -->     Type: reduce
    -->     Reduce(exp): newExpression => ( K_NEW @ singleExpression [ arguments ] | postfixExpression )
    --> __________________
    --> #493: propertyExpressionAssignment => propertyName ('T_COLON') singleExpression @
    -->     Type: reduce
    -->     Reduce: propertyExpressionAssignment => propertyName ('T_COLON') @ singleExpression
    --> __________________
    --> #494: propertyName => ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression @ ('T_RSQUARE') )
    -->     Type: reduce
    -->     Reduce: propertyName => ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') @ singleExpression ('T_RSQUARE') )
    --> __________________
    --> #495: propertyShorthand => [ 'T_ELLIPSIS' ] singleExpression @
    -->     Type: reduce
    -->     Reduce: propertyShorthand => [ @ 'T_ELLIPSIS' ] singleExpression
    --> __________________
    --> #495: propertyShorthand => [ 'T_ELLIPSIS' ] singleExpression @
    -->     Type: reduce
    -->     Reduce: propertyShorthand => [ 'T_ELLIPSIS' @ ] singleExpression
    --> __________________
    --> #496: singleExpression => [ singleExpression @ ('T_COMMA') ] assignmentExpression
    -->     Type: recursion
    -->     LA: 'T_COMMA' 
    --> __________________
    --> #497: ternaryExpression => logicalOrExpression [ 'T_QUERY' singleExpression @ 'T_COLON' singleExpression ]
    -->     Type: reduce
    -->     Reduce(exp): ternaryExpression => logicalOrExpression [ 'T_QUERY' @ singleExpression 'T_COLON' singleExpression ]
    --> __________________
    --> #498: ternaryExpression => logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' singleExpression @ ]
    -->     Type: reduce
    -->     Reduce(exp): ternaryExpression => logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' @ singleExpression ]
    --> __________________
    --> #499: variableDeclaration => assignable [ 'T_ASSIGN' singleExpression @ ]
    -->     Type: reduce
    -->     Reduce: variableDeclaration => assignable [ 'T_ASSIGN' @ singleExpression ]

** State #470: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' @ ) ] ternaryExpression
    --> __________________
    --> #146: ternaryExpression => @ logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' singleExpression ]
    -->     Type: shift
    -->     LA: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' 
    -->     LA: K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF 
    -->     LA: K_NEW K_VOID #NUMBER# 'T_LBRACE' K_DELETE 
    -->     LA: K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# 
    -->     LA: K_CLASS K_SUPER #STRING# K_FALSE 

** State #471: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' @ | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #146: ternaryExpression => @ logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' singleExpression ]
    -->     Type: shift
    -->     LA: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' 
    -->     LA: K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF 
    -->     LA: K_NEW K_VOID #NUMBER# 'T_LBRACE' K_DELETE 
    -->     LA: K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# 
    -->     LA: K_CLASS K_SUPER #STRING# K_FALSE 

** State #472: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' @ | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #146: ternaryExpression => @ logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' singleExpression ]
    -->     Type: shift
    -->     LA: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' 
    -->     LA: K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF 
    -->     LA: K_NEW K_VOID #NUMBER# 'T_LBRACE' K_DELETE 
    -->     LA: K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# 
    -->     LA: K_CLASS K_SUPER #STRING# K_FALSE 

** State #473: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' @ | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #146: ternaryExpression => @ logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' singleExpression ]
    -->     Type: shift
    -->     LA: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' 
    -->     LA: K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF 
    -->     LA: K_NEW K_VOID #NUMBER# 'T_LBRACE' K_DELETE 
    -->     LA: K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# 
    -->     LA: K_CLASS K_SUPER #STRING# K_FALSE 

** State #474: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' @ | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #146: ternaryExpression => @ logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' singleExpression ]
    -->     Type: shift
    -->     LA: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' 
    -->     LA: K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF 
    -->     LA: K_NEW K_VOID #NUMBER# 'T_LBRACE' K_DELETE 
    -->     LA: K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# 
    -->     LA: K_CLASS K_SUPER #STRING# K_FALSE 

** State #475: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' @ | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #146: ternaryExpression => @ logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' singleExpression ]
    -->     Type: shift
    -->     LA: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' 
    -->     LA: K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF 
    -->     LA: K_NEW K_VOID #NUMBER# 'T_LBRACE' K_DELETE 
    -->     LA: K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# 
    -->     LA: K_CLASS K_SUPER #STRING# K_FALSE 

** State #476: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' @ | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #146: ternaryExpression => @ logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' singleExpression ]
    -->     Type: shift
    -->     LA: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' 
    -->     LA: K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF 
    -->     LA: K_NEW K_VOID #NUMBER# 'T_LBRACE' K_DELETE 
    -->     LA: K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# 
    -->     LA: K_CLASS K_SUPER #STRING# K_FALSE 

** State #477: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' @ | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #146: ternaryExpression => @ logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' singleExpression ]
    -->     Type: shift
    -->     LA: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' 
    -->     LA: K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF 
    -->     LA: K_NEW K_VOID #NUMBER# 'T_LBRACE' K_DELETE 
    -->     LA: K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# 
    -->     LA: K_CLASS K_SUPER #STRING# K_FALSE 

** State #478: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' @ | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #146: ternaryExpression => @ logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' singleExpression ]
    -->     Type: shift
    -->     LA: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' 
    -->     LA: K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF 
    -->     LA: K_NEW K_VOID #NUMBER# 'T_LBRACE' K_DELETE 
    -->     LA: K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# 
    -->     LA: K_CLASS K_SUPER #STRING# K_FALSE 

** State #479: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' @ | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #146: ternaryExpression => @ logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' singleExpression ]
    -->     Type: shift
    -->     LA: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' 
    -->     LA: K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF 
    -->     LA: K_NEW K_VOID #NUMBER# 'T_LBRACE' K_DELETE 
    -->     LA: K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# 
    -->     LA: K_CLASS K_SUPER #STRING# K_FALSE 

** State #480: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' @ | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #146: ternaryExpression => @ logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' singleExpression ]
    -->     Type: shift
    -->     LA: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' 
    -->     LA: K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF 
    -->     LA: K_NEW K_VOID #NUMBER# 'T_LBRACE' K_DELETE 
    -->     LA: K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# 
    -->     LA: K_CLASS K_SUPER #STRING# K_FALSE 

** State #481: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' @ | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #146: ternaryExpression => @ logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' singleExpression ]
    -->     Type: shift
    -->     LA: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 'T_DEC' 
    -->     LA: K_NULL 'T_INC' K_FUNCTION K_THIS K_TYPEOF 
    -->     LA: K_NEW K_VOID #NUMBER# 'T_LBRACE' K_DELETE 
    -->     LA: K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' #REGEX# 
    -->     LA: K_CLASS K_SUPER #STRING# K_FALSE 

** [FINAL] State #482: functionExpression => ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression @ | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
    --> __________________
    --> #224: postfixExpression => ( postfixExpression ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): postfixExpression => @ ( postfixExpression ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )

** State #483: assignmentExpression => [ assignmentExpression 'T_ASSIGN' @ ] assignmentOperatorExpression
    --> __________________
    --> #114: assignmentOperatorExpression => [ @ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #484: argument => [ argument ('T_COMMA') ] [ ('T_ELLIPSIS') ] ( singleExpression @ | #ID# )
    --> __________________
    --> #339: argument => [ argument @ ('T_COMMA') ] [ ('T_ELLIPSIS') ] ( singleExpression | #ID# )
    -->     Type: recursion
    -->     LA: 'T_COMMA' 
    --> __________________
    --> #340: arguments => ('T_LPARAN') [ argument @ ] ('T_RPARAN')
    -->     Type: reduce
    -->     Reduce: arguments => ('T_LPARAN') @ [ argument ] ('T_RPARAN')

** [FINAL] State #485: arrayElement => [ 'T_ELLIPSIS' ] singleExpression @
    --> __________________
    --> #500: elementList => [ elementList ('T_COMMA') ] arrayElement @
    -->     Type: reduce
    -->     Reduce: elementList => [ @ elementList ('T_COMMA') ] arrayElement
    --> __________________
    --> #500: elementList => [ elementList ('T_COMMA') ] arrayElement @
    -->     Type: reduce
    -->     Reduce: elementList => [ elementList ('T_COMMA') @ ] arrayElement

** [FINAL] State #486: arrowFunctionBody => ( singleExpression @ | 'T_LBRACE' [ functionBody ] 'T_RBRACE' )
    --> __________________
    --> #198: arrowFunction => arrowFunctionParameters ('T_ARROW') arrowFunctionBody @
    -->     Type: reduce
    -->     Reduce: arrowFunction => arrowFunctionParameters ('T_ARROW') @ arrowFunctionBody

** [FINAL] State #487: classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' singleExpression @ )
    --> __________________
    --> #69: classElements => [ classElements ('T_COMMA') ] classElement @
    -->     Type: reduce
    -->     Reduce: classElements => [ @ classElements ('T_COMMA') ] classElement
    --> __________________
    --> #69: classElements => [ classElements ('T_COMMA') ] classElement @
    -->     Type: reduce
    -->     Reduce: classElements => [ classElements ('T_COMMA') @ ] classElement

** State #488: computedPropertyExpressionAssignment => ('T_LPARAN') singleExpression @ ('T_RPARAN') ('T_COLON') singleExpression
    --> __________________
    --> #501: computedPropertyExpressionAssignment => ('T_LPARAN') singleExpression ('T_RPARAN') @ ('T_COLON') singleExpression
    -->     Type: pass
    -->     LA: 'T_RPARAN' 

** [FINAL] State #489: computedPropertyExpressionAssignment => ('T_LPARAN') singleExpression ('T_RPARAN') ('T_COLON') singleExpression @
    --> __________________
    --> #502: propertyAssignment => ( propertyExpressionAssignment | computedPropertyExpressionAssignment @ | propertyShorthand )
    -->     Type: reduce
    -->     Reduce: propertyAssignment => @ ( propertyExpressionAssignment | computedPropertyExpressionAssignment | propertyShorthand )

** [FINAL] State #490: expressionSequence => [ expressionSequence ('T_COMMA') ] singleExpression @
    --> __________________
    --> #503: caseClause => K_CASE expressionSequence @ 'T_COLON' [ statementList ]
    -->     Type: reduce
    -->     Reduce: caseClause => K_CASE @ expressionSequence 'T_COLON' [ statementList ]
    --> __________________
    --> #504: doStatement => K_DO statement K_WHILE ('T_LPARAN') expressionSequence @ ('T_RPARAN') [ eos ]
    -->     Type: reduce
    -->     Reduce: doStatement => K_DO statement K_WHILE ('T_LPARAN') @ expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #505: expressionSequence => [ expressionSequence @ ('T_COMMA') ] singleExpression
    -->     Type: recursion
    -->     LA: 'T_COMMA' 
    --> __________________
    --> #506: expressionStatement => expressionSequence @ [ eos ]
    -->     Type: reduce
    -->     Reduce: expressionStatement => @ expressionSequence [ eos ]
    --> __________________
    --> #507: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence @ ('T_RPARAN') statement
    -->     Type: reduce
    -->     Reduce: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN @ expressionSequence ('T_RPARAN') statement
    --> __________________
    --> #508: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence @ | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
    -->     Type: reduce
    -->     Reduce: forStatement => K_FOR ('T_LPARAN') @ [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
    --> __________________
    --> #509: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence @ ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
    -->     Type: reduce
    -->     Reduce: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' @ [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
    --> __________________
    --> #510: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence @ ] ('T_RPARAN') statement
    -->     Type: reduce
    -->     Reduce: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' @ [ expressionSequence ] ('T_RPARAN') statement
    --> __________________
    --> #511: ifStatement => K_IF ('T_LPARAN') expressionSequence @ ('T_RPARAN') statement [ K_ELSE statement ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') @ expressionSequence ('T_RPARAN') statement [ K_ELSE statement ]
    --> __________________
    --> #512: memberIndexExpression => [ memberIndexExpression ] 'T_LSQUARE' expressionSequence @ 'T_RSQUARE'
    -->     Type: reduce
    -->     Reduce(exp): memberIndexExpression => [ memberIndexExpression ] 'T_LSQUARE' @ expressionSequence 'T_RSQUARE'
    --> __________________
    --> #513: parenthesizedExpression => ('T_LPARAN') expressionSequence @ ('T_RPARAN')
    -->     Type: reduce
    -->     Reduce(exp): parenthesizedExpression => ('T_LPARAN') @ expressionSequence ('T_RPARAN')
    --> __________________
    --> #514: returnStatement => K_RETURN [ expressionSequence @ ] [ eos ]
    -->     Type: reduce
    -->     Reduce: returnStatement => K_RETURN @ [ expressionSequence ] [ eos ]
    --> __________________
    --> #515: switchStatement => K_SWITCH ('T_LPARAN') expressionSequence @ ('T_RPARAN') caseBlock
    -->     Type: reduce
    -->     Reduce: switchStatement => K_SWITCH ('T_LPARAN') @ expressionSequence ('T_RPARAN') caseBlock
    --> __________________
    --> #516: throwStatement => K_THROW expressionSequence @ [ eos ]
    -->     Type: reduce
    -->     Reduce: throwStatement => K_THROW @ expressionSequence [ eos ]
    --> __________________
    --> #517: whileStatement => K_WHILE ('T_LPARAN') expressionSequence @ ('T_RPARAN') statement
    -->     Type: reduce
    -->     Reduce: whileStatement => K_WHILE ('T_LPARAN') @ expressionSequence ('T_RPARAN') statement
    --> __________________
    --> #518: withStatement => K_WITH ('T_LPARAN') expressionSequence @ ('T_RPARAN') statement
    -->     Type: reduce
    -->     Reduce: withStatement => K_WITH ('T_LPARAN') @ expressionSequence ('T_RPARAN') statement

** State #491: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression @ | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement
    --> __________________
    --> #115: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN @ expressionSequence ('T_RPARAN') statement
    -->     Type: move
    -->     LA: K_IN 

** [FINAL] State #492: newExpression => ( K_NEW singleExpression @ [ arguments ] | postfixExpression )
    --> __________________
    --> #309: arguments => @ ('T_LPARAN') [ argument ] ('T_RPARAN')
    -->     Type: shift
    -->     LA: 'T_LPARAN' 
    --> __________________
    --> #263: deleteExpression => ( K_DELETE deleteExpression | newExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): deleteExpression => @ ( K_DELETE deleteExpression | newExpression )

** [FINAL] State #493: propertyExpressionAssignment => propertyName ('T_COLON') singleExpression @
    --> __________________
    --> #519: propertyAssignment => ( propertyExpressionAssignment @ | computedPropertyExpressionAssignment | propertyShorthand )
    -->     Type: reduce
    -->     Reduce: propertyAssignment => @ ( propertyExpressionAssignment | computedPropertyExpressionAssignment | propertyShorthand )

** State #494: propertyName => ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression @ ('T_RSQUARE') )
    --> __________________
    --> #520: propertyName => ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') @ )
    -->     Type: pass
    -->     LA: 'T_RSQUARE' 

** [FINAL] State #495: propertyShorthand => [ 'T_ELLIPSIS' ] singleExpression @
    --> __________________
    --> #521: propertyAssignment => ( propertyExpressionAssignment | computedPropertyExpressionAssignment | propertyShorthand @ )
    -->     Type: reduce
    -->     Reduce: propertyAssignment => @ ( propertyExpressionAssignment | computedPropertyExpressionAssignment | propertyShorthand )

** State #496: singleExpression => [ singleExpression @ ('T_COMMA') ] assignmentExpression
    --> __________________
    --> #522: singleExpression => [ singleExpression ('T_COMMA') @ ] assignmentExpression
    -->     Type: pass
    -->     LA: 'T_COMMA' 

** State #497: ternaryExpression => logicalOrExpression [ 'T_QUERY' singleExpression @ 'T_COLON' singleExpression ]
    --> __________________
    --> #523: ternaryExpression => logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' @ singleExpression ]
    -->     Type: move
    -->     LA: 'T_COLON' 

** [FINAL] State #498: ternaryExpression => logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' singleExpression @ ]
    --> __________________
    --> #449: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ @ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #449: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' @ ) ] ternaryExpression
    --> __________________
    --> #449: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' @ | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #449: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' @ | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #449: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' @ | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #449: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' @ | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #449: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' @ | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #449: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' @ | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #449: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' @ | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #449: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' @ | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #449: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' @ | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #449: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' @ | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #449: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' @ | 'T_ASSIGN_POWER' ) ] ternaryExpression

** [FINAL] State #499: variableDeclaration => assignable [ 'T_ASSIGN' singleExpression @ ]
    --> __________________
    --> #188: variableDeclarationList => [ variableDeclarationList ('T_COMMA') ] variableDeclaration @
    -->     Type: reduce
    -->     Reduce: variableDeclarationList => [ @ variableDeclarationList ('T_COMMA') ] variableDeclaration
    --> __________________
    --> #188: variableDeclarationList => [ variableDeclarationList ('T_COMMA') ] variableDeclaration @
    -->     Type: reduce
    -->     Reduce: variableDeclarationList => [ variableDeclarationList ('T_COMMA') @ ] variableDeclaration

** [FINAL] State #500: elementList => [ elementList ('T_COMMA') ] arrayElement @
    --> __________________
    --> #524: arrayLiteral => ('T_LSQUARE') [ elementList @ ] ('T_RSQUARE')
    -->     Type: reduce
    -->     Reduce: arrayLiteral => ('T_LSQUARE') @ [ elementList ] ('T_RSQUARE')
    --> __________________
    --> #525: elementList => [ elementList @ ('T_COMMA') ] arrayElement
    -->     Type: recursion
    -->     LA: 'T_COMMA' 

** State #501: computedPropertyExpressionAssignment => ('T_LPARAN') singleExpression ('T_RPARAN') @ ('T_COLON') singleExpression
    --> __________________
    --> #526: computedPropertyExpressionAssignment => ('T_LPARAN') singleExpression ('T_RPARAN') ('T_COLON') @ singleExpression
    -->     Type: pass
    -->     LA: 'T_COLON' 

** [FINAL] State #502: propertyAssignment => ( propertyExpressionAssignment | computedPropertyExpressionAssignment @ | propertyShorthand )
    --> __________________
    --> #527: propertyAssignments => [ propertyAssignments ('T_COMMA') ] propertyAssignment @
    -->     Type: reduce
    -->     Reduce: propertyAssignments => [ @ propertyAssignments ('T_COMMA') ] propertyAssignment
    --> __________________
    --> #527: propertyAssignments => [ propertyAssignments ('T_COMMA') ] propertyAssignment @
    -->     Type: reduce
    -->     Reduce: propertyAssignments => [ propertyAssignments ('T_COMMA') @ ] propertyAssignment

** State #503: caseClause => K_CASE expressionSequence @ 'T_COLON' [ statementList ]
    --> __________________
    --> #528: caseClause => K_CASE expressionSequence 'T_COLON' @ [ statementList ]
    -->     Type: move
    -->     LA: 'T_COLON' 

** State #504: doStatement => K_DO statement K_WHILE ('T_LPARAN') expressionSequence @ ('T_RPARAN') [ eos ]
    --> __________________
    --> #529: doStatement => K_DO statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ [ eos ]
    -->     Type: pass
    -->     LA: 'T_RPARAN' 

** State #505: expressionSequence => [ expressionSequence @ ('T_COMMA') ] singleExpression
    --> __________________
    --> #530: expressionSequence => [ expressionSequence ('T_COMMA') @ ] singleExpression
    -->     Type: pass
    -->     LA: 'T_COMMA' 

** [FINAL] State #506: expressionStatement => expressionSequence @ [ eos ]
    --> __________________
    --> #53: eos => @ ( 'T_SEMI' | #END# )
    -->     Type: shift
    -->     LA: 'T_SEMI' #END# 
    --> __________________
    --> #149: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement @ | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** State #507: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence @ ('T_RPARAN') statement
    --> __________________
    --> #531: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') @ statement
    -->     Type: pass
    -->     LA: 'T_RPARAN' 

** State #508: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence @ | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
    --> __________________
    --> #117: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' @ [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
    -->     Type: move
    -->     LA: 'T_SEMI' 

** State #509: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence @ ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
    --> __________________
    --> #147: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' @ [ expressionSequence ] ('T_RPARAN') statement
    -->     Type: move
    -->     LA: 'T_SEMI' 

** State #510: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence @ ] ('T_RPARAN') statement
    --> __________________
    --> #174: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') @ statement
    -->     Type: pass
    -->     LA: 'T_RPARAN' 

** State #511: ifStatement => K_IF ('T_LPARAN') expressionSequence @ ('T_RPARAN') statement [ K_ELSE statement ]
    --> __________________
    --> #532: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement [ K_ELSE statement ]
    -->     Type: pass
    -->     LA: 'T_RPARAN' 

** State #512: memberIndexExpression => [ memberIndexExpression ] 'T_LSQUARE' expressionSequence @ 'T_RSQUARE'
    --> __________________
    --> #533: memberIndexExpression => [ memberIndexExpression ] 'T_LSQUARE' expressionSequence 'T_RSQUARE' @
    -->     Type: move
    -->     LA: 'T_RSQUARE' 

** State #513: parenthesizedExpression => ('T_LPARAN') expressionSequence @ ('T_RPARAN')
    --> __________________
    --> #534: parenthesizedExpression => ('T_LPARAN') expressionSequence ('T_RPARAN') @
    -->     Type: pass
    -->     LA: 'T_RPARAN' 

** [FINAL] State #514: returnStatement => K_RETURN [ expressionSequence @ ] [ eos ]
    --> __________________
    --> #53: eos => @ ( 'T_SEMI' | #END# )
    -->     Type: shift
    -->     LA: 'T_SEMI' #END# 
    --> __________________
    --> #58: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement @ | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** State #515: switchStatement => K_SWITCH ('T_LPARAN') expressionSequence @ ('T_RPARAN') caseBlock
    --> __________________
    --> #535: switchStatement => K_SWITCH ('T_LPARAN') expressionSequence ('T_RPARAN') @ caseBlock
    -->     Type: pass
    -->     LA: 'T_RPARAN' 

** [FINAL] State #516: throwStatement => K_THROW expressionSequence @ [ eos ]
    --> __________________
    --> #53: eos => @ ( 'T_SEMI' | #END# )
    -->     Type: shift
    -->     LA: 'T_SEMI' #END# 
    --> __________________
    --> #150: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement @ | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** State #517: whileStatement => K_WHILE ('T_LPARAN') expressionSequence @ ('T_RPARAN') statement
    --> __________________
    --> #536: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
    -->     Type: pass
    -->     LA: 'T_RPARAN' 

** State #518: withStatement => K_WITH ('T_LPARAN') expressionSequence @ ('T_RPARAN') statement
    --> __________________
    --> #537: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
    -->     Type: pass
    -->     LA: 'T_RPARAN' 

** [FINAL] State #519: propertyAssignment => ( propertyExpressionAssignment @ | computedPropertyExpressionAssignment | propertyShorthand )
    --> __________________
    --> #527: propertyAssignments => [ propertyAssignments ('T_COMMA') ] propertyAssignment @
    -->     Type: reduce
    -->     Reduce: propertyAssignments => [ @ propertyAssignments ('T_COMMA') ] propertyAssignment
    --> __________________
    --> #527: propertyAssignments => [ propertyAssignments ('T_COMMA') ] propertyAssignment @
    -->     Type: reduce
    -->     Reduce: propertyAssignments => [ propertyAssignments ('T_COMMA') @ ] propertyAssignment

** [FINAL] State #520: propertyName => ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') @ )
    --> __________________
    --> #243: classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName @ 'T_ASSIGN' singleExpression )
    -->     Type: reduce
    -->     Reduce: classElement => @ ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' singleExpression )
    --> __________________
    --> #243: classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName @ 'T_ASSIGN' singleExpression )
    -->     Type: reduce
    -->     Reduce: classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' @ ] propertyName 'T_ASSIGN' singleExpression )
    --> __________________
    --> #244: methodDefinition => [ 'T_SHARP' ] propertyName @ ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: methodDefinition => [ @ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #244: methodDefinition => [ 'T_SHARP' ] propertyName @ ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: methodDefinition => [ 'T_SHARP' @ ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #245: propertyExpressionAssignment => propertyName @ ('T_COLON') singleExpression
    -->     Type: reduce
    -->     Reduce: propertyExpressionAssignment => @ propertyName ('T_COLON') singleExpression

** [FINAL] State #521: propertyAssignment => ( propertyExpressionAssignment | computedPropertyExpressionAssignment | propertyShorthand @ )
    --> __________________
    --> #527: propertyAssignments => [ propertyAssignments ('T_COMMA') ] propertyAssignment @
    -->     Type: reduce
    -->     Reduce: propertyAssignments => [ @ propertyAssignments ('T_COMMA') ] propertyAssignment
    --> __________________
    --> #527: propertyAssignments => [ propertyAssignments ('T_COMMA') ] propertyAssignment @
    -->     Type: reduce
    -->     Reduce: propertyAssignments => [ propertyAssignments ('T_COMMA') @ ] propertyAssignment

** State #522: singleExpression => [ singleExpression ('T_COMMA') @ ] assignmentExpression
    --> __________________
    --> #82: assignmentExpression => [ @ assignmentExpression 'T_ASSIGN' ] assignmentOperatorExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #523: ternaryExpression => logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' @ singleExpression ]
    --> __________________
    --> #47: singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #524: arrayLiteral => ('T_LSQUARE') [ elementList @ ] ('T_RSQUARE')
    --> __________________
    --> #189: arrayLiteral => ('T_LSQUARE') [ elementList ] ('T_RSQUARE') @
    -->     Type: pass
    -->     LA: 'T_RSQUARE' 

** State #525: elementList => [ elementList @ ('T_COMMA') ] arrayElement
    --> __________________
    --> #538: elementList => [ elementList ('T_COMMA') @ ] arrayElement
    -->     Type: pass
    -->     LA: 'T_COMMA' 

** State #526: computedPropertyExpressionAssignment => ('T_LPARAN') singleExpression ('T_RPARAN') ('T_COLON') @ singleExpression
    --> __________________
    --> #47: singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #527: propertyAssignments => [ propertyAssignments ('T_COMMA') ] propertyAssignment @
    --> __________________
    --> #539: objectLiteral => ('T_LBRACE') [ propertyAssignments @ ] [ ('T_COMMA') ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: objectLiteral => ('T_LBRACE') @ [ propertyAssignments ] [ ('T_COMMA') ] ('T_RBRACE')
    --> __________________
    --> #540: propertyAssignments => [ propertyAssignments @ ('T_COMMA') ] propertyAssignment
    -->     Type: recursion
    -->     LA: 'T_COMMA' 

** [FINAL] State #528: caseClause => K_CASE expressionSequence 'T_COLON' @ [ statementList ]
    --> __________________
    --> #42: statementList => [ @ statementList ] statement
    -->     Type: shift
    -->     LA: K_BREAK 'T_INC' 'T_LBRACE' K_DO K_WHILE 
    -->     LA: K_NEW K_FOR 'T_LPARAN' K_SUPER K_IF 
    -->     LA: K_FALSE #REGEX# K_VOID K_DELETE K_FUNCTION 
    -->     LA: K_THIS K_NULL 'T_DEC' 'T_SUB' K_TRUE 
    -->     LA: K_CLASS 'T_BIT_NOT' 'T_ADD' #STRING# 'T_SEMI' 
    -->     LA: K_SWITCH K_CONTINUE K_RETURN K_TRY 'T_LSQUARE' 
    -->     LA: K_VAR #ID# K_THROW K_DEBUGGER #NUMBER# 
    -->     LA: K_TYPEOF 'T_LOG_NOT' K_WITH 
    --> __________________
    --> #143: caseClauses => caseClause @ [ caseClauses ]
    -->     Type: reduce
    -->     Reduce: caseClauses => @ caseClause [ caseClauses ]

** [FINAL] State #529: doStatement => K_DO statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ [ eos ]
    --> __________________
    --> #53: eos => @ ( 'T_SEMI' | #END# )
    -->     Type: shift
    -->     LA: 'T_SEMI' #END# 
    --> __________________
    --> #148: iterationStatement => ( doStatement @ | whileStatement | forStatement | forInStatement )
    -->     Type: reduce
    -->     Reduce: iterationStatement => @ ( doStatement | whileStatement | forStatement | forInStatement )

** State #530: expressionSequence => [ expressionSequence ('T_COMMA') @ ] singleExpression
    --> __________________
    --> #47: singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    -->     Type: shift
    -->     LA: K_FALSE #STRING# K_DELETE K_SUPER K_CLASS 
    -->     LA: #REGEX# 'T_LSQUARE' #ID# K_VOID 'T_LPARAN' 
    -->     LA: K_TRUE 'T_LBRACE' #NUMBER# K_NEW K_TYPEOF 
    -->     LA: K_THIS K_FUNCTION 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #531: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #2: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: shift
    -->     LA: K_TRY K_WITH 'T_LOG_NOT' K_TYPEOF #NUMBER# 
    -->     LA: K_DEBUGGER K_THROW #ID# K_VAR 'T_LSQUARE' 
    -->     LA: K_RETURN K_CONTINUE K_FUNCTION K_SWITCH 'T_SEMI' 
    -->     LA: #STRING# 'T_ADD' K_CLASS 'T_BIT_NOT' K_TRUE 
    -->     LA: 'T_SUB' 'T_DEC' K_NULL K_THIS K_VOID 
    -->     LA: K_DELETE #REGEX# K_SUPER K_FALSE K_IF 
    -->     LA: 'T_LPARAN' K_FOR K_NEW K_WHILE K_DO 
    -->     LA: 'T_LBRACE' 'T_INC' K_BREAK 

** State #532: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement [ K_ELSE statement ]
    --> __________________
    --> #2: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: shift
    -->     LA: K_TRY K_WITH 'T_LOG_NOT' K_TYPEOF #NUMBER# 
    -->     LA: K_DEBUGGER K_THROW #ID# K_VAR 'T_LSQUARE' 
    -->     LA: K_RETURN K_CONTINUE K_FUNCTION K_SWITCH 'T_SEMI' 
    -->     LA: #STRING# 'T_ADD' K_CLASS 'T_BIT_NOT' K_TRUE 
    -->     LA: 'T_SUB' 'T_DEC' K_NULL K_THIS K_VOID 
    -->     LA: K_DELETE #REGEX# K_SUPER K_FALSE K_IF 
    -->     LA: 'T_LPARAN' K_FOR K_NEW K_WHILE K_DO 
    -->     LA: 'T_LBRACE' 'T_INC' K_BREAK 

** [FINAL] State #533: memberIndexExpression => [ memberIndexExpression ] 'T_LSQUARE' expressionSequence 'T_RSQUARE' @
    --> __________________
    --> #541: memberIndexExpression => [ memberIndexExpression @ ] 'T_LSQUARE' expressionSequence 'T_RSQUARE'
    -->     Type: recursion
    -->     LA: 'T_LSQUARE' 
    --> __________________
    --> #542: postfixExpression => ( postfixExpression ( memberIndexExpression @ | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )
    -->     Type: reduce
    -->     Reduce(exp): postfixExpression => ( postfixExpression @ ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )

** [FINAL] State #534: parenthesizedExpression => ('T_LPARAN') expressionSequence ('T_RPARAN') @
    --> __________________
    --> #543: functionExpression => ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): functionExpression => @ ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )

** State #535: switchStatement => K_SWITCH ('T_LPARAN') expressionSequence ('T_RPARAN') @ caseBlock
    --> __________________
    --> #544: caseBlock => @ ('T_LBRACE') [ caseClauses ] [ defaultClause [ caseClauses ] ] ('T_RBRACE')
    -->     Type: shift
    -->     LA: 'T_LBRACE' 

** State #536: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #2: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: shift
    -->     LA: K_TRY K_WITH 'T_LOG_NOT' K_TYPEOF #NUMBER# 
    -->     LA: K_DEBUGGER K_THROW #ID# K_VAR 'T_LSQUARE' 
    -->     LA: K_RETURN K_CONTINUE K_FUNCTION K_SWITCH 'T_SEMI' 
    -->     LA: #STRING# 'T_ADD' K_CLASS 'T_BIT_NOT' K_TRUE 
    -->     LA: 'T_SUB' 'T_DEC' K_NULL K_THIS K_VOID 
    -->     LA: K_DELETE #REGEX# K_SUPER K_FALSE K_IF 
    -->     LA: 'T_LPARAN' K_FOR K_NEW K_WHILE K_DO 
    -->     LA: 'T_LBRACE' 'T_INC' K_BREAK 

** State #537: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #2: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: shift
    -->     LA: K_TRY K_WITH 'T_LOG_NOT' K_TYPEOF #NUMBER# 
    -->     LA: K_DEBUGGER K_THROW #ID# K_VAR 'T_LSQUARE' 
    -->     LA: K_RETURN K_CONTINUE K_FUNCTION K_SWITCH 'T_SEMI' 
    -->     LA: #STRING# 'T_ADD' K_CLASS 'T_BIT_NOT' K_TRUE 
    -->     LA: 'T_SUB' 'T_DEC' K_NULL K_THIS K_VOID 
    -->     LA: K_DELETE #REGEX# K_SUPER K_FALSE K_IF 
    -->     LA: 'T_LPARAN' K_FOR K_NEW K_WHILE K_DO 
    -->     LA: 'T_LBRACE' 'T_INC' K_BREAK 

** State #538: elementList => [ elementList ('T_COMMA') @ ] arrayElement
    --> __________________
    --> #218: arrayElement => [ @ 'T_ELLIPSIS' ] singleExpression
    -->     Type: shift
    -->     LA: 'T_ELLIPSIS' 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_SUB' 
    -->     LA: 'T_DEC' K_NULL 'T_INC' K_FUNCTION K_THIS 
    -->     LA: K_TYPEOF K_NEW K_VOID #NUMBER# 'T_LBRACE' 
    -->     LA: K_DELETE K_TRUE 'T_LPARAN' #ID# 'T_LSQUARE' 
    -->     LA: #REGEX# K_CLASS K_SUPER #STRING# K_FALSE 

** State #539: objectLiteral => ('T_LBRACE') [ propertyAssignments @ ] [ ('T_COMMA') ] ('T_RBRACE')
    --> __________________
    --> #179: objectLiteral => ('T_LBRACE') [ propertyAssignments ] [ ('T_COMMA') ] ('T_RBRACE') @
    -->     Type: pass
    -->     LA: 'T_RBRACE' 
    --> __________________
    --> #181: objectLiteral => ('T_LBRACE') [ propertyAssignments ] [ ('T_COMMA') @ ] ('T_RBRACE')
    -->     Type: pass
    -->     LA: 'T_COMMA' 

** State #540: propertyAssignments => [ propertyAssignments @ ('T_COMMA') ] propertyAssignment
    --> __________________
    --> #545: propertyAssignments => [ propertyAssignments ('T_COMMA') @ ] propertyAssignment
    -->     Type: pass
    -->     LA: 'T_COMMA' 

** State #541: memberIndexExpression => [ memberIndexExpression @ ] 'T_LSQUARE' expressionSequence 'T_RSQUARE'
    --> __________________
    --> #306: memberIndexExpression => [ memberIndexExpression ] 'T_LSQUARE' @ expressionSequence 'T_RSQUARE'
    -->     Type: move
    -->     LA: 'T_LSQUARE' 

** [FINAL] State #542: postfixExpression => ( postfixExpression ( memberIndexExpression @ | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )
    --> __________________
    --> #247: newExpression => ( K_NEW singleExpression [ arguments ] | postfixExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): newExpression => @ ( K_NEW singleExpression [ arguments ] | postfixExpression )
    --> __________________
    --> #248: postfixExpression => ( postfixExpression @ ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )
    -->     Type: recursion
    -->     LA: 'T_INC' 'T_LPARAN' 'T_LSQUARE' 'T_DOT' 'T_DEC' 
    -->     LA: 'T_QUERY' 

** [FINAL] State #543: functionExpression => ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression @ )
    --> __________________
    --> #224: postfixExpression => ( postfixExpression ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): postfixExpression => @ ( postfixExpression ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )

** State #544: caseBlock => @ ('T_LBRACE') [ caseClauses ] [ defaultClause [ caseClauses ] ] ('T_RBRACE')
    --> __________________
    --> #546: caseBlock => ('T_LBRACE') @ [ caseClauses ] [ defaultClause [ caseClauses ] ] ('T_RBRACE')
    -->     Type: pass
    -->     LA: 'T_LBRACE' 

** State #545: propertyAssignments => [ propertyAssignments ('T_COMMA') @ ] propertyAssignment
    --> __________________
    --> #207: propertyAssignment => @ ( propertyExpressionAssignment | computedPropertyExpressionAssignment | propertyShorthand )
    -->     Type: shift
    -->     LA: K_FOR K_SUPER #NUMBER# K_CLASS #REGEX# 
    -->     LA: 'T_LPARAN' K_DELETE K_INSTANCEOF K_NEW K_THIS 
    -->     LA: K_FUNCTION K_CONTINUE 'T_INC' K_NULL 'T_DEC' 
    -->     LA: 'T_SUB' K_TRUE 'T_BIT_NOT' 'T_ADD' K_TYPEOF 
    -->     LA: K_VAR K_FALSE 'T_ELLIPSIS' K_TRY 'T_LBRACE' 
    -->     LA: 'T_LOG_NOT' K_DEFAULT K_DEBUGGER K_WHILE #STRING# 
    -->     LA: K_SWITCH K_ELSE K_VOID K_LET K_IN 
    -->     LA: 'T_LSQUARE' #ID# K_RETURN K_IF K_FINALLY 
    -->     LA: K_CASE K_CATCH K_BREAK K_THROW K_WITH 
    -->     LA: K_DO 

** State #546: caseBlock => ('T_LBRACE') @ [ caseClauses ] [ defaultClause [ caseClauses ] ] ('T_RBRACE')
    --> __________________
    --> #172: caseBlock => ('T_LBRACE') [ caseClauses ] [ defaultClause [ caseClauses ] ] ('T_RBRACE') @
    -->     Type: pass
    -->     LA: 'T_RBRACE' 
    --> __________________
    --> #168: caseClauses => @ caseClause [ caseClauses ]
    -->     Type: shift
    -->     LA: K_CASE 
    --> __________________
    --> #201: defaultClause => @ K_DEFAULT 'T_COLON' [ statementList ]
    -->     Type: shift
    -->     LA: K_DEFAULT 

