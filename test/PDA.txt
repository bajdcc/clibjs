==== RULE ====
additiveExpression => [ additiveExpression ( 'T_ADD' | 'T_SUB' ) ] multiplicativeExpression
anonymousFunction => ( functionDecl | anoymousFunctionDecl | arrowFunction )
anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
argument => [ argument ('T_COMMA') ] [ ('T_ELLIPSIS') ] ( singleExpression | #ID# )
arguments => ('T_LPARAN') [ argument ] ('T_RPARAN')
argumentsExpression => [ argumentsExpression ] arguments
arrayElement => [ 'T_ELLIPSIS' ] singleExpression
arrayLiteral => ('T_LSQUARE') [ elementList ] ('T_RSQUARE')
arrayLiteralExpression => arrayLiteral
arrowFunction => arrowFunctionParameters ('T_ARROW') arrowFunctionBody
arrowFunctionBody => ( singleExpression | 'T_LBRACE' [ functionBody ] 'T_RBRACE' )
arrowFunctionParameters => ( #ID# | ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') )
assignable => ( #ID# | arrayLiteral | objectLiteral )
assignmentExpression => [ assignmentExpression 'T_ASSIGN' ] assignmentOperatorExpression
assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
bitAndExpression => [ bitAndExpression 'T_BIT_AND' ] equalityExpression
bitNotExpression => ( 'T_BIT_NOT' bitNotExpression | unaryMinusExpression )
bitOrExpression => [ bitOrExpression 'T_BIT_OR' ] bitXOrExpression
bitShiftExpression => [ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression
bitXOrExpression => [ bitXOrExpression 'T_BIT_XOR' ] bitAndExpression
block => ('T_LBRACE') [ statementList ] ('T_RBRACE')
breakStatement => K_BREAK [ (#RULE_NO_LINE#) #ID# ] [ eos ]
caseBlock => ('T_LBRACE') [ caseClauses ] [ defaultClause [ caseClauses ] ] ('T_RBRACE')
caseClause => K_CASE expressionSequence 'T_COLON' [ statementList ]
caseClauses => caseClause [ caseClauses ]
catchProduction => K_CATCH [ ('T_LPARAN') [ assignable ] ('T_RPARAN') ] block
classDeclaration => K_CLASS #ID# classTail
classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' singleExpression )
classElements => [ classElements ('T_COMMA') ] classElement
classExpression => K_CLASS (#ID#) classTail
classTail => ('T_LBRACE') classElements ('T_RBRACE')
coalesceExpression => [ coalesceExpression 'T_COALESCE' ] additiveExpression
computedPropertyExpressionAssignment => ('T_LPARAN') singleExpression ('T_RPARAN') ('T_COLON') singleExpression
continueStatement => K_CONTINUE [ (#RULE_NO_LINE#) #ID# ] [ eos ]
debuggerStatement => K_DEBUGGER [ eos ]
defaultClause => K_DEFAULT 'T_COLON' [ statementList ]
deleteExpression => ( K_DELETE deleteExpression | newExpression )
doStatement => K_DO statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
elementList => [ elementList ('T_COMMA') ] arrayElement
emptyStatement => 'T_SEMI'
eos => ( ('T_SEMI') | #END# )
equalityExpression => [ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression
expressionSequence => [ expressionSequence ('T_COMMA') ] singleExpression
expressionStatement => expressionSequence [ eos ]
finallyProduction => K_FINALLY block
forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement
forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
formalParameterArg => assignable
formalParameterList => [ formalParameterList ('T_COMMA') ] assignable
functionBody => [ functionBody ] sourceElements
functionDecl => functionDeclaration
functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
functionExpression => ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
identifierExpression => #ID#
identifierName => ( #ID# | reservedWord )
ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement ]
inExpression => [ inExpression K_IN ] instanceofExpression
instanceofExpression => [ instanceofExpression K_INSTANCEOF ] relationalExpression
iterationStatement => ( doStatement | whileStatement | forStatement | forInStatement )
keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
labelledStatement => #ID# 'T_COLON' statement
literal => ( K_NULL | K_TRUE | K_FALSE | #STRING# | #REGEX# | #NUMBER# )
literalExpression => literal
logicalAndExpression => [ logicalAndExpression 'T_LOG_AND' ] bitOrExpression
logicalOrExpression => [ logicalOrExpression 'T_LOG_OR' ] logicalAndExpression
memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' [ 'T_SHARP' ] identifierName
memberIndexExpression => [ memberIndexExpression ] 'T_LSQUARE' expressionSequence 'T_RSQUARE'
methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
multiplicativeExpression => [ multiplicativeExpression ( 'T_MUL' | 'T_DIV' | 'T_MOD' ) ] powerExpression
newExpression => ( K_NEW singleExpression [ arguments ] | postfixExpression )
notExpression => ( 'T_LOG_NOT' notExpression | bitNotExpression )
numericLiteral => #NUMBER#
objectLiteral => ('T_LBRACE') [ propertyAssignments ] [ ('T_COMMA') ] ('T_RBRACE')
objectLiteralExpression => objectLiteral
parenthesizedExpression => ('T_LPARAN') expressionSequence ('T_RPARAN')
postDecreaseExpression => [ postDecreaseExpression ] 'T_DEC'
postIncrementExpression => [ postIncrementExpression ] 'T_INC'
postfixExpression => ( postfixExpression (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )
powerExpression => [ powerExpression 'T_POWER' ] notExpression
preDecreaseExpression => ( 'T_DEC' preDecreaseExpression | preIncrementExpression )
preIncrementExpression => ( 'T_INC' preIncrementExpression | typeofExpression )
program => sourceElements
propertyAssignment => ( propertyExpressionAssignment | computedPropertyExpressionAssignment | propertyShorthand )
propertyAssignments => [ propertyAssignments ('T_COMMA') ] propertyAssignment
propertyExpressionAssignment => propertyName ('T_COLON') singleExpression
propertyName => ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') )
propertyShorthand => [ 'T_ELLIPSIS' ] singleExpression
relationalExpression => [ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression
reservedWord => ( keyword | K_TRUE | K_FALSE )
returnStatement => K_RETURN [ (#RULE_NO_LINE#) expressionSequence ] [ eos ]
singleExpression => [ singleExpression ('T_COMMA') ] assignmentExpression
sourceElement => statement
sourceElements => [ sourceElements ] statement
statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
statementList => [ statementList ] statement
superExpression => K_SUPER
switchStatement => K_SWITCH ('T_LPARAN') expressionSequence ('T_RPARAN') caseBlock
ternaryExpression => logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' singleExpression ]
thisExpression => K_THIS
throwStatement => K_THROW (#RULE_NO_LINE#) expressionSequence [ eos ]
tryStatement => K_TRY block ( catchProduction [ finallyProduction ] | finallyProduction )
typeofExpression => ( K_TYPEOF typeofExpression | voidExpression )
unaryMinusExpression => ( 'T_SUB' unaryMinusExpression | unaryPlusExpression )
unaryPlusExpression => ( 'T_ADD' unaryPlusExpression | preDecreaseExpression )
variableDeclaration => assignable [ 'T_ASSIGN' singleExpression ]
variableDeclarationList => [ variableDeclarationList ('T_COMMA') ] variableDeclaration
variableStatement => K_VAR variableDeclarationList [ eos ]
voidExpression => ( K_VOID voidExpression | deleteExpression )
whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement
withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement
==== NGA  ====
** Rule: additiveExpression => [ additiveExpression ( 'T_ADD' | 'T_SUB' ) ] multiplicativeExpression
-- Tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_LSQUARE' #NUMBER# 'T_DEC' #REGEX# K_NULL 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE K_NEW K_SUPER #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION K_THIS #ID# 
-- First-set tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_TYPEOF K_VOID 'T_LPARAN' K_DELETE #NUMBER# K_NEW K_SUPER #REGEX# #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION 'T_LSQUARE' K_THIS #ID# 
-- First-set rules: multiplicativeExpression additiveExpression 
Status #0 - additiveExpression => [ @ additiveExpression ( 'T_ADD' | 'T_SUB' ) ] multiplicativeExpression
  To #1:  additiveExpression
  To #2:  multiplicativeExpression
Status #1 - additiveExpression => [ additiveExpression @ ( 'T_ADD' | 'T_SUB' ) ] multiplicativeExpression
  To #3:  'T_SUB'
  To #4:  'T_ADD'
Status #2 [FINAL] - additiveExpression => [ additiveExpression ( 'T_ADD' | 'T_SUB' ) ] multiplicativeExpression @
Status #3 - additiveExpression => [ additiveExpression ( 'T_ADD' | 'T_SUB' @ ) ] multiplicativeExpression
  To #2:  multiplicativeExpression
Status #4 - additiveExpression => [ additiveExpression ( 'T_ADD' @ | 'T_SUB' ) ] multiplicativeExpression
  To #2:  multiplicativeExpression

** Rule: anonymousFunction => ( functionDecl | anoymousFunctionDecl | arrowFunction )
-- Tokens: 'T_LPARAN' K_FUNCTION #ID# 
-- First-set tokens: #ID# K_FUNCTION 'T_LPARAN' 
-- First-set rules: arrowFunction anoymousFunctionDecl functionDecl 
Status #0 - anonymousFunction => @ ( functionDecl | anoymousFunctionDecl | arrowFunction )
  To #1:  arrowFunction
  To #2:  functionDecl
  To #3:  anoymousFunctionDecl
Status #1 [FINAL] - anonymousFunction => ( functionDecl | anoymousFunctionDecl | arrowFunction @ )
Status #2 [FINAL] - anonymousFunction => ( functionDecl @ | anoymousFunctionDecl | arrowFunction )
Status #3 [FINAL] - anonymousFunction => ( functionDecl | anoymousFunctionDecl @ | arrowFunction )

** Rule: anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
-- Tokens: K_FUNCTION 
-- First-set tokens: K_FUNCTION 
-- First-set rules: 
Status #0 - anoymousFunctionDecl => @ K_FUNCTION ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
  To #1:  K_FUNCTION
Status #1 - anoymousFunctionDecl => K_FUNCTION @ ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
  To #2:  ('T_LPARAN')
Status #2 - anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') @ [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
  To #3:  ('T_RPARAN')
  To #4:  formalParameterList
Status #3 - anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') @ ('T_LBRACE') [ functionBody ] ('T_RBRACE')
  To #5:  ('T_LBRACE')
Status #4 - anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') [ formalParameterList @ ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
  To #3:  ('T_RPARAN')
Status #5 - anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') @ [ functionBody ] ('T_RBRACE')
  To #6:  ('T_RBRACE')
  To #7:  functionBody
Status #6 [FINAL] - anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE') @
Status #7 - anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody @ ] ('T_RBRACE')
  To #6:  ('T_RBRACE')

** Rule: argument => [ argument ('T_COMMA') ] [ ('T_ELLIPSIS') ] ( singleExpression | #ID# )
-- Tokens: #ID# 'T_ELLIPSIS' 'T_DEC' #REGEX# 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_LSQUARE' #NUMBER# K_NULL 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE K_NEW K_SUPER #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION K_THIS 
-- First-set tokens: #ID# 'T_DEC' 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' K_NULL 'T_INC' K_TYPEOF K_VOID 'T_LPARAN' K_DELETE 'T_ELLIPSIS' #NUMBER# K_NEW K_SUPER #REGEX# #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION 'T_LSQUARE' K_THIS 
-- First-set rules: singleExpression argument 
Status #0 - argument => [ @ argument ('T_COMMA') ] [ ('T_ELLIPSIS') ] ( singleExpression | #ID# )
  To #1:  argument
  To #2:  ('T_ELLIPSIS')
  To #3:  singleExpression
  To #4:  #ID#
Status #1 - argument => [ argument @ ('T_COMMA') ] [ ('T_ELLIPSIS') ] ( singleExpression | #ID# )
  To #5:  ('T_COMMA')
Status #2 - argument => [ argument ('T_COMMA') ] [ ('T_ELLIPSIS') @ ] ( singleExpression | #ID# )
  To #4:  #ID#
  To #3:  singleExpression
Status #3 [FINAL] - argument => [ argument ('T_COMMA') ] [ ('T_ELLIPSIS') ] ( singleExpression @ | #ID# )
Status #4 [FINAL] - argument => [ argument ('T_COMMA') ] [ ('T_ELLIPSIS') ] ( singleExpression | #ID# @ )
Status #5 - argument => [ argument ('T_COMMA') @ ] [ ('T_ELLIPSIS') ] ( singleExpression | #ID# )
  To #4:  #ID#
  To #2:  ('T_ELLIPSIS')
  To #3:  singleExpression

** Rule: arguments => ('T_LPARAN') [ argument ] ('T_RPARAN')
-- Tokens: 'T_LPARAN' 
-- First-set tokens: 'T_LPARAN' 
-- First-set rules: 
Status #0 - arguments => @ ('T_LPARAN') [ argument ] ('T_RPARAN')
  To #1:  ('T_LPARAN')
Status #1 - arguments => ('T_LPARAN') @ [ argument ] ('T_RPARAN')
  To #2:  ('T_RPARAN')
  To #3:  argument
Status #2 [FINAL] - arguments => ('T_LPARAN') [ argument ] ('T_RPARAN') @
Status #3 - arguments => ('T_LPARAN') [ argument @ ] ('T_RPARAN')
  To #2:  ('T_RPARAN')

** Rule: argumentsExpression => [ argumentsExpression ] arguments
-- Tokens: 'T_LPARAN' 
-- First-set tokens: 'T_LPARAN' 
-- First-set rules: arguments argumentsExpression 
Status #0 - argumentsExpression => [ @ argumentsExpression ] arguments
  To #1:  argumentsExpression
  To #2:  arguments
Status #1 - argumentsExpression => [ argumentsExpression @ ] arguments
  To #2:  arguments
Status #2 [FINAL] - argumentsExpression => [ argumentsExpression ] arguments @

** Rule: arrayElement => [ 'T_ELLIPSIS' ] singleExpression
-- Tokens: 'T_ELLIPSIS' 'T_DEC' #REGEX# 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_LSQUARE' #NUMBER# K_NULL 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE K_NEW K_SUPER #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION K_THIS #ID# 
-- First-set tokens: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS K_TRUE #STRING# K_SUPER K_NEW K_DELETE K_VOID K_TYPEOF 'T_INC' 'T_LPARAN' K_NULL #NUMBER# 'T_LSQUARE' 'T_SUB' 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' #REGEX# 'T_DEC' 'T_ELLIPSIS' 
-- First-set rules: singleExpression 
Status #0 - arrayElement => [ @ 'T_ELLIPSIS' ] singleExpression
  To #1:  'T_ELLIPSIS'
  To #2:  singleExpression
Status #1 - arrayElement => [ 'T_ELLIPSIS' @ ] singleExpression
  To #2:  singleExpression
Status #2 [FINAL] - arrayElement => [ 'T_ELLIPSIS' ] singleExpression @

** Rule: arrayLiteral => ('T_LSQUARE') [ elementList ] ('T_RSQUARE')
-- Tokens: 'T_LSQUARE' 
-- First-set tokens: 'T_LSQUARE' 
-- First-set rules: 
Status #0 - arrayLiteral => @ ('T_LSQUARE') [ elementList ] ('T_RSQUARE')
  To #1:  ('T_LSQUARE')
Status #1 - arrayLiteral => ('T_LSQUARE') @ [ elementList ] ('T_RSQUARE')
  To #2:  ('T_RSQUARE')
  To #3:  elementList
Status #2 [FINAL] - arrayLiteral => ('T_LSQUARE') [ elementList ] ('T_RSQUARE') @
Status #3 - arrayLiteral => ('T_LSQUARE') [ elementList @ ] ('T_RSQUARE')
  To #2:  ('T_RSQUARE')

** Rule: arrayLiteralExpression => arrayLiteral
-- Tokens: 'T_LSQUARE' 
-- First-set tokens: 'T_LSQUARE' 
-- First-set rules: arrayLiteral 
Status #0 - arrayLiteralExpression => @ arrayLiteral
  To #1:  arrayLiteral
Status #1 [FINAL] - arrayLiteralExpression => arrayLiteral @

** Rule: arrowFunction => arrowFunctionParameters ('T_ARROW') arrowFunctionBody
-- Tokens: #ID# 'T_LPARAN' 
-- First-set tokens: 'T_LPARAN' #ID# 
-- First-set rules: arrowFunctionParameters 
Status #0 - arrowFunction => @ arrowFunctionParameters ('T_ARROW') arrowFunctionBody
  To #1:  arrowFunctionParameters
Status #1 - arrowFunction => arrowFunctionParameters @ ('T_ARROW') arrowFunctionBody
  To #2:  ('T_ARROW')
Status #2 - arrowFunction => arrowFunctionParameters ('T_ARROW') @ arrowFunctionBody
  To #3:  arrowFunctionBody
Status #3 [FINAL] - arrowFunction => arrowFunctionParameters ('T_ARROW') arrowFunctionBody @

** Rule: arrowFunctionBody => ( singleExpression | 'T_LBRACE' [ functionBody ] 'T_RBRACE' )
-- Tokens: 'T_LBRACE' 'T_BIT_NOT' 'T_LOG_NOT' 'T_ADD' 'T_SUB' 'T_LSQUARE' #NUMBER# 'T_DEC' #REGEX# K_NULL 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE K_NEW K_SUPER #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION K_THIS #ID# 
-- First-set tokens: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS K_TRUE #STRING# K_SUPER K_NEW K_DELETE K_VOID K_TYPEOF 'T_INC' 'T_LPARAN' K_NULL #REGEX# 'T_DEC' #NUMBER# 'T_LSQUARE' 'T_SUB' 'T_ADD' 'T_LOG_NOT' 'T_BIT_NOT' 'T_LBRACE' 
-- First-set rules: singleExpression 
Status #0 - arrowFunctionBody => @ ( singleExpression | 'T_LBRACE' [ functionBody ] 'T_RBRACE' )
  To #1:  'T_LBRACE'
  To #2:  singleExpression
Status #1 - arrowFunctionBody => ( singleExpression | 'T_LBRACE' @ [ functionBody ] 'T_RBRACE' )
  To #3:  'T_RBRACE'
  To #4:  functionBody
Status #2 [FINAL] - arrowFunctionBody => ( singleExpression @ | 'T_LBRACE' [ functionBody ] 'T_RBRACE' )
Status #3 [FINAL] - arrowFunctionBody => ( singleExpression | 'T_LBRACE' [ functionBody ] 'T_RBRACE' @ )
Status #4 - arrowFunctionBody => ( singleExpression | 'T_LBRACE' [ functionBody @ ] 'T_RBRACE' )
  To #3:  'T_RBRACE'

** Rule: arrowFunctionParameters => ( #ID# | ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') )
-- Tokens: #ID# 'T_LPARAN' 
-- First-set tokens: 'T_LPARAN' #ID# 
-- First-set rules: 
Status #0 - arrowFunctionParameters => @ ( #ID# | ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') )
  To #1:  ('T_LPARAN')
  To #2:  #ID#
Status #1 - arrowFunctionParameters => ( #ID# | ('T_LPARAN') @ [ formalParameterList ] ('T_RPARAN') )
  To #3:  ('T_RPARAN')
  To #4:  formalParameterList
Status #2 [FINAL] - arrowFunctionParameters => ( #ID# @ | ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') )
Status #3 [FINAL] - arrowFunctionParameters => ( #ID# | ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') @ )
Status #4 - arrowFunctionParameters => ( #ID# | ('T_LPARAN') [ formalParameterList @ ] ('T_RPARAN') )
  To #3:  ('T_RPARAN')

** Rule: assignable => ( #ID# | arrayLiteral | objectLiteral )
-- Tokens: #ID# 'T_LBRACE' 'T_LSQUARE' 
-- First-set tokens: 'T_LSQUARE' 'T_LBRACE' #ID# 
-- First-set rules: objectLiteral arrayLiteral 
Status #0 - assignable => @ ( #ID# | arrayLiteral | objectLiteral )
  To #1:  objectLiteral
  To #2:  #ID#
  To #3:  arrayLiteral
Status #1 [FINAL] - assignable => ( #ID# | arrayLiteral | objectLiteral @ )
Status #2 [FINAL] - assignable => ( #ID# @ | arrayLiteral | objectLiteral )
Status #3 [FINAL] - assignable => ( #ID# | arrayLiteral @ | objectLiteral )

** Rule: assignmentExpression => [ assignmentExpression 'T_ASSIGN' ] assignmentOperatorExpression
-- Tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_LSQUARE' #NUMBER# 'T_DEC' #REGEX# K_NULL 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE K_NEW K_SUPER #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION K_THIS #ID# 
-- First-set tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_TYPEOF K_VOID 'T_LPARAN' K_DELETE #NUMBER# K_NEW K_SUPER #REGEX# #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION 'T_LSQUARE' K_THIS #ID# 
-- First-set rules: assignmentOperatorExpression assignmentExpression 
Status #0 - assignmentExpression => [ @ assignmentExpression 'T_ASSIGN' ] assignmentOperatorExpression
  To #1:  assignmentExpression
  To #2:  assignmentOperatorExpression
Status #1 - assignmentExpression => [ assignmentExpression @ 'T_ASSIGN' ] assignmentOperatorExpression
  To #3:  'T_ASSIGN'
Status #2 [FINAL] - assignmentExpression => [ assignmentExpression 'T_ASSIGN' ] assignmentOperatorExpression @
Status #3 - assignmentExpression => [ assignmentExpression 'T_ASSIGN' @ ] assignmentOperatorExpression
  To #2:  assignmentOperatorExpression

** Rule: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
-- Tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_LSQUARE' #NUMBER# 'T_DEC' #REGEX# K_NULL 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE K_NEW K_SUPER #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION K_THIS #ID# 
-- First-set tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_TYPEOF K_VOID 'T_LPARAN' K_DELETE #NUMBER# K_NEW K_SUPER #REGEX# #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION 'T_LSQUARE' K_THIS #ID# 
-- First-set rules: ternaryExpression assignmentOperatorExpression 
Status #0 - assignmentOperatorExpression => [ @ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
  To #1:  assignmentOperatorExpression
  To #2:  ternaryExpression
Status #1 - assignmentOperatorExpression => [ assignmentOperatorExpression @ ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
  To #3:  'T_ASSIGN_POWER'
  To #4:  'T_ASSIGN_ADD'
  To #5:  'T_ASSIGN_SUB'
  To #6:  'T_ASSIGN_MUL'
  To #7:  'T_ASSIGN_DIV'
  To #8:  'T_ASSIGN_MOD'
  To #9:  'T_ASSIGN_LSHIFT'
  To #10:  'T_ASSIGN_RSHIFT'
  To #11:  'T_ASSIGN_URSHIFT'
  To #12:  'T_ASSIGN_AND'
  To #13:  'T_ASSIGN_OR'
  To #14:  'T_ASSIGN_XOR'
Status #2 [FINAL] - assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
Status #3 - assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' @ ) ] ternaryExpression
  To #2:  ternaryExpression
Status #4 - assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' @ | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
  To #2:  ternaryExpression
Status #5 - assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' @ | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
  To #2:  ternaryExpression
Status #6 - assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' @ | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
  To #2:  ternaryExpression
Status #7 - assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' @ | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
  To #2:  ternaryExpression
Status #8 - assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' @ | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
  To #2:  ternaryExpression
Status #9 - assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' @ | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
  To #2:  ternaryExpression
Status #10 - assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' @ | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
  To #2:  ternaryExpression
Status #11 - assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' @ | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
  To #2:  ternaryExpression
Status #12 - assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' @ | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
  To #2:  ternaryExpression
Status #13 - assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' @ | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
  To #2:  ternaryExpression
Status #14 - assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' @ | 'T_ASSIGN_POWER' ) ] ternaryExpression
  To #2:  ternaryExpression

** Rule: bitAndExpression => [ bitAndExpression 'T_BIT_AND' ] equalityExpression
-- Tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_LSQUARE' #NUMBER# 'T_DEC' #REGEX# K_NULL 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE K_NEW K_SUPER #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION K_THIS #ID# 
-- First-set tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_TYPEOF K_VOID 'T_LPARAN' K_DELETE #NUMBER# K_NEW K_SUPER #REGEX# #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION 'T_LSQUARE' K_THIS #ID# 
-- First-set rules: equalityExpression bitAndExpression 
Status #0 - bitAndExpression => [ @ bitAndExpression 'T_BIT_AND' ] equalityExpression
  To #1:  bitAndExpression
  To #2:  equalityExpression
Status #1 - bitAndExpression => [ bitAndExpression @ 'T_BIT_AND' ] equalityExpression
  To #3:  'T_BIT_AND'
Status #2 [FINAL] - bitAndExpression => [ bitAndExpression 'T_BIT_AND' ] equalityExpression @
Status #3 - bitAndExpression => [ bitAndExpression 'T_BIT_AND' @ ] equalityExpression
  To #2:  equalityExpression

** Rule: bitNotExpression => ( 'T_BIT_NOT' bitNotExpression | unaryMinusExpression )
-- Tokens: 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_LSQUARE' 'T_ADD' #NUMBER# 'T_DEC' #REGEX# K_NULL 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE K_NEW K_SUPER #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION K_THIS #ID# 
-- First-set tokens: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS K_TRUE #STRING# K_SUPER K_NEW K_DELETE K_VOID K_TYPEOF 'T_INC' 'T_LPARAN' K_NULL #REGEX# 'T_DEC' #NUMBER# 'T_ADD' 'T_LSQUARE' 'T_SUB' 'T_LBRACE' 'T_BIT_NOT' 
-- First-set rules: unaryMinusExpression 
Status #0 - bitNotExpression => @ ( 'T_BIT_NOT' bitNotExpression | unaryMinusExpression )
  To #1:  unaryMinusExpression
  To #2:  'T_BIT_NOT'
Status #1 [FINAL] - bitNotExpression => ( 'T_BIT_NOT' bitNotExpression | unaryMinusExpression @ )
Status #2 - bitNotExpression => ( 'T_BIT_NOT' @ bitNotExpression | unaryMinusExpression )
  To #3:  bitNotExpression
Status #3 [FINAL] - bitNotExpression => ( 'T_BIT_NOT' bitNotExpression @ | unaryMinusExpression )

** Rule: bitOrExpression => [ bitOrExpression 'T_BIT_OR' ] bitXOrExpression
-- Tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_LSQUARE' #NUMBER# 'T_DEC' #REGEX# K_NULL 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE K_NEW K_SUPER #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION K_THIS #ID# 
-- First-set tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_TYPEOF K_VOID 'T_LPARAN' K_DELETE #NUMBER# K_NEW K_SUPER #REGEX# #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION 'T_LSQUARE' K_THIS #ID# 
-- First-set rules: bitXOrExpression bitOrExpression 
Status #0 - bitOrExpression => [ @ bitOrExpression 'T_BIT_OR' ] bitXOrExpression
  To #1:  bitOrExpression
  To #2:  bitXOrExpression
Status #1 - bitOrExpression => [ bitOrExpression @ 'T_BIT_OR' ] bitXOrExpression
  To #3:  'T_BIT_OR'
Status #2 [FINAL] - bitOrExpression => [ bitOrExpression 'T_BIT_OR' ] bitXOrExpression @
Status #3 - bitOrExpression => [ bitOrExpression 'T_BIT_OR' @ ] bitXOrExpression
  To #2:  bitXOrExpression

** Rule: bitShiftExpression => [ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression
-- Tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_LSQUARE' #NUMBER# 'T_DEC' #REGEX# K_NULL 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE K_NEW K_SUPER #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION K_THIS #ID# 
-- First-set tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_TYPEOF K_VOID 'T_LPARAN' K_DELETE #NUMBER# K_NEW K_SUPER #REGEX# #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION 'T_LSQUARE' K_THIS #ID# 
-- First-set rules: coalesceExpression bitShiftExpression 
Status #0 - bitShiftExpression => [ @ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression
  To #1:  bitShiftExpression
  To #2:  coalesceExpression
Status #1 - bitShiftExpression => [ bitShiftExpression @ ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression
  To #3:  'T_URSHIFT'
  To #4:  'T_LSHIFT'
  To #5:  'T_RSHIFT'
Status #2 [FINAL] - bitShiftExpression => [ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression @
Status #3 - bitShiftExpression => [ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' @ ) ] coalesceExpression
  To #2:  coalesceExpression
Status #4 - bitShiftExpression => [ bitShiftExpression ( 'T_LSHIFT' @ | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression
  To #2:  coalesceExpression
Status #5 - bitShiftExpression => [ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' @ | 'T_URSHIFT' ) ] coalesceExpression
  To #2:  coalesceExpression

** Rule: bitXOrExpression => [ bitXOrExpression 'T_BIT_XOR' ] bitAndExpression
-- Tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_LSQUARE' #NUMBER# 'T_DEC' #REGEX# K_NULL 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE K_NEW K_SUPER #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION K_THIS #ID# 
-- First-set tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_TYPEOF K_VOID 'T_LPARAN' K_DELETE #NUMBER# K_NEW K_SUPER #REGEX# #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION 'T_LSQUARE' K_THIS #ID# 
-- First-set rules: bitAndExpression bitXOrExpression 
Status #0 - bitXOrExpression => [ @ bitXOrExpression 'T_BIT_XOR' ] bitAndExpression
  To #1:  bitXOrExpression
  To #2:  bitAndExpression
Status #1 - bitXOrExpression => [ bitXOrExpression @ 'T_BIT_XOR' ] bitAndExpression
  To #3:  'T_BIT_XOR'
Status #2 [FINAL] - bitXOrExpression => [ bitXOrExpression 'T_BIT_XOR' ] bitAndExpression @
Status #3 - bitXOrExpression => [ bitXOrExpression 'T_BIT_XOR' @ ] bitAndExpression
  To #2:  bitAndExpression

** Rule: block => ('T_LBRACE') [ statementList ] ('T_RBRACE')
-- Tokens: 'T_LBRACE' 
-- First-set tokens: 'T_LBRACE' 
-- First-set rules: 
Status #0 - block => @ ('T_LBRACE') [ statementList ] ('T_RBRACE')
  To #1:  ('T_LBRACE')
Status #1 - block => ('T_LBRACE') @ [ statementList ] ('T_RBRACE')
  To #2:  ('T_RBRACE')
  To #3:  statementList
Status #2 [FINAL] - block => ('T_LBRACE') [ statementList ] ('T_RBRACE') @
Status #3 - block => ('T_LBRACE') [ statementList @ ] ('T_RBRACE')
  To #2:  ('T_RBRACE')

** Rule: breakStatement => K_BREAK [ (#RULE_NO_LINE#) #ID# ] [ eos ]
-- Tokens: K_BREAK 
-- First-set tokens: K_BREAK 
-- First-set rules: 
Status #0 - breakStatement => @ K_BREAK [ (#RULE_NO_LINE#) #ID# ] [ eos ]
  To #1:  K_BREAK
Status #1 [FINAL] - breakStatement => K_BREAK @ [ (#RULE_NO_LINE#) #ID# ] [ eos ]
  To #2:  eos
  To #3:  (#RULE_NO_LINE#)
Status #2 [FINAL] - breakStatement => K_BREAK [ (#RULE_NO_LINE#) #ID# ] [ eos @ ]
Status #3 - breakStatement => K_BREAK [ (#RULE_NO_LINE#) @ #ID# ] [ eos ]
  To #4:  #ID#
Status #4 [FINAL] - breakStatement => K_BREAK [ (#RULE_NO_LINE#) #ID# @ ] [ eos ]
  To #2:  eos

** Rule: caseBlock => ('T_LBRACE') [ caseClauses ] [ defaultClause [ caseClauses ] ] ('T_RBRACE')
-- Tokens: 'T_LBRACE' 
-- First-set tokens: 'T_LBRACE' 
-- First-set rules: 
Status #0 - caseBlock => @ ('T_LBRACE') [ caseClauses ] [ defaultClause [ caseClauses ] ] ('T_RBRACE')
  To #1:  ('T_LBRACE')
Status #1 - caseBlock => ('T_LBRACE') @ [ caseClauses ] [ defaultClause [ caseClauses ] ] ('T_RBRACE')
  To #2:  ('T_RBRACE')
  To #3:  caseClauses
  To #4:  defaultClause
Status #2 [FINAL] - caseBlock => ('T_LBRACE') [ caseClauses ] [ defaultClause [ caseClauses ] ] ('T_RBRACE') @
Status #3 - caseBlock => ('T_LBRACE') [ caseClauses @ ] [ defaultClause [ caseClauses ] ] ('T_RBRACE')
  To #2:  ('T_RBRACE')
  To #4:  defaultClause
Status #4 - caseBlock => ('T_LBRACE') [ caseClauses ] [ defaultClause @ [ caseClauses ] ] ('T_RBRACE')
  To #2:  ('T_RBRACE')
  To #5:  caseClauses
Status #5 - caseBlock => ('T_LBRACE') [ caseClauses ] [ defaultClause [ caseClauses @ ] ] ('T_RBRACE')
  To #2:  ('T_RBRACE')

** Rule: caseClause => K_CASE expressionSequence 'T_COLON' [ statementList ]
-- Tokens: K_CASE 
-- First-set tokens: K_CASE 
-- First-set rules: 
Status #0 - caseClause => @ K_CASE expressionSequence 'T_COLON' [ statementList ]
  To #1:  K_CASE
Status #1 - caseClause => K_CASE @ expressionSequence 'T_COLON' [ statementList ]
  To #2:  expressionSequence
Status #2 - caseClause => K_CASE expressionSequence @ 'T_COLON' [ statementList ]
  To #3:  'T_COLON'
Status #3 [FINAL] - caseClause => K_CASE expressionSequence 'T_COLON' @ [ statementList ]
  To #4:  statementList
Status #4 [FINAL] - caseClause => K_CASE expressionSequence 'T_COLON' [ statementList @ ]

** Rule: caseClauses => caseClause [ caseClauses ]
-- Tokens: K_CASE 
-- First-set tokens: K_CASE 
-- First-set rules: caseClause 
Status #0 - caseClauses => @ caseClause [ caseClauses ]
  To #1:  caseClause
Status #1 [FINAL] - caseClauses => caseClause @ [ caseClauses ]
  To #2:  caseClauses
Status #2 [FINAL] - caseClauses => caseClause [ caseClauses @ ]

** Rule: catchProduction => K_CATCH [ ('T_LPARAN') [ assignable ] ('T_RPARAN') ] block
-- Tokens: K_CATCH 
-- First-set tokens: K_CATCH 
-- First-set rules: 
Status #0 - catchProduction => @ K_CATCH [ ('T_LPARAN') [ assignable ] ('T_RPARAN') ] block
  To #1:  K_CATCH
Status #1 - catchProduction => K_CATCH @ [ ('T_LPARAN') [ assignable ] ('T_RPARAN') ] block
  To #2:  block
  To #3:  ('T_LPARAN')
Status #2 [FINAL] - catchProduction => K_CATCH [ ('T_LPARAN') [ assignable ] ('T_RPARAN') ] block @
Status #3 - catchProduction => K_CATCH [ ('T_LPARAN') @ [ assignable ] ('T_RPARAN') ] block
  To #4:  ('T_RPARAN')
  To #5:  assignable
Status #4 - catchProduction => K_CATCH [ ('T_LPARAN') [ assignable ] ('T_RPARAN') @ ] block
  To #2:  block
Status #5 - catchProduction => K_CATCH [ ('T_LPARAN') [ assignable @ ] ('T_RPARAN') ] block
  To #4:  ('T_RPARAN')

** Rule: classDeclaration => K_CLASS #ID# classTail
-- Tokens: K_CLASS 
-- First-set tokens: K_CLASS 
-- First-set rules: 
Status #0 - classDeclaration => @ K_CLASS #ID# classTail
  To #1:  K_CLASS
Status #1 - classDeclaration => K_CLASS @ #ID# classTail
  To #2:  #ID#
Status #2 - classDeclaration => K_CLASS #ID# @ classTail
  To #3:  classTail
Status #3 [FINAL] - classDeclaration => K_CLASS #ID# classTail @

** Rule: classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' singleExpression )
-- Tokens: K_TRY 'T_SHARP' K_SUPER K_BREAK K_WITH K_FINALLY K_FUNCTION K_CONTINUE K_VOID K_WHILE K_THROW K_IN K_DELETE K_DEBUGGER K_IF K_VAR K_TYPEOF K_FOR K_DEFAULT K_ELSE K_CLASS K_DO K_TRUE K_NEW K_INSTANCEOF K_LET K_CATCH 'T_SEMI' K_SWITCH #ID# K_THIS K_FALSE #STRING# 'T_LSQUARE' K_CASE #NUMBER# K_RETURN 
-- First-set tokens: K_RETURN #NUMBER# 'T_LSQUARE' #STRING# K_THIS #ID# K_SWITCH 'T_SEMI' K_LET K_FALSE K_TRUE K_DO K_ELSE K_CLASS K_CATCH K_DEFAULT K_FOR K_IF K_DELETE K_THROW K_WHILE K_CASE K_CONTINUE K_FUNCTION K_VOID K_INSTANCEOF K_TYPEOF K_WITH K_VAR K_BREAK K_FINALLY K_NEW K_SUPER K_DEBUGGER 'T_SHARP' K_IN K_TRY 
-- First-set rules: propertyName emptyStatement methodDefinition 
Status #0 - classElement => @ ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' singleExpression )
  To #1:  propertyName
  To #2:  methodDefinition
  To #3:  emptyStatement
  To #4:  'T_SHARP'
Status #1 - classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName @ 'T_ASSIGN' singleExpression )
  To #5:  'T_ASSIGN'
Status #2 [FINAL] - classElement => ( methodDefinition @ | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' singleExpression )
Status #3 [FINAL] - classElement => ( methodDefinition | emptyStatement @ | [ 'T_SHARP' ] propertyName 'T_ASSIGN' singleExpression )
Status #4 - classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' @ ] propertyName 'T_ASSIGN' singleExpression )
  To #1:  propertyName
Status #5 - classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' @ singleExpression )
  To #6:  singleExpression
Status #6 [FINAL] - classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' singleExpression @ )

** Rule: classElements => [ classElements ('T_COMMA') ] classElement
-- Tokens: K_TRY 'T_SHARP' K_SUPER K_BREAK K_WITH K_FINALLY K_FUNCTION K_CONTINUE K_VOID K_WHILE K_THROW K_IN K_DELETE K_DEBUGGER K_IF K_VAR K_TYPEOF K_FOR K_DEFAULT K_ELSE K_CLASS K_DO K_TRUE K_NEW K_INSTANCEOF K_LET K_CATCH 'T_SEMI' K_SWITCH #ID# K_THIS K_FALSE #STRING# 'T_LSQUARE' K_CASE #NUMBER# K_RETURN 
-- First-set tokens: K_TRY K_SUPER K_BREAK K_WITH K_FINALLY K_FUNCTION K_CONTINUE K_VOID K_WHILE K_THROW K_IN K_DELETE K_DEBUGGER K_IF K_TYPEOF K_FOR K_VAR K_DEFAULT K_ELSE K_CLASS K_DO K_TRUE K_INSTANCEOF K_LET K_CATCH 'T_SHARP' 'T_SEMI' K_NEW K_SWITCH #ID# K_THIS K_FALSE 'T_LSQUARE' K_CASE #NUMBER# #STRING# K_RETURN 
-- First-set rules: classElement classElements 
Status #0 - classElements => [ @ classElements ('T_COMMA') ] classElement
  To #1:  classElements
  To #2:  classElement
Status #1 - classElements => [ classElements @ ('T_COMMA') ] classElement
  To #3:  ('T_COMMA')
Status #2 [FINAL] - classElements => [ classElements ('T_COMMA') ] classElement @
Status #3 - classElements => [ classElements ('T_COMMA') @ ] classElement
  To #2:  classElement

** Rule: classExpression => K_CLASS (#ID#) classTail
-- Tokens: K_CLASS 
-- First-set tokens: K_CLASS 
-- First-set rules: 
Status #0 - classExpression => @ K_CLASS (#ID#) classTail
  To #1:  K_CLASS
Status #1 - classExpression => K_CLASS @ (#ID#) classTail
  To #2:  (#ID#)
Status #2 - classExpression => K_CLASS (#ID#) @ classTail
  To #3:  classTail
Status #3 [FINAL] - classExpression => K_CLASS (#ID#) classTail @

** Rule: classTail => ('T_LBRACE') classElements ('T_RBRACE')
-- Tokens: 'T_LBRACE' 
-- First-set tokens: 'T_LBRACE' 
-- First-set rules: 
Status #0 - classTail => @ ('T_LBRACE') classElements ('T_RBRACE')
  To #1:  ('T_LBRACE')
Status #1 - classTail => ('T_LBRACE') @ classElements ('T_RBRACE')
  To #2:  classElements
Status #2 - classTail => ('T_LBRACE') classElements @ ('T_RBRACE')
  To #3:  ('T_RBRACE')
Status #3 [FINAL] - classTail => ('T_LBRACE') classElements ('T_RBRACE') @

** Rule: coalesceExpression => [ coalesceExpression 'T_COALESCE' ] additiveExpression
-- Tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_LSQUARE' #NUMBER# 'T_DEC' #REGEX# K_NULL 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE K_NEW K_SUPER #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION K_THIS #ID# 
-- First-set tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_TYPEOF K_VOID 'T_LPARAN' K_DELETE #NUMBER# K_NEW K_SUPER #REGEX# #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION 'T_LSQUARE' K_THIS #ID# 
-- First-set rules: additiveExpression coalesceExpression 
Status #0 - coalesceExpression => [ @ coalesceExpression 'T_COALESCE' ] additiveExpression
  To #1:  coalesceExpression
  To #2:  additiveExpression
Status #1 - coalesceExpression => [ coalesceExpression @ 'T_COALESCE' ] additiveExpression
  To #3:  'T_COALESCE'
Status #2 [FINAL] - coalesceExpression => [ coalesceExpression 'T_COALESCE' ] additiveExpression @
Status #3 - coalesceExpression => [ coalesceExpression 'T_COALESCE' @ ] additiveExpression
  To #2:  additiveExpression

** Rule: computedPropertyExpressionAssignment => ('T_LPARAN') singleExpression ('T_RPARAN') ('T_COLON') singleExpression
-- Tokens: 'T_LPARAN' 
-- First-set tokens: 'T_LPARAN' 
-- First-set rules: 
Status #0 - computedPropertyExpressionAssignment => @ ('T_LPARAN') singleExpression ('T_RPARAN') ('T_COLON') singleExpression
  To #1:  ('T_LPARAN')
Status #1 - computedPropertyExpressionAssignment => ('T_LPARAN') @ singleExpression ('T_RPARAN') ('T_COLON') singleExpression
  To #2:  singleExpression
Status #2 - computedPropertyExpressionAssignment => ('T_LPARAN') singleExpression @ ('T_RPARAN') ('T_COLON') singleExpression
  To #3:  ('T_RPARAN')
Status #3 - computedPropertyExpressionAssignment => ('T_LPARAN') singleExpression ('T_RPARAN') @ ('T_COLON') singleExpression
  To #4:  ('T_COLON')
Status #4 - computedPropertyExpressionAssignment => ('T_LPARAN') singleExpression ('T_RPARAN') ('T_COLON') @ singleExpression
  To #5:  singleExpression
Status #5 [FINAL] - computedPropertyExpressionAssignment => ('T_LPARAN') singleExpression ('T_RPARAN') ('T_COLON') singleExpression @

** Rule: continueStatement => K_CONTINUE [ (#RULE_NO_LINE#) #ID# ] [ eos ]
-- Tokens: K_CONTINUE 
-- First-set tokens: K_CONTINUE 
-- First-set rules: 
Status #0 - continueStatement => @ K_CONTINUE [ (#RULE_NO_LINE#) #ID# ] [ eos ]
  To #1:  K_CONTINUE
Status #1 [FINAL] - continueStatement => K_CONTINUE @ [ (#RULE_NO_LINE#) #ID# ] [ eos ]
  To #2:  eos
  To #3:  (#RULE_NO_LINE#)
Status #2 [FINAL] - continueStatement => K_CONTINUE [ (#RULE_NO_LINE#) #ID# ] [ eos @ ]
Status #3 - continueStatement => K_CONTINUE [ (#RULE_NO_LINE#) @ #ID# ] [ eos ]
  To #4:  #ID#
Status #4 [FINAL] - continueStatement => K_CONTINUE [ (#RULE_NO_LINE#) #ID# @ ] [ eos ]
  To #2:  eos

** Rule: debuggerStatement => K_DEBUGGER [ eos ]
-- Tokens: K_DEBUGGER 
-- First-set tokens: K_DEBUGGER 
-- First-set rules: 
Status #0 - debuggerStatement => @ K_DEBUGGER [ eos ]
  To #1:  K_DEBUGGER
Status #1 [FINAL] - debuggerStatement => K_DEBUGGER @ [ eos ]
  To #2:  eos
Status #2 [FINAL] - debuggerStatement => K_DEBUGGER [ eos @ ]

** Rule: defaultClause => K_DEFAULT 'T_COLON' [ statementList ]
-- Tokens: K_DEFAULT 
-- First-set tokens: K_DEFAULT 
-- First-set rules: 
Status #0 - defaultClause => @ K_DEFAULT 'T_COLON' [ statementList ]
  To #1:  K_DEFAULT
Status #1 - defaultClause => K_DEFAULT @ 'T_COLON' [ statementList ]
  To #2:  'T_COLON'
Status #2 [FINAL] - defaultClause => K_DEFAULT 'T_COLON' @ [ statementList ]
  To #3:  statementList
Status #3 [FINAL] - defaultClause => K_DEFAULT 'T_COLON' [ statementList @ ]

** Rule: deleteExpression => ( K_DELETE deleteExpression | newExpression )
-- Tokens: K_DELETE K_NEW K_SUPER #REGEX# K_NULL #STRING# 'T_LPARAN' K_TRUE #NUMBER# K_FALSE 'T_LSQUARE' K_FUNCTION K_THIS #ID# 'T_LBRACE' K_CLASS 
-- First-set tokens: K_CLASS 'T_LBRACE' #ID# K_THIS K_FUNCTION 'T_LSQUARE' K_FALSE #NUMBER# K_TRUE 'T_LPARAN' #STRING# K_NULL #REGEX# K_SUPER K_NEW K_DELETE 
-- First-set rules: newExpression 
Status #0 - deleteExpression => @ ( K_DELETE deleteExpression | newExpression )
  To #1:  newExpression
  To #2:  K_DELETE
Status #1 [FINAL] - deleteExpression => ( K_DELETE deleteExpression | newExpression @ )
Status #2 - deleteExpression => ( K_DELETE @ deleteExpression | newExpression )
  To #3:  deleteExpression
Status #3 [FINAL] - deleteExpression => ( K_DELETE deleteExpression @ | newExpression )

** Rule: doStatement => K_DO statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
-- Tokens: K_DO 
-- First-set tokens: K_DO 
-- First-set rules: 
Status #0 - doStatement => @ K_DO statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
  To #1:  K_DO
Status #1 - doStatement => K_DO @ statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
  To #2:  statement
Status #2 - doStatement => K_DO statement @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
  To #3:  K_WHILE
Status #3 - doStatement => K_DO statement K_WHILE @ ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
  To #4:  ('T_LPARAN')
Status #4 - doStatement => K_DO statement K_WHILE ('T_LPARAN') @ expressionSequence ('T_RPARAN') [ eos ]
  To #5:  expressionSequence
Status #5 - doStatement => K_DO statement K_WHILE ('T_LPARAN') expressionSequence @ ('T_RPARAN') [ eos ]
  To #6:  ('T_RPARAN')
Status #6 [FINAL] - doStatement => K_DO statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ [ eos ]
  To #7:  eos
Status #7 [FINAL] - doStatement => K_DO statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos @ ]

** Rule: elementList => [ elementList ('T_COMMA') ] arrayElement
-- Tokens: 'T_ELLIPSIS' 'T_DEC' #REGEX# 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_LSQUARE' #NUMBER# K_NULL 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE K_NEW K_SUPER #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION K_THIS #ID# 
-- First-set tokens: 'T_DEC' 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' K_NULL 'T_INC' K_TYPEOF K_VOID 'T_LPARAN' K_DELETE 'T_ELLIPSIS' #NUMBER# K_NEW K_SUPER #REGEX# #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION 'T_LSQUARE' K_THIS #ID# 
-- First-set rules: arrayElement elementList 
Status #0 - elementList => [ @ elementList ('T_COMMA') ] arrayElement
  To #1:  elementList
  To #2:  arrayElement
Status #1 - elementList => [ elementList @ ('T_COMMA') ] arrayElement
  To #3:  ('T_COMMA')
Status #2 [FINAL] - elementList => [ elementList ('T_COMMA') ] arrayElement @
Status #3 - elementList => [ elementList ('T_COMMA') @ ] arrayElement
  To #2:  arrayElement

** Rule: emptyStatement => 'T_SEMI'
-- Tokens: 'T_SEMI' 
-- First-set tokens: 'T_SEMI' 
-- First-set rules: 
Status #0 - emptyStatement => @ 'T_SEMI'
  To #1:  'T_SEMI'
Status #1 [FINAL] - emptyStatement => 'T_SEMI' @

** Rule: eos => ( ('T_SEMI') | #END# )
-- Tokens: 'T_SEMI' #END# 
-- First-set tokens: #END# 'T_SEMI' 
-- First-set rules: 
Status #0 - eos => @ ( ('T_SEMI') | #END# )
  To #1:  #END#
  To #2:  ('T_SEMI')
Status #1 [FINAL] - eos => ( ('T_SEMI') | #END# @ )
Status #2 [FINAL] - eos => ( ('T_SEMI') @ | #END# )

** Rule: equalityExpression => [ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression
-- Tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_LSQUARE' #NUMBER# 'T_DEC' #REGEX# K_NULL 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE K_NEW K_SUPER #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION K_THIS #ID# 
-- First-set tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_TYPEOF K_VOID 'T_LPARAN' K_DELETE #NUMBER# K_NEW K_SUPER #REGEX# #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION 'T_LSQUARE' K_THIS #ID# 
-- First-set rules: inExpression equalityExpression 
Status #0 - equalityExpression => [ @ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression
  To #1:  equalityExpression
  To #2:  inExpression
Status #1 - equalityExpression => [ equalityExpression @ ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression
  To #3:  'T_FNOT_EQUAL'
  To #4:  'T_EQUAL'
  To #5:  'T_NOT_EQUAL'
  To #6:  'T_FEQUAL'
Status #2 [FINAL] - equalityExpression => [ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression @
Status #3 - equalityExpression => [ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' @ ) ] inExpression
  To #2:  inExpression
Status #4 - equalityExpression => [ equalityExpression ( 'T_EQUAL' @ | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression
  To #2:  inExpression
Status #5 - equalityExpression => [ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' @ | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression
  To #2:  inExpression
Status #6 - equalityExpression => [ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' @ | 'T_FNOT_EQUAL' ) ] inExpression
  To #2:  inExpression

** Rule: expressionSequence => [ expressionSequence ('T_COMMA') ] singleExpression
-- Tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_LSQUARE' #NUMBER# 'T_DEC' #REGEX# K_NULL 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE K_NEW K_SUPER #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION K_THIS #ID# 
-- First-set tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_TYPEOF K_VOID 'T_LPARAN' K_DELETE #NUMBER# K_NEW K_SUPER #REGEX# #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION 'T_LSQUARE' K_THIS #ID# 
-- First-set rules: singleExpression expressionSequence 
Status #0 - expressionSequence => [ @ expressionSequence ('T_COMMA') ] singleExpression
  To #1:  expressionSequence
  To #2:  singleExpression
Status #1 - expressionSequence => [ expressionSequence @ ('T_COMMA') ] singleExpression
  To #3:  ('T_COMMA')
Status #2 [FINAL] - expressionSequence => [ expressionSequence ('T_COMMA') ] singleExpression @
Status #3 - expressionSequence => [ expressionSequence ('T_COMMA') @ ] singleExpression
  To #2:  singleExpression

** Rule: expressionStatement => expressionSequence [ eos ]
-- Tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_LSQUARE' #NUMBER# 'T_DEC' #REGEX# K_NULL 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE K_NEW K_SUPER #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION K_THIS #ID# 
-- First-set tokens: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS K_TRUE #STRING# K_SUPER K_NEW K_DELETE K_VOID K_TYPEOF 'T_INC' 'T_LPARAN' K_NULL #REGEX# 'T_DEC' #NUMBER# 'T_LSQUARE' 'T_SUB' 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 
-- First-set rules: expressionSequence 
Status #0 - expressionStatement => @ expressionSequence [ eos ]
  To #1:  expressionSequence
Status #1 [FINAL] - expressionStatement => expressionSequence @ [ eos ]
  To #2:  eos
Status #2 [FINAL] - expressionStatement => expressionSequence [ eos @ ]

** Rule: finallyProduction => K_FINALLY block
-- Tokens: K_FINALLY 
-- First-set tokens: K_FINALLY 
-- First-set rules: 
Status #0 - finallyProduction => @ K_FINALLY block
  To #1:  K_FINALLY
Status #1 - finallyProduction => K_FINALLY @ block
  To #2:  block
Status #2 [FINAL] - finallyProduction => K_FINALLY block @

** Rule: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement
-- Tokens: K_FOR 
-- First-set tokens: K_FOR 
-- First-set rules: 
Status #0 - forInStatement => @ K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement
  To #1:  K_FOR
Status #1 - forInStatement => K_FOR @ ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement
  To #2:  ('T_LPARAN')
Status #2 - forInStatement => K_FOR ('T_LPARAN') @ [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement
  To #3:  K_IN
  To #4:  singleExpression
  To #5:  K_VAR
Status #3 - forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN @ expressionSequence ('T_RPARAN') statement
  To #6:  expressionSequence
Status #4 - forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression @ | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement
  To #3:  K_IN
Status #5 - forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR @ variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement
  To #7:  variableDeclarationList
Status #6 - forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence @ ('T_RPARAN') statement
  To #8:  ('T_RPARAN')
Status #7 - forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList @ ) ] K_IN expressionSequence ('T_RPARAN') statement
  To #3:  K_IN
Status #8 - forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') @ statement
  To #9:  statement
Status #9 [FINAL] - forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement @

** Rule: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
-- Tokens: K_FOR 
-- First-set tokens: K_FOR 
-- First-set rules: 
Status #0 - forStatement => @ K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
  To #1:  K_FOR
Status #1 - forStatement => K_FOR @ ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
  To #2:  ('T_LPARAN')
Status #2 - forStatement => K_FOR ('T_LPARAN') @ [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
  To #3:  'T_SEMI'
  To #4:  expressionSequence
  To #5:  K_VAR
Status #3 - forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' @ [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
  To #6:  'T_SEMI'
  To #7:  expressionSequence
Status #4 - forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence @ | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
  To #3:  'T_SEMI'
Status #5 - forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR @ variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
  To #8:  variableDeclarationList
Status #6 - forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' @ [ expressionSequence ] ('T_RPARAN') statement
  To #9:  ('T_RPARAN')
  To #10:  expressionSequence
Status #7 - forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence @ ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
  To #6:  'T_SEMI'
Status #8 - forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList @ ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
  To #3:  'T_SEMI'
Status #9 - forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') @ statement
  To #11:  statement
Status #10 - forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence @ ] ('T_RPARAN') statement
  To #9:  ('T_RPARAN')
Status #11 [FINAL] - forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement @

** Rule: formalParameterArg => assignable
-- Tokens: #ID# 'T_LBRACE' 'T_LSQUARE' 
-- First-set tokens: 'T_LSQUARE' 'T_LBRACE' #ID# 
-- First-set rules: assignable 
Status #0 - formalParameterArg => @ assignable
  To #1:  assignable
Status #1 [FINAL] - formalParameterArg => assignable @

** Rule: formalParameterList => [ formalParameterList ('T_COMMA') ] assignable
-- Tokens: #ID# 'T_LBRACE' 'T_LSQUARE' 
-- First-set tokens: #ID# 'T_LBRACE' 'T_LSQUARE' 
-- First-set rules: assignable formalParameterList 
Status #0 - formalParameterList => [ @ formalParameterList ('T_COMMA') ] assignable
  To #1:  formalParameterList
  To #2:  assignable
Status #1 - formalParameterList => [ formalParameterList @ ('T_COMMA') ] assignable
  To #3:  ('T_COMMA')
Status #2 [FINAL] - formalParameterList => [ formalParameterList ('T_COMMA') ] assignable @
Status #3 - formalParameterList => [ formalParameterList ('T_COMMA') @ ] assignable
  To #2:  assignable

** Rule: functionBody => [ functionBody ] sourceElements
-- Tokens: 'T_LBRACE' K_THROW K_FUNCTION K_SWITCH #NUMBER# K_TRY #ID# K_WITH 'T_SEMI' K_CONTINUE 'T_ADD' K_TRUE 'T_LSQUARE' 'T_DEC' #REGEX# K_RETURN K_NULL 'T_SUB' 'T_LPARAN' K_NEW 'T_INC' K_WHILE K_VOID K_DELETE K_SUPER #STRING# K_FALSE K_CLASS 'T_BIT_NOT' K_DO K_THIS K_DEBUGGER K_IF K_VAR 'T_LOG_NOT' K_TYPEOF K_FOR K_BREAK 
-- First-set tokens: 'T_LBRACE' K_THROW K_FUNCTION #NUMBER# K_TRY #ID# K_WITH 'T_SEMI' K_CONTINUE 'T_ADD' K_TRUE 'T_LSQUARE' 'T_DEC' #REGEX# K_NULL 'T_SUB' 'T_LPARAN' K_SWITCH K_NEW 'T_INC' K_WHILE K_VOID K_DELETE K_SUPER K_RETURN #STRING# K_FALSE K_CLASS 'T_BIT_NOT' K_DO K_THIS K_DEBUGGER K_IF K_VAR 'T_LOG_NOT' K_TYPEOF K_FOR K_BREAK 
-- First-set rules: sourceElements functionBody 
Status #0 - functionBody => [ @ functionBody ] sourceElements
  To #1:  functionBody
  To #2:  sourceElements
Status #1 - functionBody => [ functionBody @ ] sourceElements
  To #2:  sourceElements
Status #2 [FINAL] - functionBody => [ functionBody ] sourceElements @

** Rule: functionDecl => functionDeclaration
-- Tokens: K_FUNCTION 
-- First-set tokens: K_FUNCTION 
-- First-set rules: functionDeclaration 
Status #0 - functionDecl => @ functionDeclaration
  To #1:  functionDeclaration
Status #1 [FINAL] - functionDecl => functionDeclaration @

** Rule: functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
-- Tokens: K_FUNCTION 
-- First-set tokens: K_FUNCTION 
-- First-set rules: 
Status #0 - functionDeclaration => @ K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
  To #1:  K_FUNCTION
Status #1 - functionDeclaration => K_FUNCTION @ #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
  To #2:  #ID#
Status #2 - functionDeclaration => K_FUNCTION #ID# @ ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
  To #3:  ('T_LPARAN')
Status #3 - functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') @ [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
  To #4:  ('T_RPARAN')
  To #5:  formalParameterList
Status #4 - functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') @ ('T_LBRACE') [ functionBody ] ('T_RBRACE')
  To #6:  ('T_LBRACE')
Status #5 - functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList @ ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
  To #4:  ('T_RPARAN')
Status #6 - functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') @ [ functionBody ] ('T_RBRACE')
  To #7:  ('T_RBRACE')
  To #8:  functionBody
Status #7 [FINAL] - functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE') @
Status #8 - functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody @ ] ('T_RBRACE')
  To #7:  ('T_RBRACE')

** Rule: functionExpression => ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
-- Tokens: K_SUPER #REGEX# K_NULL #STRING# 'T_LPARAN' K_TRUE #NUMBER# K_FALSE 'T_LSQUARE' K_FUNCTION K_THIS #ID# 'T_LBRACE' K_CLASS 
-- First-set tokens: K_CLASS #ID# K_THIS K_FUNCTION 'T_LBRACE' 'T_LSQUARE' K_FALSE #NUMBER# 'T_LPARAN' K_NULL #STRING# K_TRUE #REGEX# K_SUPER 
-- First-set rules: parenthesizedExpression objectLiteralExpression arrayLiteralExpression literalExpression superExpression anonymousFunction classExpression identifierExpression thisExpression 
Status #0 - functionExpression => @ ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
  To #1:  parenthesizedExpression
  To #2:  anonymousFunction
  To #3:  classExpression
  To #4:  thisExpression
  To #5:  identifierExpression
  To #6:  superExpression
  To #7:  literalExpression
  To #8:  arrayLiteralExpression
  To #9:  objectLiteralExpression
Status #1 [FINAL] - functionExpression => ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression @ )
Status #2 [FINAL] - functionExpression => ( anonymousFunction @ | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
Status #3 [FINAL] - functionExpression => ( anonymousFunction | classExpression @ | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
Status #4 [FINAL] - functionExpression => ( anonymousFunction | classExpression | thisExpression @ | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
Status #5 [FINAL] - functionExpression => ( anonymousFunction | classExpression | thisExpression | identifierExpression @ | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
Status #6 [FINAL] - functionExpression => ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression @ | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
Status #7 [FINAL] - functionExpression => ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression @ | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
Status #8 [FINAL] - functionExpression => ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression @ | objectLiteralExpression | parenthesizedExpression )
Status #9 [FINAL] - functionExpression => ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression @ | parenthesizedExpression )

** Rule: identifierExpression => #ID#
-- Tokens: #ID# 
-- First-set tokens: #ID# 
-- First-set rules: 
Status #0 - identifierExpression => @ #ID#
  To #1:  #ID#
Status #1 [FINAL] - identifierExpression => #ID# @

** Rule: identifierName => ( #ID# | reservedWord )
-- Tokens: #ID# K_SWITCH K_LET K_FALSE K_TRUE K_DO K_IF K_CLASS K_CATCH K_DEFAULT K_FOR K_THIS K_ELSE K_FUNCTION K_DELETE K_THROW K_WHILE K_CASE K_CONTINUE K_VOID K_RETURN K_INSTANCEOF K_TYPEOF K_WITH K_VAR K_BREAK K_FINALLY K_NEW K_SUPER K_DEBUGGER K_IN K_TRY 
-- First-set tokens: K_TRY K_IN K_DEBUGGER K_SUPER K_NEW K_FINALLY K_BREAK K_VAR K_WITH K_TYPEOF K_INSTANCEOF K_RETURN K_VOID K_CONTINUE K_CASE K_WHILE K_THROW K_DELETE K_FUNCTION K_ELSE K_THIS K_FOR K_DEFAULT K_CATCH K_CLASS K_IF K_DO K_TRUE K_FALSE K_LET K_SWITCH #ID# 
-- First-set rules: reservedWord 
Status #0 - identifierName => @ ( #ID# | reservedWord )
  To #1:  reservedWord
  To #2:  #ID#
Status #1 [FINAL] - identifierName => ( #ID# | reservedWord @ )
Status #2 [FINAL] - identifierName => ( #ID# @ | reservedWord )

** Rule: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement ]
-- Tokens: K_IF 
-- First-set tokens: K_IF 
-- First-set rules: 
Status #0 - ifStatement => @ K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement ]
  To #1:  K_IF
Status #1 - ifStatement => K_IF @ ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement ]
  To #2:  ('T_LPARAN')
Status #2 - ifStatement => K_IF ('T_LPARAN') @ expressionSequence ('T_RPARAN') statement [ K_ELSE statement ]
  To #3:  expressionSequence
Status #3 - ifStatement => K_IF ('T_LPARAN') expressionSequence @ ('T_RPARAN') statement [ K_ELSE statement ]
  To #4:  ('T_RPARAN')
Status #4 - ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement [ K_ELSE statement ]
  To #5:  statement
Status #5 [FINAL] - ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement @ [ K_ELSE statement ]
  To #6:  K_ELSE
Status #6 - ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE @ statement ]
  To #7:  statement
Status #7 [FINAL] - ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement @ ]

** Rule: inExpression => [ inExpression K_IN ] instanceofExpression
-- Tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_LSQUARE' #NUMBER# 'T_DEC' #REGEX# K_NULL 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE K_NEW K_SUPER #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION K_THIS #ID# 
-- First-set tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_TYPEOF K_VOID 'T_LPARAN' K_DELETE #NUMBER# K_NEW K_SUPER #REGEX# #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION 'T_LSQUARE' K_THIS #ID# 
-- First-set rules: instanceofExpression inExpression 
Status #0 - inExpression => [ @ inExpression K_IN ] instanceofExpression
  To #1:  inExpression
  To #2:  instanceofExpression
Status #1 - inExpression => [ inExpression @ K_IN ] instanceofExpression
  To #3:  K_IN
Status #2 [FINAL] - inExpression => [ inExpression K_IN ] instanceofExpression @
Status #3 - inExpression => [ inExpression K_IN @ ] instanceofExpression
  To #2:  instanceofExpression

** Rule: instanceofExpression => [ instanceofExpression K_INSTANCEOF ] relationalExpression
-- Tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_LSQUARE' #NUMBER# 'T_DEC' #REGEX# K_NULL 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE K_NEW K_SUPER #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION K_THIS #ID# 
-- First-set tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_TYPEOF K_VOID 'T_LPARAN' K_DELETE #NUMBER# K_NEW K_SUPER #REGEX# #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION 'T_LSQUARE' K_THIS #ID# 
-- First-set rules: relationalExpression instanceofExpression 
Status #0 - instanceofExpression => [ @ instanceofExpression K_INSTANCEOF ] relationalExpression
  To #1:  instanceofExpression
  To #2:  relationalExpression
Status #1 - instanceofExpression => [ instanceofExpression @ K_INSTANCEOF ] relationalExpression
  To #3:  K_INSTANCEOF
Status #2 [FINAL] - instanceofExpression => [ instanceofExpression K_INSTANCEOF ] relationalExpression @
Status #3 - instanceofExpression => [ instanceofExpression K_INSTANCEOF @ ] relationalExpression
  To #2:  relationalExpression

** Rule: iterationStatement => ( doStatement | whileStatement | forStatement | forInStatement )
-- Tokens: K_FOR K_WHILE K_DO 
-- First-set tokens: K_DO K_WHILE K_FOR 
-- First-set rules: forInStatement forStatement whileStatement doStatement 
Status #0 - iterationStatement => @ ( doStatement | whileStatement | forStatement | forInStatement )
  To #1:  forInStatement
  To #2:  doStatement
  To #3:  whileStatement
  To #4:  forStatement
Status #1 [FINAL] - iterationStatement => ( doStatement | whileStatement | forStatement | forInStatement @ )
Status #2 [FINAL] - iterationStatement => ( doStatement @ | whileStatement | forStatement | forInStatement )
Status #3 [FINAL] - iterationStatement => ( doStatement | whileStatement @ | forStatement | forInStatement )
Status #4 [FINAL] - iterationStatement => ( doStatement | whileStatement | forStatement @ | forInStatement )

** Rule: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
-- Tokens: K_IF K_CATCH K_DEFAULT K_THIS K_FUNCTION K_THROW K_WHILE K_SWITCH K_FOR K_CASE K_CONTINUE K_VOID K_RETURN K_INSTANCEOF K_TYPEOF K_WITH K_DO K_BREAK K_ELSE K_FINALLY K_NEW K_DEBUGGER K_LET K_VAR K_DELETE K_IN K_TRY K_CLASS K_SUPER 
-- First-set tokens: K_SUPER K_CLASS K_TRY K_IN K_DELETE K_VAR K_DEBUGGER K_NEW K_FINALLY K_ELSE K_DO K_WITH K_BREAK K_TYPEOF K_INSTANCEOF K_RETURN K_VOID K_CONTINUE K_CASE K_FOR K_SWITCH K_WHILE K_THROW K_FUNCTION K_THIS K_LET K_DEFAULT K_CATCH K_IF 
-- First-set rules: 
Status #0 - keyword => @ ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
  To #1:  K_LET
  To #2:  K_BREAK
  To #3:  K_DO
  To #4:  K_INSTANCEOF
  To #5:  K_TYPEOF
  To #6:  K_CASE
  To #7:  K_ELSE
  To #8:  K_NEW
  To #9:  K_VAR
  To #10:  K_CATCH
  To #11:  K_FINALLY
  To #12:  K_RETURN
  To #13:  K_VOID
  To #14:  K_CONTINUE
  To #15:  K_FOR
  To #16:  K_SWITCH
  To #17:  K_WHILE
  To #18:  K_DEBUGGER
  To #19:  K_FUNCTION
  To #20:  K_THIS
  To #21:  K_WITH
  To #22:  K_DEFAULT
  To #23:  K_IF
  To #24:  K_THROW
  To #25:  K_DELETE
  To #26:  K_IN
  To #27:  K_TRY
  To #28:  K_CLASS
  To #29:  K_SUPER
Status #1 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET @ )
Status #2 [FINAL] - keyword => ( K_BREAK @ | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #3 [FINAL] - keyword => ( K_BREAK | K_DO @ | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #4 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF @ | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #5 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF @ | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #6 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE @ | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #7 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE @ | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #8 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW @ | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #9 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR @ | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #10 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH @ | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #11 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY @ | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #12 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN @ | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #13 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID @ | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #14 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE @ | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #15 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR @ | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #16 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH @ | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #17 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE @ | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #18 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER @ | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #19 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION @ | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #20 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS @ | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #21 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH @ | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #22 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT @ | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #23 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF @ | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #24 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW @ | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #25 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE @ | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #26 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN @ | K_TRY | K_CLASS | K_SUPER | K_LET )
Status #27 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY @ | K_CLASS | K_SUPER | K_LET )
Status #28 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS @ | K_SUPER | K_LET )
Status #29 [FINAL] - keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER @ | K_LET )

** Rule: labelledStatement => #ID# 'T_COLON' statement
-- Tokens: #ID# 
-- First-set tokens: #ID# 
-- First-set rules: 
Status #0 - labelledStatement => @ #ID# 'T_COLON' statement
  To #1:  #ID#
Status #1 - labelledStatement => #ID# @ 'T_COLON' statement
  To #2:  'T_COLON'
Status #2 - labelledStatement => #ID# 'T_COLON' @ statement
  To #3:  statement
Status #3 [FINAL] - labelledStatement => #ID# 'T_COLON' statement @

** Rule: literal => ( K_NULL | K_TRUE | K_FALSE | #STRING# | #REGEX# | #NUMBER# )
-- Tokens: K_FALSE #NUMBER# K_NULL #STRING# K_TRUE #REGEX# 
-- First-set tokens: #REGEX# K_TRUE K_NULL #STRING# #NUMBER# K_FALSE 
-- First-set rules: 
Status #0 - literal => @ ( K_NULL | K_TRUE | K_FALSE | #STRING# | #REGEX# | #NUMBER# )
  To #1:  #NUMBER#
  To #2:  K_NULL
  To #3:  K_TRUE
  To #4:  K_FALSE
  To #5:  #STRING#
  To #6:  #REGEX#
Status #1 [FINAL] - literal => ( K_NULL | K_TRUE | K_FALSE | #STRING# | #REGEX# | #NUMBER# @ )
Status #2 [FINAL] - literal => ( K_NULL @ | K_TRUE | K_FALSE | #STRING# | #REGEX# | #NUMBER# )
Status #3 [FINAL] - literal => ( K_NULL | K_TRUE @ | K_FALSE | #STRING# | #REGEX# | #NUMBER# )
Status #4 [FINAL] - literal => ( K_NULL | K_TRUE | K_FALSE @ | #STRING# | #REGEX# | #NUMBER# )
Status #5 [FINAL] - literal => ( K_NULL | K_TRUE | K_FALSE | #STRING# @ | #REGEX# | #NUMBER# )
Status #6 [FINAL] - literal => ( K_NULL | K_TRUE | K_FALSE | #STRING# | #REGEX# @ | #NUMBER# )

** Rule: literalExpression => literal
-- Tokens: K_FALSE #NUMBER# K_NULL #STRING# K_TRUE #REGEX# 
-- First-set tokens: #REGEX# K_TRUE #STRING# K_NULL #NUMBER# K_FALSE 
-- First-set rules: literal 
Status #0 - literalExpression => @ literal
  To #1:  literal
Status #1 [FINAL] - literalExpression => literal @

** Rule: logicalAndExpression => [ logicalAndExpression 'T_LOG_AND' ] bitOrExpression
-- Tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_LSQUARE' #NUMBER# 'T_DEC' #REGEX# K_NULL 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE K_NEW K_SUPER #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION K_THIS #ID# 
-- First-set tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_TYPEOF K_VOID 'T_LPARAN' K_DELETE #NUMBER# K_NEW K_SUPER #REGEX# #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION 'T_LSQUARE' K_THIS #ID# 
-- First-set rules: bitOrExpression logicalAndExpression 
Status #0 - logicalAndExpression => [ @ logicalAndExpression 'T_LOG_AND' ] bitOrExpression
  To #1:  logicalAndExpression
  To #2:  bitOrExpression
Status #1 - logicalAndExpression => [ logicalAndExpression @ 'T_LOG_AND' ] bitOrExpression
  To #3:  'T_LOG_AND'
Status #2 [FINAL] - logicalAndExpression => [ logicalAndExpression 'T_LOG_AND' ] bitOrExpression @
Status #3 - logicalAndExpression => [ logicalAndExpression 'T_LOG_AND' @ ] bitOrExpression
  To #2:  bitOrExpression

** Rule: logicalOrExpression => [ logicalOrExpression 'T_LOG_OR' ] logicalAndExpression
-- Tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_LSQUARE' #NUMBER# 'T_DEC' #REGEX# K_NULL 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE K_NEW K_SUPER #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION K_THIS #ID# 
-- First-set tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_TYPEOF K_VOID 'T_LPARAN' K_DELETE #NUMBER# K_NEW K_SUPER #REGEX# #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION 'T_LSQUARE' K_THIS #ID# 
-- First-set rules: logicalAndExpression logicalOrExpression 
Status #0 - logicalOrExpression => [ @ logicalOrExpression 'T_LOG_OR' ] logicalAndExpression
  To #1:  logicalOrExpression
  To #2:  logicalAndExpression
Status #1 - logicalOrExpression => [ logicalOrExpression @ 'T_LOG_OR' ] logicalAndExpression
  To #3:  'T_LOG_OR'
Status #2 [FINAL] - logicalOrExpression => [ logicalOrExpression 'T_LOG_OR' ] logicalAndExpression @
Status #3 - logicalOrExpression => [ logicalOrExpression 'T_LOG_OR' @ ] logicalAndExpression
  To #2:  logicalAndExpression

** Rule: memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' [ 'T_SHARP' ] identifierName
-- Tokens: 'T_QUERY' 'T_DOT' 
-- First-set tokens: 'T_DOT' 'T_QUERY' 
-- First-set rules: memberDotExpression 
Status #0 - memberDotExpression => [ @ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' [ 'T_SHARP' ] identifierName
  To #1:  memberDotExpression
  To #2:  'T_QUERY'
  To #3:  'T_DOT'
Status #1 - memberDotExpression => [ memberDotExpression @ ] [ 'T_QUERY' ] 'T_DOT' [ 'T_SHARP' ] identifierName
  To #3:  'T_DOT'
  To #2:  'T_QUERY'
Status #2 - memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' @ ] 'T_DOT' [ 'T_SHARP' ] identifierName
  To #3:  'T_DOT'
Status #3 - memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' @ [ 'T_SHARP' ] identifierName
  To #4:  identifierName
  To #5:  'T_SHARP'
Status #4 [FINAL] - memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' [ 'T_SHARP' ] identifierName @
Status #5 - memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' [ 'T_SHARP' @ ] identifierName
  To #4:  identifierName

** Rule: memberIndexExpression => [ memberIndexExpression ] 'T_LSQUARE' expressionSequence 'T_RSQUARE'
-- Tokens: 'T_LSQUARE' 
-- First-set tokens: 'T_LSQUARE' 
-- First-set rules: memberIndexExpression 
Status #0 - memberIndexExpression => [ @ memberIndexExpression ] 'T_LSQUARE' expressionSequence 'T_RSQUARE'
  To #1:  memberIndexExpression
  To #2:  'T_LSQUARE'
Status #1 - memberIndexExpression => [ memberIndexExpression @ ] 'T_LSQUARE' expressionSequence 'T_RSQUARE'
  To #2:  'T_LSQUARE'
Status #2 - memberIndexExpression => [ memberIndexExpression ] 'T_LSQUARE' @ expressionSequence 'T_RSQUARE'
  To #3:  expressionSequence
Status #3 - memberIndexExpression => [ memberIndexExpression ] 'T_LSQUARE' expressionSequence @ 'T_RSQUARE'
  To #4:  'T_RSQUARE'
Status #4 [FINAL] - memberIndexExpression => [ memberIndexExpression ] 'T_LSQUARE' expressionSequence 'T_RSQUARE' @

** Rule: methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
-- Tokens: 'T_SHARP' K_RETURN #NUMBER# 'T_LSQUARE' #STRING# K_THIS K_ELSE #ID# K_SWITCH K_LET K_FALSE K_TRUE K_DO K_IF K_CLASS K_CATCH K_DEFAULT K_FOR K_FUNCTION K_DELETE K_THROW K_WHILE K_CASE K_CONTINUE K_VOID K_INSTANCEOF K_TYPEOF K_WITH K_VAR K_BREAK K_FINALLY K_NEW K_SUPER K_DEBUGGER K_IN K_TRY 
-- First-set tokens: K_TRY K_IN K_DEBUGGER K_SUPER K_NEW K_FINALLY K_BREAK K_VAR K_WITH K_TYPEOF K_INSTANCEOF K_VOID K_CONTINUE K_CASE K_WHILE K_THROW K_DELETE K_FUNCTION K_FOR K_DEFAULT K_CATCH K_CLASS K_IF K_DO K_TRUE K_FALSE K_LET K_SWITCH #ID# K_ELSE K_THIS #STRING# 'T_LSQUARE' #NUMBER# K_RETURN 'T_SHARP' 
-- First-set rules: propertyName 
Status #0 - methodDefinition => [ @ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
  To #1:  'T_SHARP'
  To #2:  propertyName
Status #1 - methodDefinition => [ 'T_SHARP' @ ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
  To #2:  propertyName
Status #2 - methodDefinition => [ 'T_SHARP' ] propertyName @ ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
  To #3:  ('T_LPARAN')
Status #3 - methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') @ [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
  To #4:  ('T_RPARAN')
  To #5:  formalParameterList
Status #4 - methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') @ ('T_LBRACE') [ functionBody ] ('T_RBRACE')
  To #6:  ('T_LBRACE')
Status #5 - methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList @ ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
  To #4:  ('T_RPARAN')
Status #6 - methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') @ [ functionBody ] ('T_RBRACE')
  To #7:  ('T_RBRACE')
  To #8:  functionBody
Status #7 [FINAL] - methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE') @
Status #8 - methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody @ ] ('T_RBRACE')
  To #7:  ('T_RBRACE')

** Rule: multiplicativeExpression => [ multiplicativeExpression ( 'T_MUL' | 'T_DIV' | 'T_MOD' ) ] powerExpression
-- Tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_LSQUARE' #NUMBER# 'T_DEC' #REGEX# K_NULL 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE K_NEW K_SUPER #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION K_THIS #ID# 
-- First-set tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_TYPEOF K_VOID 'T_LPARAN' K_DELETE #NUMBER# K_NEW K_SUPER #REGEX# #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION 'T_LSQUARE' K_THIS #ID# 
-- First-set rules: powerExpression multiplicativeExpression 
Status #0 - multiplicativeExpression => [ @ multiplicativeExpression ( 'T_MUL' | 'T_DIV' | 'T_MOD' ) ] powerExpression
  To #1:  multiplicativeExpression
  To #2:  powerExpression
Status #1 - multiplicativeExpression => [ multiplicativeExpression @ ( 'T_MUL' | 'T_DIV' | 'T_MOD' ) ] powerExpression
  To #3:  'T_MOD'
  To #4:  'T_MUL'
  To #5:  'T_DIV'
Status #2 [FINAL] - multiplicativeExpression => [ multiplicativeExpression ( 'T_MUL' | 'T_DIV' | 'T_MOD' ) ] powerExpression @
Status #3 - multiplicativeExpression => [ multiplicativeExpression ( 'T_MUL' | 'T_DIV' | 'T_MOD' @ ) ] powerExpression
  To #2:  powerExpression
Status #4 - multiplicativeExpression => [ multiplicativeExpression ( 'T_MUL' @ | 'T_DIV' | 'T_MOD' ) ] powerExpression
  To #2:  powerExpression
Status #5 - multiplicativeExpression => [ multiplicativeExpression ( 'T_MUL' | 'T_DIV' @ | 'T_MOD' ) ] powerExpression
  To #2:  powerExpression

** Rule: newExpression => ( K_NEW singleExpression [ arguments ] | postfixExpression )
-- Tokens: K_NEW K_SUPER #REGEX# K_NULL #STRING# 'T_LPARAN' K_TRUE #NUMBER# K_FALSE 'T_LSQUARE' K_FUNCTION K_THIS #ID# 'T_LBRACE' K_CLASS 
-- First-set tokens: K_CLASS 'T_LBRACE' #ID# K_THIS K_FUNCTION 'T_LSQUARE' K_FALSE #NUMBER# K_TRUE 'T_LPARAN' #STRING# K_NULL #REGEX# K_SUPER K_NEW 
-- First-set rules: postfixExpression 
Status #0 - newExpression => @ ( K_NEW singleExpression [ arguments ] | postfixExpression )
  To #1:  postfixExpression
  To #2:  K_NEW
Status #1 [FINAL] - newExpression => ( K_NEW singleExpression [ arguments ] | postfixExpression @ )
Status #2 - newExpression => ( K_NEW @ singleExpression [ arguments ] | postfixExpression )
  To #3:  singleExpression
Status #3 [FINAL] - newExpression => ( K_NEW singleExpression @ [ arguments ] | postfixExpression )
  To #4:  arguments
Status #4 [FINAL] - newExpression => ( K_NEW singleExpression [ arguments @ ] | postfixExpression )

** Rule: notExpression => ( 'T_LOG_NOT' notExpression | bitNotExpression )
-- Tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_LSQUARE' #NUMBER# 'T_DEC' #REGEX# K_NULL 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE K_NEW K_SUPER #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION K_THIS #ID# 
-- First-set tokens: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS K_TRUE #STRING# K_SUPER K_NEW K_DELETE K_VOID K_TYPEOF 'T_INC' 'T_LPARAN' K_NULL #REGEX# 'T_DEC' #NUMBER# 'T_LSQUARE' 'T_SUB' 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 
-- First-set rules: bitNotExpression 
Status #0 - notExpression => @ ( 'T_LOG_NOT' notExpression | bitNotExpression )
  To #1:  bitNotExpression
  To #2:  'T_LOG_NOT'
Status #1 [FINAL] - notExpression => ( 'T_LOG_NOT' notExpression | bitNotExpression @ )
Status #2 - notExpression => ( 'T_LOG_NOT' @ notExpression | bitNotExpression )
  To #3:  notExpression
Status #3 [FINAL] - notExpression => ( 'T_LOG_NOT' notExpression @ | bitNotExpression )

** Rule: numericLiteral => #NUMBER#
-- Tokens: #NUMBER# 
-- First-set tokens: #NUMBER# 
-- First-set rules: 
Status #0 - numericLiteral => @ #NUMBER#
  To #1:  #NUMBER#
Status #1 [FINAL] - numericLiteral => #NUMBER# @

** Rule: objectLiteral => ('T_LBRACE') [ propertyAssignments ] [ ('T_COMMA') ] ('T_RBRACE')
-- Tokens: 'T_LBRACE' 
-- First-set tokens: 'T_LBRACE' 
-- First-set rules: 
Status #0 - objectLiteral => @ ('T_LBRACE') [ propertyAssignments ] [ ('T_COMMA') ] ('T_RBRACE')
  To #1:  ('T_LBRACE')
Status #1 - objectLiteral => ('T_LBRACE') @ [ propertyAssignments ] [ ('T_COMMA') ] ('T_RBRACE')
  To #2:  ('T_RBRACE')
  To #3:  propertyAssignments
  To #4:  ('T_COMMA')
Status #2 [FINAL] - objectLiteral => ('T_LBRACE') [ propertyAssignments ] [ ('T_COMMA') ] ('T_RBRACE') @
Status #3 - objectLiteral => ('T_LBRACE') [ propertyAssignments @ ] [ ('T_COMMA') ] ('T_RBRACE')
  To #2:  ('T_RBRACE')
  To #4:  ('T_COMMA')
Status #4 - objectLiteral => ('T_LBRACE') [ propertyAssignments ] [ ('T_COMMA') @ ] ('T_RBRACE')
  To #2:  ('T_RBRACE')

** Rule: objectLiteralExpression => objectLiteral
-- Tokens: 'T_LBRACE' 
-- First-set tokens: 'T_LBRACE' 
-- First-set rules: objectLiteral 
Status #0 - objectLiteralExpression => @ objectLiteral
  To #1:  objectLiteral
Status #1 [FINAL] - objectLiteralExpression => objectLiteral @

** Rule: parenthesizedExpression => ('T_LPARAN') expressionSequence ('T_RPARAN')
-- Tokens: 'T_LPARAN' 
-- First-set tokens: 'T_LPARAN' 
-- First-set rules: 
Status #0 - parenthesizedExpression => @ ('T_LPARAN') expressionSequence ('T_RPARAN')
  To #1:  ('T_LPARAN')
Status #1 - parenthesizedExpression => ('T_LPARAN') @ expressionSequence ('T_RPARAN')
  To #2:  expressionSequence
Status #2 - parenthesizedExpression => ('T_LPARAN') expressionSequence @ ('T_RPARAN')
  To #3:  ('T_RPARAN')
Status #3 [FINAL] - parenthesizedExpression => ('T_LPARAN') expressionSequence ('T_RPARAN') @

** Rule: postDecreaseExpression => [ postDecreaseExpression ] 'T_DEC'
-- Tokens: 'T_DEC' 
-- First-set tokens: 'T_DEC' 
-- First-set rules: postDecreaseExpression 
Status #0 - postDecreaseExpression => [ @ postDecreaseExpression ] 'T_DEC'
  To #1:  postDecreaseExpression
  To #2:  'T_DEC'
Status #1 - postDecreaseExpression => [ postDecreaseExpression @ ] 'T_DEC'
  To #2:  'T_DEC'
Status #2 [FINAL] - postDecreaseExpression => [ postDecreaseExpression ] 'T_DEC' @

** Rule: postIncrementExpression => [ postIncrementExpression ] 'T_INC'
-- Tokens: 'T_INC' 
-- First-set tokens: 'T_INC' 
-- First-set rules: postIncrementExpression 
Status #0 - postIncrementExpression => [ @ postIncrementExpression ] 'T_INC'
  To #1:  postIncrementExpression
  To #2:  'T_INC'
Status #1 - postIncrementExpression => [ postIncrementExpression @ ] 'T_INC'
  To #2:  'T_INC'
Status #2 [FINAL] - postIncrementExpression => [ postIncrementExpression ] 'T_INC' @

** Rule: postfixExpression => ( postfixExpression (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )
-- Tokens: K_SUPER #REGEX# K_NULL #STRING# 'T_LPARAN' K_TRUE #NUMBER# K_FALSE 'T_LSQUARE' K_FUNCTION K_THIS #ID# 'T_LBRACE' K_CLASS 
-- First-set tokens: K_SUPER #REGEX# K_NULL 'T_LPARAN' K_TRUE K_FALSE #NUMBER# 'T_LSQUARE' K_FUNCTION #STRING# K_THIS #ID# 'T_LBRACE' K_CLASS 
-- First-set rules: functionExpression postfixExpression 
Status #0 - postfixExpression => @ ( postfixExpression (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )
  To #1:  functionExpression
  To #2:  postfixExpression
Status #1 [FINAL] - postfixExpression => ( postfixExpression (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression @ )
Status #2 - postfixExpression => ( postfixExpression @ (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )
  To #3:  (#RULE_NO_LINE#)
Status #3 - postfixExpression => ( postfixExpression (#RULE_NO_LINE#) @ ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )
  To #4:  postDecreaseExpression
  To #5:  memberIndexExpression
  To #6:  memberDotExpression
  To #7:  argumentsExpression
  To #8:  postIncrementExpression
Status #4 [FINAL] - postfixExpression => ( postfixExpression (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression @ ) | functionExpression )
Status #5 [FINAL] - postfixExpression => ( postfixExpression (#RULE_NO_LINE#) ( memberIndexExpression @ | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )
Status #6 [FINAL] - postfixExpression => ( postfixExpression (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression @ | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )
Status #7 [FINAL] - postfixExpression => ( postfixExpression (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression | argumentsExpression @ | postIncrementExpression | postDecreaseExpression ) | functionExpression )
Status #8 [FINAL] - postfixExpression => ( postfixExpression (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression @ | postDecreaseExpression ) | functionExpression )

** Rule: powerExpression => [ powerExpression 'T_POWER' ] notExpression
-- Tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_LSQUARE' #NUMBER# 'T_DEC' #REGEX# K_NULL 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE K_NEW K_SUPER #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION K_THIS #ID# 
-- First-set tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_TYPEOF K_VOID 'T_LPARAN' K_DELETE #NUMBER# K_NEW K_SUPER #REGEX# #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION 'T_LSQUARE' K_THIS #ID# 
-- First-set rules: notExpression powerExpression 
Status #0 - powerExpression => [ @ powerExpression 'T_POWER' ] notExpression
  To #1:  powerExpression
  To #2:  notExpression
Status #1 - powerExpression => [ powerExpression @ 'T_POWER' ] notExpression
  To #3:  'T_POWER'
Status #2 [FINAL] - powerExpression => [ powerExpression 'T_POWER' ] notExpression @
Status #3 - powerExpression => [ powerExpression 'T_POWER' @ ] notExpression
  To #2:  notExpression

** Rule: preDecreaseExpression => ( 'T_DEC' preDecreaseExpression | preIncrementExpression )
-- Tokens: 'T_DEC' K_NULL 'T_LPARAN' 'T_INC' K_TYPEOF 'T_LBRACE' K_VOID K_DELETE #REGEX# K_NEW K_SUPER #STRING# K_TRUE #NUMBER# K_CLASS K_FALSE 'T_LSQUARE' K_FUNCTION K_THIS #ID# 
-- First-set tokens: #ID# K_THIS K_FUNCTION 'T_LSQUARE' K_FALSE K_CLASS #NUMBER# K_TRUE #STRING# K_SUPER K_NEW #REGEX# K_DELETE K_VOID 'T_LBRACE' K_TYPEOF 'T_INC' 'T_LPARAN' K_NULL 'T_DEC' 
-- First-set rules: preIncrementExpression 
Status #0 - preDecreaseExpression => @ ( 'T_DEC' preDecreaseExpression | preIncrementExpression )
  To #1:  preIncrementExpression
  To #2:  'T_DEC'
Status #1 [FINAL] - preDecreaseExpression => ( 'T_DEC' preDecreaseExpression | preIncrementExpression @ )
Status #2 - preDecreaseExpression => ( 'T_DEC' @ preDecreaseExpression | preIncrementExpression )
  To #3:  preDecreaseExpression
Status #3 [FINAL] - preDecreaseExpression => ( 'T_DEC' preDecreaseExpression @ | preIncrementExpression )

** Rule: preIncrementExpression => ( 'T_INC' preIncrementExpression | typeofExpression )
-- Tokens: 'T_INC' K_TYPEOF 'T_LBRACE' K_VOID K_DELETE #REGEX# K_NEW K_SUPER K_NULL 'T_LPARAN' #STRING# K_TRUE #NUMBER# K_CLASS K_FALSE 'T_LSQUARE' K_FUNCTION K_THIS #ID# 
-- First-set tokens: #ID# K_THIS K_FUNCTION 'T_LSQUARE' K_FALSE K_CLASS #NUMBER# K_TRUE #STRING# 'T_LPARAN' K_NULL K_SUPER K_NEW #REGEX# K_DELETE K_VOID 'T_LBRACE' K_TYPEOF 'T_INC' 
-- First-set rules: typeofExpression 
Status #0 - preIncrementExpression => @ ( 'T_INC' preIncrementExpression | typeofExpression )
  To #1:  typeofExpression
  To #2:  'T_INC'
Status #1 [FINAL] - preIncrementExpression => ( 'T_INC' preIncrementExpression | typeofExpression @ )
Status #2 - preIncrementExpression => ( 'T_INC' @ preIncrementExpression | typeofExpression )
  To #3:  preIncrementExpression
Status #3 [FINAL] - preIncrementExpression => ( 'T_INC' preIncrementExpression @ | typeofExpression )

** Rule: program => sourceElements
-- Tokens: 'T_LBRACE' K_THROW K_FUNCTION K_SWITCH #NUMBER# K_TRY #ID# K_WITH 'T_SEMI' K_CONTINUE 'T_ADD' K_TRUE 'T_LSQUARE' 'T_DEC' #REGEX# K_RETURN K_NULL 'T_SUB' 'T_LPARAN' K_NEW 'T_INC' K_WHILE K_VOID K_DELETE K_SUPER #STRING# K_FALSE K_CLASS 'T_BIT_NOT' K_DO K_THIS K_DEBUGGER K_IF K_VAR 'T_LOG_NOT' K_TYPEOF K_FOR K_BREAK 
-- First-set tokens: K_BREAK K_FOR K_TYPEOF 'T_LOG_NOT' K_VAR K_IF K_DEBUGGER K_THIS K_DO 'T_BIT_NOT' K_CLASS K_FALSE #STRING# K_SUPER K_DELETE K_VOID K_WHILE 'T_INC' K_NEW 'T_LPARAN' 'T_SUB' K_NULL K_RETURN #REGEX# 'T_DEC' 'T_LSQUARE' K_TRUE 'T_ADD' K_CONTINUE 'T_SEMI' K_WITH #ID# K_TRY #NUMBER# K_SWITCH K_FUNCTION K_THROW 'T_LBRACE' 
-- First-set rules: sourceElements 
Status #0 - program => @ sourceElements
  To #1:  sourceElements
Status #1 [FINAL] - program => sourceElements @

** Rule: propertyAssignment => ( propertyExpressionAssignment | computedPropertyExpressionAssignment | propertyShorthand )
-- Tokens: K_INSTANCEOF K_THIS K_CLASS #STRING# K_SUPER K_DELETE K_VOID K_TYPEOF 'T_INC' K_NEW 'T_LPARAN' K_FALSE K_DO 'T_LSQUARE' 'T_SUB' 'T_LBRACE' 'T_ADD' 'T_DEC' 'T_ELLIPSIS' #NUMBER# K_SWITCH K_IF K_CATCH K_LET 'T_LOG_NOT' K_DEFAULT K_FUNCTION K_THROW K_NULL K_WHILE K_VAR K_FOR K_CASE K_CONTINUE #REGEX# K_RETURN K_WITH K_BREAK K_ELSE K_FINALLY K_DEBUGGER K_TRUE 'T_BIT_NOT' K_IN #ID# K_TRY 
-- First-set tokens: K_TRY K_IN K_DEBUGGER K_FINALLY K_BREAK K_WITH K_RETURN K_CONTINUE K_CASE K_VAR K_WHILE K_THROW K_DEFAULT K_CATCH K_IF K_SWITCH K_ELSE 'T_ELLIPSIS' 'T_DEC' #REGEX# 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_LSQUARE' #NUMBER# K_NULL K_DO 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE K_FOR K_NEW K_SUPER K_LET #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION K_THIS K_INSTANCEOF #ID# 
-- First-set rules: propertyShorthand computedPropertyExpressionAssignment propertyExpressionAssignment 
Status #0 - propertyAssignment => @ ( propertyExpressionAssignment | computedPropertyExpressionAssignment | propertyShorthand )
  To #1:  propertyShorthand
  To #2:  propertyExpressionAssignment
  To #3:  computedPropertyExpressionAssignment
Status #1 [FINAL] - propertyAssignment => ( propertyExpressionAssignment | computedPropertyExpressionAssignment | propertyShorthand @ )
Status #2 [FINAL] - propertyAssignment => ( propertyExpressionAssignment @ | computedPropertyExpressionAssignment | propertyShorthand )
Status #3 [FINAL] - propertyAssignment => ( propertyExpressionAssignment | computedPropertyExpressionAssignment @ | propertyShorthand )

** Rule: propertyAssignments => [ propertyAssignments ('T_COMMA') ] propertyAssignment
-- Tokens: K_INSTANCEOF K_THIS K_CLASS #STRING# K_SUPER K_DELETE K_VOID K_TYPEOF 'T_INC' K_NEW 'T_LPARAN' K_FALSE K_DO 'T_LSQUARE' 'T_SUB' 'T_LBRACE' 'T_ADD' 'T_DEC' 'T_ELLIPSIS' #NUMBER# K_SWITCH K_IF K_CATCH K_LET 'T_LOG_NOT' K_DEFAULT K_FUNCTION K_THROW K_NULL K_WHILE K_VAR K_FOR K_CASE K_CONTINUE #REGEX# K_RETURN K_WITH K_BREAK K_ELSE K_FINALLY K_DEBUGGER K_TRUE 'T_BIT_NOT' K_IN #ID# K_TRY 
-- First-set tokens: K_INSTANCEOF K_THIS K_CLASS K_SUPER K_DELETE K_VOID K_TYPEOF 'T_INC' 'T_LPARAN' K_FALSE K_DO 'T_LSQUARE' 'T_SUB' 'T_LBRACE' 'T_ADD' 'T_DEC' #NUMBER# K_SWITCH K_IF K_CATCH K_LET 'T_LOG_NOT' #STRING# K_DEFAULT K_FUNCTION K_THROW K_WHILE K_NULL K_VAR K_FOR K_NEW K_CASE K_CONTINUE 'T_ELLIPSIS' #REGEX# K_RETURN K_WITH K_BREAK K_ELSE K_FINALLY K_DEBUGGER K_TRUE 'T_BIT_NOT' K_IN #ID# K_TRY 
-- First-set rules: propertyAssignment propertyAssignments 
Status #0 - propertyAssignments => [ @ propertyAssignments ('T_COMMA') ] propertyAssignment
  To #1:  propertyAssignments
  To #2:  propertyAssignment
Status #1 - propertyAssignments => [ propertyAssignments @ ('T_COMMA') ] propertyAssignment
  To #3:  ('T_COMMA')
Status #2 [FINAL] - propertyAssignments => [ propertyAssignments ('T_COMMA') ] propertyAssignment @
Status #3 - propertyAssignments => [ propertyAssignments ('T_COMMA') @ ] propertyAssignment
  To #2:  propertyAssignment

** Rule: propertyExpressionAssignment => propertyName ('T_COLON') singleExpression
-- Tokens: #NUMBER# 'T_LSQUARE' #STRING# K_THIS K_ELSE #ID# K_SWITCH K_LET K_FALSE K_TRUE K_DO K_IF K_CLASS K_CATCH K_DEFAULT K_FOR K_FUNCTION K_DELETE K_THROW K_WHILE K_CASE K_CONTINUE K_VOID K_RETURN K_INSTANCEOF K_TYPEOF K_WITH K_VAR K_BREAK K_FINALLY K_NEW K_SUPER K_DEBUGGER K_IN K_TRY 
-- First-set tokens: K_TRY K_IN K_DEBUGGER K_SUPER K_NEW K_FINALLY K_BREAK K_VAR K_WITH K_TYPEOF K_INSTANCEOF K_RETURN K_VOID K_CONTINUE K_CASE K_WHILE K_THROW K_DELETE K_FUNCTION K_FOR K_DEFAULT K_CATCH K_CLASS K_IF K_DO K_TRUE K_FALSE K_LET K_SWITCH #ID# K_ELSE K_THIS #STRING# 'T_LSQUARE' #NUMBER# 
-- First-set rules: propertyName 
Status #0 - propertyExpressionAssignment => @ propertyName ('T_COLON') singleExpression
  To #1:  propertyName
Status #1 - propertyExpressionAssignment => propertyName @ ('T_COLON') singleExpression
  To #2:  ('T_COLON')
Status #2 - propertyExpressionAssignment => propertyName ('T_COLON') @ singleExpression
  To #3:  singleExpression
Status #3 [FINAL] - propertyExpressionAssignment => propertyName ('T_COLON') singleExpression @

** Rule: propertyName => ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') )
-- Tokens: #NUMBER# 'T_LSQUARE' #STRING# K_THIS K_ELSE #ID# K_SWITCH K_LET K_FALSE K_TRUE K_DO K_IF K_CLASS K_CATCH K_DEFAULT K_FOR K_FUNCTION K_DELETE K_THROW K_WHILE K_CASE K_CONTINUE K_VOID K_RETURN K_INSTANCEOF K_TYPEOF K_WITH K_VAR K_BREAK K_FINALLY K_NEW K_SUPER K_DEBUGGER K_IN K_TRY 
-- First-set tokens: K_TRY K_IN K_DEBUGGER K_SUPER K_NEW K_FINALLY K_BREAK K_VAR K_WITH K_TYPEOF K_INSTANCEOF K_RETURN K_VOID K_CONTINUE K_CASE K_WHILE K_THROW K_DELETE K_FUNCTION K_FOR K_DEFAULT K_CATCH K_CLASS K_IF K_DO K_TRUE K_FALSE K_LET K_SWITCH #ID# K_ELSE K_THIS #STRING# 'T_LSQUARE' #NUMBER# 
-- First-set rules: numericLiteral identifierName 
Status #0 - propertyName => @ ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') )
  To #1:  ('T_LSQUARE')
  To #2:  identifierName
  To #3:  #STRING#
  To #4:  numericLiteral
Status #1 - propertyName => ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') @ singleExpression ('T_RSQUARE') )
  To #5:  singleExpression
Status #2 [FINAL] - propertyName => ( identifierName @ | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') )
Status #3 [FINAL] - propertyName => ( identifierName | #STRING# @ | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') )
Status #4 [FINAL] - propertyName => ( identifierName | #STRING# | numericLiteral @ | ('T_LSQUARE') singleExpression ('T_RSQUARE') )
Status #5 - propertyName => ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression @ ('T_RSQUARE') )
  To #6:  ('T_RSQUARE')
Status #6 [FINAL] - propertyName => ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') @ )

** Rule: propertyShorthand => [ 'T_ELLIPSIS' ] singleExpression
-- Tokens: 'T_ELLIPSIS' 'T_DEC' #REGEX# 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_LSQUARE' #NUMBER# K_NULL 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE K_NEW K_SUPER #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION K_THIS #ID# 
-- First-set tokens: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS K_TRUE #STRING# K_SUPER K_NEW K_DELETE K_VOID K_TYPEOF 'T_INC' 'T_LPARAN' K_NULL #NUMBER# 'T_LSQUARE' 'T_SUB' 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' #REGEX# 'T_DEC' 'T_ELLIPSIS' 
-- First-set rules: singleExpression 
Status #0 - propertyShorthand => [ @ 'T_ELLIPSIS' ] singleExpression
  To #1:  'T_ELLIPSIS'
  To #2:  singleExpression
Status #1 - propertyShorthand => [ 'T_ELLIPSIS' @ ] singleExpression
  To #2:  singleExpression
Status #2 [FINAL] - propertyShorthand => [ 'T_ELLIPSIS' ] singleExpression @

** Rule: relationalExpression => [ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression
-- Tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_LSQUARE' #NUMBER# 'T_DEC' #REGEX# K_NULL 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE K_NEW K_SUPER #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION K_THIS #ID# 
-- First-set tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_TYPEOF K_VOID 'T_LPARAN' K_DELETE #NUMBER# K_NEW K_SUPER #REGEX# #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION 'T_LSQUARE' K_THIS #ID# 
-- First-set rules: bitShiftExpression relationalExpression 
Status #0 - relationalExpression => [ @ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression
  To #1:  relationalExpression
  To #2:  bitShiftExpression
Status #1 - relationalExpression => [ relationalExpression @ ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression
  To #3:  'T_GREATER_EQUAL'
  To #4:  'T_LESS'
  To #5:  'T_LESS_EQUAL'
  To #6:  'T_GREATER'
Status #2 [FINAL] - relationalExpression => [ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression @
Status #3 - relationalExpression => [ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' @ ) ] bitShiftExpression
  To #2:  bitShiftExpression
Status #4 - relationalExpression => [ relationalExpression ( 'T_LESS' @ | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression
  To #2:  bitShiftExpression
Status #5 - relationalExpression => [ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' @ | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression
  To #2:  bitShiftExpression
Status #6 - relationalExpression => [ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' @ | 'T_GREATER_EQUAL' ) ] bitShiftExpression
  To #2:  bitShiftExpression

** Rule: reservedWord => ( keyword | K_TRUE | K_FALSE )
-- Tokens: K_FALSE K_TRUE K_DO K_IF K_CLASS K_CATCH K_DEFAULT K_FOR K_THIS K_ELSE K_FUNCTION K_DELETE K_THROW K_WHILE K_CASE K_SWITCH K_LET K_CONTINUE K_VOID K_RETURN K_INSTANCEOF K_TYPEOF K_WITH K_VAR K_BREAK K_FINALLY K_NEW K_SUPER K_DEBUGGER K_IN K_TRY 
-- First-set tokens: K_TRY K_IN K_DEBUGGER K_SUPER K_NEW K_FINALLY K_BREAK K_VAR K_WITH K_TYPEOF K_INSTANCEOF K_RETURN K_VOID K_CONTINUE K_LET K_SWITCH K_CASE K_WHILE K_THROW K_DELETE K_FUNCTION K_ELSE K_THIS K_FOR K_DEFAULT K_CATCH K_CLASS K_IF K_DO K_TRUE K_FALSE 
-- First-set rules: keyword 
Status #0 - reservedWord => @ ( keyword | K_TRUE | K_FALSE )
  To #1:  K_FALSE
  To #2:  keyword
  To #3:  K_TRUE
Status #1 [FINAL] - reservedWord => ( keyword | K_TRUE | K_FALSE @ )
Status #2 [FINAL] - reservedWord => ( keyword @ | K_TRUE | K_FALSE )
Status #3 [FINAL] - reservedWord => ( keyword | K_TRUE @ | K_FALSE )

** Rule: returnStatement => K_RETURN [ (#RULE_NO_LINE#) expressionSequence ] [ eos ]
-- Tokens: K_RETURN 
-- First-set tokens: K_RETURN 
-- First-set rules: 
Status #0 - returnStatement => @ K_RETURN [ (#RULE_NO_LINE#) expressionSequence ] [ eos ]
  To #1:  K_RETURN
Status #1 [FINAL] - returnStatement => K_RETURN @ [ (#RULE_NO_LINE#) expressionSequence ] [ eos ]
  To #2:  eos
  To #3:  (#RULE_NO_LINE#)
Status #2 [FINAL] - returnStatement => K_RETURN [ (#RULE_NO_LINE#) expressionSequence ] [ eos @ ]
Status #3 - returnStatement => K_RETURN [ (#RULE_NO_LINE#) @ expressionSequence ] [ eos ]
  To #4:  expressionSequence
Status #4 [FINAL] - returnStatement => K_RETURN [ (#RULE_NO_LINE#) expressionSequence @ ] [ eos ]
  To #2:  eos

** Rule: singleExpression => [ singleExpression ('T_COMMA') ] assignmentExpression
-- Tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_LSQUARE' #NUMBER# 'T_DEC' #REGEX# K_NULL 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE K_NEW K_SUPER #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION K_THIS #ID# 
-- First-set tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_DEC' K_NULL 'T_INC' K_TYPEOF K_VOID 'T_LPARAN' K_DELETE #NUMBER# K_NEW K_SUPER #REGEX# #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION 'T_LSQUARE' K_THIS #ID# 
-- First-set rules: assignmentExpression singleExpression 
Status #0 - singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
  To #1:  singleExpression
  To #2:  assignmentExpression
Status #1 - singleExpression => [ singleExpression @ ('T_COMMA') ] assignmentExpression
  To #3:  ('T_COMMA')
Status #2 [FINAL] - singleExpression => [ singleExpression ('T_COMMA') ] assignmentExpression @
Status #3 - singleExpression => [ singleExpression ('T_COMMA') @ ] assignmentExpression
  To #2:  assignmentExpression

** Rule: sourceElement => statement
-- Tokens: 'T_LBRACE' K_THROW K_FUNCTION K_SWITCH #NUMBER# K_TRY #ID# K_WITH 'T_SEMI' K_CONTINUE 'T_ADD' K_TRUE 'T_LSQUARE' 'T_DEC' #REGEX# K_RETURN K_NULL 'T_SUB' 'T_LPARAN' K_NEW 'T_INC' K_WHILE K_VOID K_DELETE K_SUPER #STRING# K_FALSE K_CLASS 'T_BIT_NOT' K_DO K_THIS K_DEBUGGER K_IF K_VAR 'T_LOG_NOT' K_TYPEOF K_FOR K_BREAK 
-- First-set tokens: K_BREAK K_FOR K_TYPEOF 'T_LOG_NOT' K_VAR K_IF K_DEBUGGER K_THIS K_DO 'T_BIT_NOT' K_CLASS K_FALSE #STRING# K_SUPER K_DELETE K_VOID K_WHILE 'T_INC' K_NEW 'T_LPARAN' 'T_SUB' K_NULL K_RETURN #REGEX# 'T_DEC' 'T_LSQUARE' K_TRUE 'T_ADD' K_CONTINUE 'T_SEMI' K_WITH #ID# K_TRY #NUMBER# K_SWITCH K_FUNCTION K_THROW 'T_LBRACE' 
-- First-set rules: statement 
Status #0 - sourceElement => @ statement
  To #1:  statement
Status #1 [FINAL] - sourceElement => statement @

** Rule: sourceElements => [ sourceElements ] statement
-- Tokens: 'T_LBRACE' K_THROW K_FUNCTION K_SWITCH #NUMBER# K_TRY #ID# K_WITH 'T_SEMI' K_CONTINUE 'T_ADD' K_TRUE 'T_LSQUARE' 'T_DEC' #REGEX# K_RETURN K_NULL 'T_SUB' 'T_LPARAN' K_NEW 'T_INC' K_WHILE K_VOID K_DELETE K_SUPER #STRING# K_FALSE K_CLASS 'T_BIT_NOT' K_DO K_THIS K_DEBUGGER K_IF K_VAR 'T_LOG_NOT' K_TYPEOF K_FOR K_BREAK 
-- First-set tokens: 'T_LBRACE' K_THROW K_FUNCTION #NUMBER# K_TRY #ID# K_WITH 'T_SEMI' K_CONTINUE 'T_ADD' K_TRUE 'T_LSQUARE' 'T_DEC' #REGEX# K_NULL 'T_SUB' 'T_LPARAN' K_SWITCH K_NEW 'T_INC' K_WHILE K_VOID K_DELETE K_SUPER K_RETURN #STRING# K_FALSE K_CLASS 'T_BIT_NOT' K_DO K_THIS K_DEBUGGER K_IF K_VAR 'T_LOG_NOT' K_TYPEOF K_FOR K_BREAK 
-- First-set rules: statement sourceElements 
Status #0 - sourceElements => [ @ sourceElements ] statement
  To #1:  sourceElements
  To #2:  statement
Status #1 - sourceElements => [ sourceElements @ ] statement
  To #2:  statement
Status #2 [FINAL] - sourceElements => [ sourceElements ] statement @

** Rule: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
-- Tokens: 'T_LBRACE' K_THROW K_FUNCTION K_SWITCH #NUMBER# K_TRY #ID# K_WITH 'T_SEMI' K_CONTINUE 'T_ADD' K_TRUE 'T_LSQUARE' 'T_DEC' #REGEX# K_RETURN K_NULL 'T_SUB' 'T_LPARAN' K_NEW 'T_INC' K_WHILE K_VOID K_DELETE K_SUPER #STRING# K_FALSE K_CLASS 'T_BIT_NOT' K_DO K_THIS K_DEBUGGER K_IF K_VAR 'T_LOG_NOT' K_TYPEOF K_FOR K_BREAK 
-- First-set tokens: K_BREAK K_FOR K_IF K_THIS K_DO K_FALSE #STRING# K_SUPER K_DELETE K_VOID K_TYPEOF 'T_INC' K_NEW 'T_LPARAN' K_WHILE K_NULL K_RETURN #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' K_TRUE 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' K_VAR K_DEBUGGER K_CONTINUE K_CLASS 'T_SEMI' K_WITH #ID# K_TRY #NUMBER# K_SWITCH K_FUNCTION K_THROW 'T_LBRACE' 
-- First-set rules: debuggerStatement tryStatement switchStatement labelledStatement withStatement functionDeclaration variableStatement continueStatement classDeclaration emptyStatement throwStatement block expressionStatement ifStatement iterationStatement breakStatement returnStatement 
Status #0 - statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
  To #1:  functionDeclaration
  To #2:  block
  To #3:  variableStatement
  To #4:  emptyStatement
  To #5:  classDeclaration
  To #6:  expressionStatement
  To #7:  ifStatement
  To #8:  iterationStatement
  To #9:  continueStatement
  To #10:  breakStatement
  To #11:  returnStatement
  To #12:  withStatement
  To #13:  labelledStatement
  To #14:  switchStatement
  To #15:  throwStatement
  To #16:  tryStatement
  To #17:  debuggerStatement
Status #1 [FINAL] - statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration @ )
Status #2 [FINAL] - statement => ( block @ | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
Status #3 [FINAL] - statement => ( block | variableStatement @ | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
Status #4 [FINAL] - statement => ( block | variableStatement | emptyStatement @ | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
Status #5 [FINAL] - statement => ( block | variableStatement | emptyStatement | classDeclaration @ | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
Status #6 [FINAL] - statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement @ | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
Status #7 [FINAL] - statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement @ | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
Status #8 [FINAL] - statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement @ | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
Status #9 [FINAL] - statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement @ | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
Status #10 [FINAL] - statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement @ | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
Status #11 [FINAL] - statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement @ | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
Status #12 [FINAL] - statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement @ | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
Status #13 [FINAL] - statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement @ | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
Status #14 [FINAL] - statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement @ | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
Status #15 [FINAL] - statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement @ | tryStatement | debuggerStatement | functionDeclaration )
Status #16 [FINAL] - statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement @ | debuggerStatement | functionDeclaration )
Status #17 [FINAL] - statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement @ | functionDeclaration )

** Rule: statementList => [ statementList ] statement
-- Tokens: 'T_LBRACE' K_THROW K_FUNCTION K_SWITCH #NUMBER# K_TRY #ID# K_WITH 'T_SEMI' K_CONTINUE 'T_ADD' K_TRUE 'T_LSQUARE' 'T_DEC' #REGEX# K_RETURN K_NULL 'T_SUB' 'T_LPARAN' K_NEW 'T_INC' K_WHILE K_VOID K_DELETE K_SUPER #STRING# K_FALSE K_CLASS 'T_BIT_NOT' K_DO K_THIS K_DEBUGGER K_IF K_VAR 'T_LOG_NOT' K_TYPEOF K_FOR K_BREAK 
-- First-set tokens: 'T_LBRACE' K_THROW K_FUNCTION #NUMBER# K_TRY #ID# K_WITH 'T_SEMI' K_CONTINUE 'T_ADD' K_TRUE 'T_LSQUARE' 'T_DEC' #REGEX# K_NULL 'T_SUB' 'T_LPARAN' K_SWITCH K_NEW 'T_INC' K_WHILE K_VOID K_DELETE K_SUPER K_RETURN #STRING# K_FALSE K_CLASS 'T_BIT_NOT' K_DO K_THIS K_DEBUGGER K_IF K_VAR 'T_LOG_NOT' K_TYPEOF K_FOR K_BREAK 
-- First-set rules: statement statementList 
Status #0 - statementList => [ @ statementList ] statement
  To #1:  statementList
  To #2:  statement
Status #1 - statementList => [ statementList @ ] statement
  To #2:  statement
Status #2 [FINAL] - statementList => [ statementList ] statement @

** Rule: superExpression => K_SUPER
-- Tokens: K_SUPER 
-- First-set tokens: K_SUPER 
-- First-set rules: 
Status #0 - superExpression => @ K_SUPER
  To #1:  K_SUPER
Status #1 [FINAL] - superExpression => K_SUPER @

** Rule: switchStatement => K_SWITCH ('T_LPARAN') expressionSequence ('T_RPARAN') caseBlock
-- Tokens: K_SWITCH 
-- First-set tokens: K_SWITCH 
-- First-set rules: 
Status #0 - switchStatement => @ K_SWITCH ('T_LPARAN') expressionSequence ('T_RPARAN') caseBlock
  To #1:  K_SWITCH
Status #1 - switchStatement => K_SWITCH @ ('T_LPARAN') expressionSequence ('T_RPARAN') caseBlock
  To #2:  ('T_LPARAN')
Status #2 - switchStatement => K_SWITCH ('T_LPARAN') @ expressionSequence ('T_RPARAN') caseBlock
  To #3:  expressionSequence
Status #3 - switchStatement => K_SWITCH ('T_LPARAN') expressionSequence @ ('T_RPARAN') caseBlock
  To #4:  ('T_RPARAN')
Status #4 - switchStatement => K_SWITCH ('T_LPARAN') expressionSequence ('T_RPARAN') @ caseBlock
  To #5:  caseBlock
Status #5 [FINAL] - switchStatement => K_SWITCH ('T_LPARAN') expressionSequence ('T_RPARAN') caseBlock @

** Rule: ternaryExpression => logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' singleExpression ]
-- Tokens: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_LSQUARE' #NUMBER# 'T_DEC' #REGEX# K_NULL 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE K_NEW K_SUPER #STRING# K_TRUE K_CLASS K_FALSE K_FUNCTION K_THIS #ID# 
-- First-set tokens: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS K_TRUE #STRING# K_SUPER K_NEW K_DELETE K_VOID K_TYPEOF 'T_INC' 'T_LPARAN' K_NULL #REGEX# 'T_DEC' #NUMBER# 'T_LSQUARE' 'T_SUB' 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 
-- First-set rules: logicalOrExpression 
Status #0 - ternaryExpression => @ logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' singleExpression ]
  To #1:  logicalOrExpression
Status #1 [FINAL] - ternaryExpression => logicalOrExpression @ [ 'T_QUERY' singleExpression 'T_COLON' singleExpression ]
  To #2:  'T_QUERY'
Status #2 - ternaryExpression => logicalOrExpression [ 'T_QUERY' @ singleExpression 'T_COLON' singleExpression ]
  To #3:  singleExpression
Status #3 - ternaryExpression => logicalOrExpression [ 'T_QUERY' singleExpression @ 'T_COLON' singleExpression ]
  To #4:  'T_COLON'
Status #4 - ternaryExpression => logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' @ singleExpression ]
  To #5:  singleExpression
Status #5 [FINAL] - ternaryExpression => logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' singleExpression @ ]

** Rule: thisExpression => K_THIS
-- Tokens: K_THIS 
-- First-set tokens: K_THIS 
-- First-set rules: 
Status #0 - thisExpression => @ K_THIS
  To #1:  K_THIS
Status #1 [FINAL] - thisExpression => K_THIS @

** Rule: throwStatement => K_THROW (#RULE_NO_LINE#) expressionSequence [ eos ]
-- Tokens: K_THROW 
-- First-set tokens: K_THROW 
-- First-set rules: 
Status #0 - throwStatement => @ K_THROW (#RULE_NO_LINE#) expressionSequence [ eos ]
  To #1:  K_THROW
Status #1 - throwStatement => K_THROW @ (#RULE_NO_LINE#) expressionSequence [ eos ]
  To #2:  (#RULE_NO_LINE#)
Status #2 - throwStatement => K_THROW (#RULE_NO_LINE#) @ expressionSequence [ eos ]
  To #3:  expressionSequence
Status #3 [FINAL] - throwStatement => K_THROW (#RULE_NO_LINE#) expressionSequence @ [ eos ]
  To #4:  eos
Status #4 [FINAL] - throwStatement => K_THROW (#RULE_NO_LINE#) expressionSequence [ eos @ ]

** Rule: tryStatement => K_TRY block ( catchProduction [ finallyProduction ] | finallyProduction )
-- Tokens: K_TRY 
-- First-set tokens: K_TRY 
-- First-set rules: 
Status #0 - tryStatement => @ K_TRY block ( catchProduction [ finallyProduction ] | finallyProduction )
  To #1:  K_TRY
Status #1 - tryStatement => K_TRY @ block ( catchProduction [ finallyProduction ] | finallyProduction )
  To #2:  block
Status #2 - tryStatement => K_TRY block @ ( catchProduction [ finallyProduction ] | finallyProduction )
  To #3:  finallyProduction
  To #4:  catchProduction
Status #3 [FINAL] - tryStatement => K_TRY block ( catchProduction [ finallyProduction ] | finallyProduction @ )
Status #4 [FINAL] - tryStatement => K_TRY block ( catchProduction @ [ finallyProduction ] | finallyProduction )
  To #5:  finallyProduction
Status #5 [FINAL] - tryStatement => K_TRY block ( catchProduction [ finallyProduction @ ] | finallyProduction )

** Rule: typeofExpression => ( K_TYPEOF typeofExpression | voidExpression )
-- Tokens: K_TYPEOF 'T_LBRACE' K_VOID K_DELETE #REGEX# K_NEW K_SUPER K_NULL 'T_LPARAN' #STRING# K_TRUE #NUMBER# K_CLASS K_FALSE 'T_LSQUARE' K_FUNCTION #ID# K_THIS 
-- First-set tokens: K_THIS #ID# K_FUNCTION 'T_LSQUARE' K_FALSE K_CLASS #NUMBER# K_TRUE #STRING# 'T_LPARAN' K_NULL K_SUPER K_NEW #REGEX# K_DELETE K_VOID 'T_LBRACE' K_TYPEOF 
-- First-set rules: voidExpression 
Status #0 - typeofExpression => @ ( K_TYPEOF typeofExpression | voidExpression )
  To #1:  voidExpression
  To #2:  K_TYPEOF
Status #1 [FINAL] - typeofExpression => ( K_TYPEOF typeofExpression | voidExpression @ )
Status #2 - typeofExpression => ( K_TYPEOF @ typeofExpression | voidExpression )
  To #3:  typeofExpression
Status #3 [FINAL] - typeofExpression => ( K_TYPEOF typeofExpression @ | voidExpression )

** Rule: unaryMinusExpression => ( 'T_SUB' unaryMinusExpression | unaryPlusExpression )
-- Tokens: 'T_SUB' 'T_ADD' #NUMBER# 'T_DEC' K_NULL 'T_LPARAN' 'T_INC' K_TYPEOF 'T_LBRACE' K_VOID K_DELETE #REGEX# K_NEW K_SUPER #STRING# K_TRUE K_CLASS K_FALSE 'T_LSQUARE' K_FUNCTION K_THIS #ID# 
-- First-set tokens: #ID# K_THIS K_FUNCTION 'T_LSQUARE' K_FALSE K_CLASS K_TRUE #STRING# K_SUPER K_NEW #REGEX# K_DELETE K_VOID 'T_LBRACE' K_TYPEOF 'T_INC' 'T_LPARAN' K_NULL 'T_DEC' #NUMBER# 'T_ADD' 'T_SUB' 
-- First-set rules: unaryPlusExpression 
Status #0 - unaryMinusExpression => @ ( 'T_SUB' unaryMinusExpression | unaryPlusExpression )
  To #1:  unaryPlusExpression
  To #2:  'T_SUB'
Status #1 [FINAL] - unaryMinusExpression => ( 'T_SUB' unaryMinusExpression | unaryPlusExpression @ )
Status #2 - unaryMinusExpression => ( 'T_SUB' @ unaryMinusExpression | unaryPlusExpression )
  To #3:  unaryMinusExpression
Status #3 [FINAL] - unaryMinusExpression => ( 'T_SUB' unaryMinusExpression @ | unaryPlusExpression )

** Rule: unaryPlusExpression => ( 'T_ADD' unaryPlusExpression | preDecreaseExpression )
-- Tokens: 'T_ADD' #NUMBER# 'T_DEC' K_NULL 'T_LPARAN' 'T_INC' K_TYPEOF 'T_LBRACE' K_VOID K_DELETE #REGEX# K_NEW K_SUPER #STRING# K_TRUE K_CLASS K_FALSE 'T_LSQUARE' K_FUNCTION K_THIS #ID# 
-- First-set tokens: #ID# K_THIS K_FUNCTION 'T_LSQUARE' K_FALSE K_CLASS K_TRUE #STRING# K_SUPER K_NEW #REGEX# K_DELETE K_VOID 'T_LBRACE' K_TYPEOF 'T_INC' 'T_LPARAN' K_NULL 'T_DEC' #NUMBER# 'T_ADD' 
-- First-set rules: preDecreaseExpression 
Status #0 - unaryPlusExpression => @ ( 'T_ADD' unaryPlusExpression | preDecreaseExpression )
  To #1:  preDecreaseExpression
  To #2:  'T_ADD'
Status #1 [FINAL] - unaryPlusExpression => ( 'T_ADD' unaryPlusExpression | preDecreaseExpression @ )
Status #2 - unaryPlusExpression => ( 'T_ADD' @ unaryPlusExpression | preDecreaseExpression )
  To #3:  unaryPlusExpression
Status #3 [FINAL] - unaryPlusExpression => ( 'T_ADD' unaryPlusExpression @ | preDecreaseExpression )

** Rule: variableDeclaration => assignable [ 'T_ASSIGN' singleExpression ]
-- Tokens: #ID# 'T_LBRACE' 'T_LSQUARE' 
-- First-set tokens: 'T_LSQUARE' 'T_LBRACE' #ID# 
-- First-set rules: assignable 
Status #0 - variableDeclaration => @ assignable [ 'T_ASSIGN' singleExpression ]
  To #1:  assignable
Status #1 [FINAL] - variableDeclaration => assignable @ [ 'T_ASSIGN' singleExpression ]
  To #2:  'T_ASSIGN'
Status #2 - variableDeclaration => assignable [ 'T_ASSIGN' @ singleExpression ]
  To #3:  singleExpression
Status #3 [FINAL] - variableDeclaration => assignable [ 'T_ASSIGN' singleExpression @ ]

** Rule: variableDeclarationList => [ variableDeclarationList ('T_COMMA') ] variableDeclaration
-- Tokens: #ID# 'T_LBRACE' 'T_LSQUARE' 
-- First-set tokens: #ID# 'T_LBRACE' 'T_LSQUARE' 
-- First-set rules: variableDeclaration variableDeclarationList 
Status #0 - variableDeclarationList => [ @ variableDeclarationList ('T_COMMA') ] variableDeclaration
  To #1:  variableDeclarationList
  To #2:  variableDeclaration
Status #1 - variableDeclarationList => [ variableDeclarationList @ ('T_COMMA') ] variableDeclaration
  To #3:  ('T_COMMA')
Status #2 [FINAL] - variableDeclarationList => [ variableDeclarationList ('T_COMMA') ] variableDeclaration @
Status #3 - variableDeclarationList => [ variableDeclarationList ('T_COMMA') @ ] variableDeclaration
  To #2:  variableDeclaration

** Rule: variableStatement => K_VAR variableDeclarationList [ eos ]
-- Tokens: K_VAR 
-- First-set tokens: K_VAR 
-- First-set rules: 
Status #0 - variableStatement => @ K_VAR variableDeclarationList [ eos ]
  To #1:  K_VAR
Status #1 - variableStatement => K_VAR @ variableDeclarationList [ eos ]
  To #2:  variableDeclarationList
Status #2 [FINAL] - variableStatement => K_VAR variableDeclarationList @ [ eos ]
  To #3:  eos
Status #3 [FINAL] - variableStatement => K_VAR variableDeclarationList [ eos @ ]

** Rule: voidExpression => ( K_VOID voidExpression | deleteExpression )
-- Tokens: K_VOID K_DELETE #REGEX# K_NEW K_SUPER K_NULL 'T_LPARAN' #STRING# K_TRUE #NUMBER# K_CLASS K_FALSE 'T_LSQUARE' K_FUNCTION #ID# K_THIS 'T_LBRACE' 
-- First-set tokens: 'T_LBRACE' K_THIS #ID# K_FUNCTION 'T_LSQUARE' K_FALSE K_CLASS #NUMBER# K_TRUE #STRING# 'T_LPARAN' K_NULL K_SUPER K_NEW #REGEX# K_DELETE K_VOID 
-- First-set rules: deleteExpression 
Status #0 - voidExpression => @ ( K_VOID voidExpression | deleteExpression )
  To #1:  deleteExpression
  To #2:  K_VOID
Status #1 [FINAL] - voidExpression => ( K_VOID voidExpression | deleteExpression @ )
Status #2 - voidExpression => ( K_VOID @ voidExpression | deleteExpression )
  To #3:  voidExpression
Status #3 [FINAL] - voidExpression => ( K_VOID voidExpression @ | deleteExpression )

** Rule: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement
-- Tokens: K_WHILE 
-- First-set tokens: K_WHILE 
-- First-set rules: 
Status #0 - whileStatement => @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement
  To #1:  K_WHILE
Status #1 - whileStatement => K_WHILE @ ('T_LPARAN') expressionSequence ('T_RPARAN') statement
  To #2:  ('T_LPARAN')
Status #2 - whileStatement => K_WHILE ('T_LPARAN') @ expressionSequence ('T_RPARAN') statement
  To #3:  expressionSequence
Status #3 - whileStatement => K_WHILE ('T_LPARAN') expressionSequence @ ('T_RPARAN') statement
  To #4:  ('T_RPARAN')
Status #4 - whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
  To #5:  statement
Status #5 [FINAL] - whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement @

** Rule: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement
-- Tokens: K_WITH 
-- First-set tokens: K_WITH 
-- First-set rules: 
Status #0 - withStatement => @ K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement
  To #1:  K_WITH
Status #1 - withStatement => K_WITH @ ('T_LPARAN') expressionSequence ('T_RPARAN') statement
  To #2:  ('T_LPARAN')
Status #2 - withStatement => K_WITH ('T_LPARAN') @ expressionSequence ('T_RPARAN') statement
  To #3:  expressionSequence
Status #3 - withStatement => K_WITH ('T_LPARAN') expressionSequence @ ('T_RPARAN') statement
  To #4:  ('T_RPARAN')
Status #4 - withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
  To #5:  statement
Status #5 [FINAL] - withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement @

==== PDA  ====
** [Initial] State: program => @ sourceElements

** State #0: program => @ sourceElements
    --> __________________
    --> #1: sourceElements => [ @ sourceElements ] statement
    -->     Type: shift
    -->     LA: K_BREAK K_FOR K_TYPEOF 'T_LOG_NOT' K_VAR 
    -->     LA: K_IF K_DEBUGGER K_THIS K_DO 'T_BIT_NOT' 
    -->     LA: K_CLASS K_FALSE #STRING# K_RETURN K_SUPER 
    -->     LA: K_DELETE K_VOID K_WHILE 'T_INC' K_NEW 
    -->     LA: K_SWITCH 'T_LPARAN' 'T_SUB' K_NULL #REGEX# 
    -->     LA: 'T_DEC' 'T_LSQUARE' K_TRUE 'T_ADD' K_CONTINUE 
    -->     LA: 'T_SEMI' K_WITH #ID# K_TRY #NUMBER# 
    -->     LA: K_FUNCTION K_THROW 'T_LBRACE' 

** State #1: sourceElements => [ @ sourceElements ] statement
    --> __________________
    --> #2: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: shift
    -->     LA: 'T_LBRACE' K_THROW K_FUNCTION K_SWITCH #NUMBER# 
    -->     LA: K_TRY #ID# K_WITH 'T_SEMI' K_CONTINUE 
    -->     LA: 'T_ADD' K_TRUE 'T_LSQUARE' 'T_DEC' #REGEX# 
    -->     LA: K_RETURN K_NULL 'T_SUB' 'T_LPARAN' K_NEW 
    -->     LA: 'T_INC' K_WHILE K_VOID K_DELETE K_SUPER 
    -->     LA: #STRING# K_FALSE K_CLASS 'T_BIT_NOT' K_DO 
    -->     LA: K_THIS K_DEBUGGER K_IF K_VAR 'T_LOG_NOT' 
    -->     LA: K_TYPEOF K_FOR K_BREAK 

** State #2: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    --> __________________
    --> #3: functionDeclaration => @ K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: shift
    -->     LA: K_FUNCTION 
    --> __________________
    --> #4: block => @ ('T_LBRACE') [ statementList ] ('T_RBRACE')
    -->     Type: shift
    -->     LA: 'T_LBRACE' 
    --> __________________
    --> #5: variableStatement => @ K_VAR variableDeclarationList [ eos ]
    -->     Type: shift
    -->     LA: K_VAR 
    --> __________________
    --> #6: emptyStatement => @ 'T_SEMI'
    -->     Type: shift
    -->     LA: 'T_SEMI' 
    --> __________________
    --> #7: classDeclaration => @ K_CLASS #ID# classTail
    -->     Type: shift
    -->     LA: K_CLASS 
    --> __________________
    --> #8: expressionStatement => @ expressionSequence [ eos ]
    -->     Type: shift
    -->     LA: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 
    -->     LA: 'T_LSQUARE' #NUMBER# 'T_DEC' #REGEX# K_NULL 
    -->     LA: 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE 
    -->     LA: K_NEW K_SUPER #STRING# K_TRUE K_CLASS 
    -->     LA: K_FALSE K_FUNCTION K_THIS #ID# 
    --> __________________
    --> #9: ifStatement => @ K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement ]
    -->     Type: shift
    -->     LA: K_IF 
    --> __________________
    --> #10: iterationStatement => @ ( doStatement | whileStatement | forStatement | forInStatement )
    -->     Type: shift
    -->     LA: K_FOR K_WHILE K_DO 
    --> __________________
    --> #11: continueStatement => @ K_CONTINUE [ (#RULE_NO_LINE#) #ID# ] [ eos ]
    -->     Type: shift
    -->     LA: K_CONTINUE 
    --> __________________
    --> #12: breakStatement => @ K_BREAK [ (#RULE_NO_LINE#) #ID# ] [ eos ]
    -->     Type: shift
    -->     LA: K_BREAK 
    --> __________________
    --> #13: returnStatement => @ K_RETURN [ (#RULE_NO_LINE#) expressionSequence ] [ eos ]
    -->     Type: shift
    -->     LA: K_RETURN 
    --> __________________
    --> #14: withStatement => @ K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement
    -->     Type: shift
    -->     LA: K_WITH 
    --> __________________
    --> #15: labelledStatement => @ #ID# 'T_COLON' statement
    -->     Type: shift
    -->     LA: #ID# 
    --> __________________
    --> #16: switchStatement => @ K_SWITCH ('T_LPARAN') expressionSequence ('T_RPARAN') caseBlock
    -->     Type: shift
    -->     LA: K_SWITCH 
    --> __________________
    --> #17: throwStatement => @ K_THROW (#RULE_NO_LINE#) expressionSequence [ eos ]
    -->     Type: shift
    -->     LA: K_THROW 
    --> __________________
    --> #18: tryStatement => @ K_TRY block ( catchProduction [ finallyProduction ] | finallyProduction )
    -->     Type: shift
    -->     LA: K_TRY 
    --> __________________
    --> #19: debuggerStatement => @ K_DEBUGGER [ eos ]
    -->     Type: shift
    -->     LA: K_DEBUGGER 

** State #3: functionDeclaration => @ K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #20: functionDeclaration => K_FUNCTION @ #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: move
    -->     LA: K_FUNCTION 

** State #4: block => @ ('T_LBRACE') [ statementList ] ('T_RBRACE')
    --> __________________
    --> #21: block => ('T_LBRACE') @ [ statementList ] ('T_RBRACE')
    -->     Type: pass
    -->     LA: 'T_LBRACE' 

** State #5: variableStatement => @ K_VAR variableDeclarationList [ eos ]
    --> __________________
    --> #22: variableStatement => K_VAR @ variableDeclarationList [ eos ]
    -->     Type: move
    -->     LA: K_VAR 

** State #6: emptyStatement => @ 'T_SEMI'
    --> __________________
    --> #23: emptyStatement => 'T_SEMI' @
    -->     Type: move
    -->     LA: 'T_SEMI' 

** State #7: classDeclaration => @ K_CLASS #ID# classTail
    --> __________________
    --> #24: classDeclaration => K_CLASS @ #ID# classTail
    -->     Type: move
    -->     LA: K_CLASS 

** State #8: expressionStatement => @ expressionSequence [ eos ]
    --> __________________
    --> #25: expressionSequence => [ @ expressionSequence ('T_COMMA') ] singleExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #9: ifStatement => @ K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement ]
    --> __________________
    --> #26: ifStatement => K_IF @ ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement ]
    -->     Type: move
    -->     LA: K_IF 

** State #10: iterationStatement => @ ( doStatement | whileStatement | forStatement | forInStatement )
    --> __________________
    --> #28: doStatement => @ K_DO statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    -->     Type: shift
    -->     LA: K_DO 
    --> __________________
    --> #29: whileStatement => @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement
    -->     Type: shift
    -->     LA: K_WHILE 
    --> __________________
    --> #30: forStatement => @ K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
    -->     Type: shift
    -->     LA: K_FOR 
    --> __________________
    --> #27: forInStatement => @ K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement
    -->     Type: shift
    -->     LA: K_FOR 

** State #11: continueStatement => @ K_CONTINUE [ (#RULE_NO_LINE#) #ID# ] [ eos ]
    --> __________________
    --> #31: continueStatement => K_CONTINUE @ [ (#RULE_NO_LINE#) #ID# ] [ eos ]
    -->     Type: move
    -->     LA: K_CONTINUE 

** State #12: breakStatement => @ K_BREAK [ (#RULE_NO_LINE#) #ID# ] [ eos ]
    --> __________________
    --> #32: breakStatement => K_BREAK @ [ (#RULE_NO_LINE#) #ID# ] [ eos ]
    -->     Type: move
    -->     LA: K_BREAK 

** State #13: returnStatement => @ K_RETURN [ (#RULE_NO_LINE#) expressionSequence ] [ eos ]
    --> __________________
    --> #33: returnStatement => K_RETURN @ [ (#RULE_NO_LINE#) expressionSequence ] [ eos ]
    -->     Type: move
    -->     LA: K_RETURN 

** State #14: withStatement => @ K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement
    --> __________________
    --> #34: withStatement => K_WITH @ ('T_LPARAN') expressionSequence ('T_RPARAN') statement
    -->     Type: move
    -->     LA: K_WITH 

** State #15: labelledStatement => @ #ID# 'T_COLON' statement
    --> __________________
    --> #35: labelledStatement => #ID# @ 'T_COLON' statement
    -->     Type: move
    -->     LA: #ID# 

** State #16: switchStatement => @ K_SWITCH ('T_LPARAN') expressionSequence ('T_RPARAN') caseBlock
    --> __________________
    --> #36: switchStatement => K_SWITCH @ ('T_LPARAN') expressionSequence ('T_RPARAN') caseBlock
    -->     Type: move
    -->     LA: K_SWITCH 

** State #17: throwStatement => @ K_THROW (#RULE_NO_LINE#) expressionSequence [ eos ]
    --> __________________
    --> #37: throwStatement => K_THROW @ (#RULE_NO_LINE#) expressionSequence [ eos ]
    -->     Type: move
    -->     LA: K_THROW 

** State #18: tryStatement => @ K_TRY block ( catchProduction [ finallyProduction ] | finallyProduction )
    --> __________________
    --> #38: tryStatement => K_TRY @ block ( catchProduction [ finallyProduction ] | finallyProduction )
    -->     Type: move
    -->     LA: K_TRY 

** State #19: debuggerStatement => @ K_DEBUGGER [ eos ]
    --> __________________
    --> #39: debuggerStatement => K_DEBUGGER @ [ eos ]
    -->     Type: move
    -->     LA: K_DEBUGGER 

** State #20: functionDeclaration => K_FUNCTION @ #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #40: functionDeclaration => K_FUNCTION #ID# @ ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: move
    -->     LA: #ID# 

** State #21: block => ('T_LBRACE') @ [ statementList ] ('T_RBRACE')
    --> __________________
    --> #41: block => ('T_LBRACE') [ statementList ] ('T_RBRACE') @
    -->     Type: pass
    -->     LA: 'T_RBRACE' 
    --> __________________
    --> #42: statementList => [ @ statementList ] statement
    -->     Type: shift
    -->     LA: K_BREAK K_FOR K_TYPEOF 'T_LOG_NOT' K_VAR 
    -->     LA: K_IF K_DEBUGGER K_THIS K_DO 'T_BIT_NOT' 
    -->     LA: K_CLASS K_FALSE #STRING# K_RETURN K_SUPER 
    -->     LA: K_DELETE K_VOID K_WHILE 'T_INC' K_NEW 
    -->     LA: K_SWITCH 'T_LPARAN' 'T_SUB' K_NULL #REGEX# 
    -->     LA: 'T_DEC' 'T_LSQUARE' K_TRUE 'T_ADD' K_CONTINUE 
    -->     LA: 'T_SEMI' K_WITH #ID# K_TRY #NUMBER# 
    -->     LA: K_FUNCTION K_THROW 'T_LBRACE' 

** State #22: variableStatement => K_VAR @ variableDeclarationList [ eos ]
    --> __________________
    --> #43: variableDeclarationList => [ @ variableDeclarationList ('T_COMMA') ] variableDeclaration
    -->     Type: shift
    -->     LA: 'T_LSQUARE' 'T_LBRACE' #ID# 

** [FINAL] State #23: emptyStatement => 'T_SEMI' @
    --> __________________
    --> #44: classElement => ( methodDefinition | emptyStatement @ | [ 'T_SHARP' ] propertyName 'T_ASSIGN' singleExpression )
    -->     Type: reduce
    -->     Reduce: classElement => @ ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' singleExpression )
    --> __________________
    --> #45: statement => ( block | variableStatement | emptyStatement @ | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** State #24: classDeclaration => K_CLASS @ #ID# classTail
    --> __________________
    --> #46: classDeclaration => K_CLASS #ID# @ classTail
    -->     Type: move
    -->     LA: #ID# 

** State #25: expressionSequence => [ @ expressionSequence ('T_COMMA') ] singleExpression
    --> __________________
    --> #47: singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #26: ifStatement => K_IF @ ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement ]
    --> __________________
    --> #48: ifStatement => K_IF ('T_LPARAN') @ expressionSequence ('T_RPARAN') statement [ K_ELSE statement ]
    -->     Type: pass
    -->     LA: 'T_LPARAN' 

** State #27: forInStatement => @ K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement
    --> __________________
    --> #49: forInStatement => K_FOR @ ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement
    -->     Type: move
    -->     LA: K_FOR 

** State #28: doStatement => @ K_DO statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #50: doStatement => K_DO @ statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    -->     Type: move
    -->     LA: K_DO 

** State #29: whileStatement => @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement
    --> __________________
    --> #51: whileStatement => K_WHILE @ ('T_LPARAN') expressionSequence ('T_RPARAN') statement
    -->     Type: move
    -->     LA: K_WHILE 

** State #30: forStatement => @ K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
    --> __________________
    --> #52: forStatement => K_FOR @ ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
    -->     Type: move
    -->     LA: K_FOR 

** [FINAL] State #31: continueStatement => K_CONTINUE @ [ (#RULE_NO_LINE#) #ID# ] [ eos ]
    --> __________________
    --> #53: eos => @ ( ('T_SEMI') | #END# )
    -->     Type: shift
    -->     LA: 'T_SEMI' #END# 
    --> __________________
    --> #54: continueStatement => K_CONTINUE [ (#RULE_NO_LINE#) @ #ID# ] [ eos ]
    -->     Type: rule
    -->     LA: #RULE_NO_LINE# 
    --> __________________
    --> #55: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement @ | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** [FINAL] State #32: breakStatement => K_BREAK @ [ (#RULE_NO_LINE#) #ID# ] [ eos ]
    --> __________________
    --> #53: eos => @ ( ('T_SEMI') | #END# )
    -->     Type: shift
    -->     LA: 'T_SEMI' #END# 
    --> __________________
    --> #56: breakStatement => K_BREAK [ (#RULE_NO_LINE#) @ #ID# ] [ eos ]
    -->     Type: rule
    -->     LA: #RULE_NO_LINE# 
    --> __________________
    --> #57: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement @ | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** [FINAL] State #33: returnStatement => K_RETURN @ [ (#RULE_NO_LINE#) expressionSequence ] [ eos ]
    --> __________________
    --> #53: eos => @ ( ('T_SEMI') | #END# )
    -->     Type: shift
    -->     LA: 'T_SEMI' #END# 
    --> __________________
    --> #58: returnStatement => K_RETURN [ (#RULE_NO_LINE#) @ expressionSequence ] [ eos ]
    -->     Type: rule
    -->     LA: #RULE_NO_LINE# 
    --> __________________
    --> #59: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement @ | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** State #34: withStatement => K_WITH @ ('T_LPARAN') expressionSequence ('T_RPARAN') statement
    --> __________________
    --> #60: withStatement => K_WITH ('T_LPARAN') @ expressionSequence ('T_RPARAN') statement
    -->     Type: pass
    -->     LA: 'T_LPARAN' 

** State #35: labelledStatement => #ID# @ 'T_COLON' statement
    --> __________________
    --> #61: labelledStatement => #ID# 'T_COLON' @ statement
    -->     Type: move
    -->     LA: 'T_COLON' 

** State #36: switchStatement => K_SWITCH @ ('T_LPARAN') expressionSequence ('T_RPARAN') caseBlock
    --> __________________
    --> #62: switchStatement => K_SWITCH ('T_LPARAN') @ expressionSequence ('T_RPARAN') caseBlock
    -->     Type: pass
    -->     LA: 'T_LPARAN' 

** State #37: throwStatement => K_THROW @ (#RULE_NO_LINE#) expressionSequence [ eos ]
    --> __________________
    --> #63: throwStatement => K_THROW (#RULE_NO_LINE#) @ expressionSequence [ eos ]
    -->     Type: rule
    -->     LA: #RULE_NO_LINE# 

** State #38: tryStatement => K_TRY @ block ( catchProduction [ finallyProduction ] | finallyProduction )
    --> __________________
    --> #4: block => @ ('T_LBRACE') [ statementList ] ('T_RBRACE')
    -->     Type: shift
    -->     LA: 'T_LBRACE' 

** [FINAL] State #39: debuggerStatement => K_DEBUGGER @ [ eos ]
    --> __________________
    --> #53: eos => @ ( ('T_SEMI') | #END# )
    -->     Type: shift
    -->     LA: 'T_SEMI' #END# 
    --> __________________
    --> #64: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement @ | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** State #40: functionDeclaration => K_FUNCTION #ID# @ ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #65: functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') @ [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: pass
    -->     LA: 'T_LPARAN' 

** [FINAL] State #41: block => ('T_LBRACE') [ statementList ] ('T_RBRACE') @
    --> __________________
    --> #66: catchProduction => K_CATCH [ ('T_LPARAN') [ assignable ] ('T_RPARAN') ] block @
    -->     Type: reduce
    -->     Reduce: catchProduction => K_CATCH @ [ ('T_LPARAN') [ assignable ] ('T_RPARAN') ] block
    --> __________________
    --> #66: catchProduction => K_CATCH [ ('T_LPARAN') [ assignable ] ('T_RPARAN') ] block @
    -->     Type: reduce
    -->     Reduce: catchProduction => K_CATCH [ ('T_LPARAN') [ assignable ] ('T_RPARAN') @ ] block
    --> __________________
    --> #67: finallyProduction => K_FINALLY block @
    -->     Type: reduce
    -->     Reduce: finallyProduction => K_FINALLY @ block
    --> __________________
    --> #68: statement => ( block @ | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    --> __________________
    --> #69: tryStatement => K_TRY block @ ( catchProduction [ finallyProduction ] | finallyProduction )
    -->     Type: reduce
    -->     Reduce: tryStatement => K_TRY @ block ( catchProduction [ finallyProduction ] | finallyProduction )

** State #42: statementList => [ @ statementList ] statement
    --> __________________
    --> #2: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: shift
    -->     LA: 'T_LBRACE' K_THROW K_FUNCTION K_SWITCH #NUMBER# 
    -->     LA: K_TRY #ID# K_WITH 'T_SEMI' K_CONTINUE 
    -->     LA: 'T_ADD' K_TRUE 'T_LSQUARE' 'T_DEC' #REGEX# 
    -->     LA: K_RETURN K_NULL 'T_SUB' 'T_LPARAN' K_NEW 
    -->     LA: 'T_INC' K_WHILE K_VOID K_DELETE K_SUPER 
    -->     LA: #STRING# K_FALSE K_CLASS 'T_BIT_NOT' K_DO 
    -->     LA: K_THIS K_DEBUGGER K_IF K_VAR 'T_LOG_NOT' 
    -->     LA: K_TYPEOF K_FOR K_BREAK 

** State #43: variableDeclarationList => [ @ variableDeclarationList ('T_COMMA') ] variableDeclaration
    --> __________________
    --> #70: variableDeclaration => @ assignable [ 'T_ASSIGN' singleExpression ]
    -->     Type: shift
    -->     LA: #ID# 'T_LBRACE' 'T_LSQUARE' 

** [FINAL] State #44: classElement => ( methodDefinition | emptyStatement @ | [ 'T_SHARP' ] propertyName 'T_ASSIGN' singleExpression )
    --> __________________
    --> #71: classElements => [ classElements ('T_COMMA') ] classElement @
    -->     Type: reduce
    -->     Reduce: classElements => [ @ classElements ('T_COMMA') ] classElement
    --> __________________
    --> #71: classElements => [ classElements ('T_COMMA') ] classElement @
    -->     Type: reduce
    -->     Reduce: classElements => [ classElements ('T_COMMA') @ ] classElement

** [FINAL] State #45: statement => ( block | variableStatement | emptyStatement @ | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    --> __________________
    --> #72: doStatement => K_DO statement @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    -->     Type: reduce
    -->     Reduce: doStatement => K_DO @ statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #73: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #74: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') @ statement
    --> __________________
    --> #75: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement @ [ K_ELSE statement ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement [ K_ELSE statement ]
    --> __________________
    --> #76: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement @ ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE @ statement ]
    --> __________________
    --> #77: labelledStatement => #ID# 'T_COLON' statement @
    -->     Type: reduce
    -->     Reduce: labelledStatement => #ID# 'T_COLON' @ statement
    --> __________________
    --> #78: sourceElement => statement @
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #79: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ @ sourceElements ] statement
    --> __________________
    --> #79: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ sourceElements @ ] statement
    --> __________________
    --> #80: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ @ statementList ] statement
    --> __________________
    --> #80: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ statementList @ ] statement
    --> __________________
    --> #81: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #82: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement

** State #46: classDeclaration => K_CLASS #ID# @ classTail
    --> __________________
    --> #83: classTail => @ ('T_LBRACE') classElements ('T_RBRACE')
    -->     Type: shift
    -->     LA: 'T_LBRACE' 

** State #47: singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    --> __________________
    --> #84: assignmentExpression => [ @ assignmentExpression 'T_ASSIGN' ] assignmentOperatorExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #48: ifStatement => K_IF ('T_LPARAN') @ expressionSequence ('T_RPARAN') statement [ K_ELSE statement ]
    --> __________________
    --> #25: expressionSequence => [ @ expressionSequence ('T_COMMA') ] singleExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #49: forInStatement => K_FOR @ ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement
    --> __________________
    --> #85: forInStatement => K_FOR ('T_LPARAN') @ [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement
    -->     Type: pass
    -->     LA: 'T_LPARAN' 

** State #50: doStatement => K_DO @ statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #2: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: shift
    -->     LA: 'T_LBRACE' K_THROW K_FUNCTION K_SWITCH #NUMBER# 
    -->     LA: K_TRY #ID# K_WITH 'T_SEMI' K_CONTINUE 
    -->     LA: 'T_ADD' K_TRUE 'T_LSQUARE' 'T_DEC' #REGEX# 
    -->     LA: K_RETURN K_NULL 'T_SUB' 'T_LPARAN' K_NEW 
    -->     LA: 'T_INC' K_WHILE K_VOID K_DELETE K_SUPER 
    -->     LA: #STRING# K_FALSE K_CLASS 'T_BIT_NOT' K_DO 
    -->     LA: K_THIS K_DEBUGGER K_IF K_VAR 'T_LOG_NOT' 
    -->     LA: K_TYPEOF K_FOR K_BREAK 

** State #51: whileStatement => K_WHILE @ ('T_LPARAN') expressionSequence ('T_RPARAN') statement
    --> __________________
    --> #86: whileStatement => K_WHILE ('T_LPARAN') @ expressionSequence ('T_RPARAN') statement
    -->     Type: pass
    -->     LA: 'T_LPARAN' 

** State #52: forStatement => K_FOR @ ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
    --> __________________
    --> #87: forStatement => K_FOR ('T_LPARAN') @ [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
    -->     Type: pass
    -->     LA: 'T_LPARAN' 

** State #53: eos => @ ( ('T_SEMI') | #END# )
    --> __________________
    --> #88: eos => ( ('T_SEMI') | #END# @ )
    -->     Type: move
    -->     LA: #END# 
    --> __________________
    --> #89: eos => ( ('T_SEMI') @ | #END# )
    -->     Type: pass
    -->     LA: 'T_SEMI' 

** State #54: continueStatement => K_CONTINUE [ (#RULE_NO_LINE#) @ #ID# ] [ eos ]
    --> __________________
    --> #90: continueStatement => K_CONTINUE [ (#RULE_NO_LINE#) #ID# @ ] [ eos ]
    -->     Type: move
    -->     LA: #ID# 

** [FINAL] State #55: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement @ | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    --> __________________
    --> #72: doStatement => K_DO statement @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    -->     Type: reduce
    -->     Reduce: doStatement => K_DO @ statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #73: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #74: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') @ statement
    --> __________________
    --> #75: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement @ [ K_ELSE statement ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement [ K_ELSE statement ]
    --> __________________
    --> #76: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement @ ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE @ statement ]
    --> __________________
    --> #77: labelledStatement => #ID# 'T_COLON' statement @
    -->     Type: reduce
    -->     Reduce: labelledStatement => #ID# 'T_COLON' @ statement
    --> __________________
    --> #78: sourceElement => statement @
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #79: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ @ sourceElements ] statement
    --> __________________
    --> #79: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ sourceElements @ ] statement
    --> __________________
    --> #80: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ @ statementList ] statement
    --> __________________
    --> #80: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ statementList @ ] statement
    --> __________________
    --> #81: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #82: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement

** State #56: breakStatement => K_BREAK [ (#RULE_NO_LINE#) @ #ID# ] [ eos ]
    --> __________________
    --> #91: breakStatement => K_BREAK [ (#RULE_NO_LINE#) #ID# @ ] [ eos ]
    -->     Type: move
    -->     LA: #ID# 

** [FINAL] State #57: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement @ | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    --> __________________
    --> #72: doStatement => K_DO statement @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    -->     Type: reduce
    -->     Reduce: doStatement => K_DO @ statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #73: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #74: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') @ statement
    --> __________________
    --> #75: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement @ [ K_ELSE statement ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement [ K_ELSE statement ]
    --> __________________
    --> #76: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement @ ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE @ statement ]
    --> __________________
    --> #77: labelledStatement => #ID# 'T_COLON' statement @
    -->     Type: reduce
    -->     Reduce: labelledStatement => #ID# 'T_COLON' @ statement
    --> __________________
    --> #78: sourceElement => statement @
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #79: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ @ sourceElements ] statement
    --> __________________
    --> #79: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ sourceElements @ ] statement
    --> __________________
    --> #80: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ @ statementList ] statement
    --> __________________
    --> #80: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ statementList @ ] statement
    --> __________________
    --> #81: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #82: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement

** State #58: returnStatement => K_RETURN [ (#RULE_NO_LINE#) @ expressionSequence ] [ eos ]
    --> __________________
    --> #25: expressionSequence => [ @ expressionSequence ('T_COMMA') ] singleExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #59: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement @ | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    --> __________________
    --> #72: doStatement => K_DO statement @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    -->     Type: reduce
    -->     Reduce: doStatement => K_DO @ statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #73: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #74: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') @ statement
    --> __________________
    --> #75: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement @ [ K_ELSE statement ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement [ K_ELSE statement ]
    --> __________________
    --> #76: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement @ ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE @ statement ]
    --> __________________
    --> #77: labelledStatement => #ID# 'T_COLON' statement @
    -->     Type: reduce
    -->     Reduce: labelledStatement => #ID# 'T_COLON' @ statement
    --> __________________
    --> #78: sourceElement => statement @
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #79: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ @ sourceElements ] statement
    --> __________________
    --> #79: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ sourceElements @ ] statement
    --> __________________
    --> #80: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ @ statementList ] statement
    --> __________________
    --> #80: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ statementList @ ] statement
    --> __________________
    --> #81: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #82: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement

** State #60: withStatement => K_WITH ('T_LPARAN') @ expressionSequence ('T_RPARAN') statement
    --> __________________
    --> #25: expressionSequence => [ @ expressionSequence ('T_COMMA') ] singleExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #61: labelledStatement => #ID# 'T_COLON' @ statement
    --> __________________
    --> #2: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: shift
    -->     LA: 'T_LBRACE' K_THROW K_FUNCTION K_SWITCH #NUMBER# 
    -->     LA: K_TRY #ID# K_WITH 'T_SEMI' K_CONTINUE 
    -->     LA: 'T_ADD' K_TRUE 'T_LSQUARE' 'T_DEC' #REGEX# 
    -->     LA: K_RETURN K_NULL 'T_SUB' 'T_LPARAN' K_NEW 
    -->     LA: 'T_INC' K_WHILE K_VOID K_DELETE K_SUPER 
    -->     LA: #STRING# K_FALSE K_CLASS 'T_BIT_NOT' K_DO 
    -->     LA: K_THIS K_DEBUGGER K_IF K_VAR 'T_LOG_NOT' 
    -->     LA: K_TYPEOF K_FOR K_BREAK 

** State #62: switchStatement => K_SWITCH ('T_LPARAN') @ expressionSequence ('T_RPARAN') caseBlock
    --> __________________
    --> #25: expressionSequence => [ @ expressionSequence ('T_COMMA') ] singleExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #63: throwStatement => K_THROW (#RULE_NO_LINE#) @ expressionSequence [ eos ]
    --> __________________
    --> #25: expressionSequence => [ @ expressionSequence ('T_COMMA') ] singleExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #64: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement @ | functionDeclaration )
    --> __________________
    --> #72: doStatement => K_DO statement @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    -->     Type: reduce
    -->     Reduce: doStatement => K_DO @ statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #73: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #74: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') @ statement
    --> __________________
    --> #75: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement @ [ K_ELSE statement ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement [ K_ELSE statement ]
    --> __________________
    --> #76: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement @ ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE @ statement ]
    --> __________________
    --> #77: labelledStatement => #ID# 'T_COLON' statement @
    -->     Type: reduce
    -->     Reduce: labelledStatement => #ID# 'T_COLON' @ statement
    --> __________________
    --> #78: sourceElement => statement @
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #79: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ @ sourceElements ] statement
    --> __________________
    --> #79: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ sourceElements @ ] statement
    --> __________________
    --> #80: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ @ statementList ] statement
    --> __________________
    --> #80: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ statementList @ ] statement
    --> __________________
    --> #81: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #82: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement

** State #65: functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') @ [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #92: functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') @ ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: pass
    -->     LA: 'T_RPARAN' 
    --> __________________
    --> #93: formalParameterList => [ @ formalParameterList ('T_COMMA') ] assignable
    -->     Type: shift
    -->     LA: 'T_LSQUARE' 'T_LBRACE' #ID# 

** [FINAL] State #66: catchProduction => K_CATCH [ ('T_LPARAN') [ assignable ] ('T_RPARAN') ] block @
    --> __________________
    --> #94: tryStatement => K_TRY block ( catchProduction @ [ finallyProduction ] | finallyProduction )
    -->     Type: reduce
    -->     Reduce: tryStatement => K_TRY block @ ( catchProduction [ finallyProduction ] | finallyProduction )

** [FINAL] State #67: finallyProduction => K_FINALLY block @
    --> __________________
    --> #95: tryStatement => K_TRY block ( catchProduction [ finallyProduction ] | finallyProduction @ )
    -->     Type: reduce
    -->     Reduce: tryStatement => K_TRY block @ ( catchProduction [ finallyProduction ] | finallyProduction )
    --> __________________
    --> #96: tryStatement => K_TRY block ( catchProduction [ finallyProduction @ ] | finallyProduction )
    -->     Type: reduce
    -->     Reduce: tryStatement => K_TRY block ( catchProduction @ [ finallyProduction ] | finallyProduction )

** [FINAL] State #68: statement => ( block @ | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    --> __________________
    --> #72: doStatement => K_DO statement @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    -->     Type: reduce
    -->     Reduce: doStatement => K_DO @ statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #73: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #74: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') @ statement
    --> __________________
    --> #75: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement @ [ K_ELSE statement ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement [ K_ELSE statement ]
    --> __________________
    --> #76: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement @ ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE @ statement ]
    --> __________________
    --> #77: labelledStatement => #ID# 'T_COLON' statement @
    -->     Type: reduce
    -->     Reduce: labelledStatement => #ID# 'T_COLON' @ statement
    --> __________________
    --> #78: sourceElement => statement @
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #79: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ @ sourceElements ] statement
    --> __________________
    --> #79: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ sourceElements @ ] statement
    --> __________________
    --> #80: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ @ statementList ] statement
    --> __________________
    --> #80: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ statementList @ ] statement
    --> __________________
    --> #81: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #82: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement

** State #69: tryStatement => K_TRY block @ ( catchProduction [ finallyProduction ] | finallyProduction )
    --> __________________
    --> #97: finallyProduction => @ K_FINALLY block
    -->     Type: shift
    -->     LA: K_FINALLY 
    --> __________________
    --> #98: catchProduction => @ K_CATCH [ ('T_LPARAN') [ assignable ] ('T_RPARAN') ] block
    -->     Type: shift
    -->     LA: K_CATCH 

** State #70: variableDeclaration => @ assignable [ 'T_ASSIGN' singleExpression ]
    --> __________________
    --> #99: assignable => @ ( #ID# | arrayLiteral | objectLiteral )
    -->     Type: shift
    -->     LA: #ID# 'T_LBRACE' 'T_LSQUARE' 

** [FINAL] State #71: classElements => [ classElements ('T_COMMA') ] classElement @
    --> __________________
    --> #100: classElements => [ classElements @ ('T_COMMA') ] classElement
    -->     Type: recursion
    -->     LA: 'T_COMMA' 
    --> __________________
    --> #101: classTail => ('T_LBRACE') classElements @ ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: classTail => ('T_LBRACE') @ classElements ('T_RBRACE')

** State #72: doStatement => K_DO statement @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #102: doStatement => K_DO statement K_WHILE @ ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    -->     Type: move
    -->     LA: K_WHILE 

** [FINAL] State #73: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement @
    --> __________________
    --> #103: iterationStatement => ( doStatement | whileStatement | forStatement | forInStatement @ )
    -->     Type: reduce
    -->     Reduce: iterationStatement => @ ( doStatement | whileStatement | forStatement | forInStatement )

** [FINAL] State #74: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement @
    --> __________________
    --> #104: iterationStatement => ( doStatement | whileStatement | forStatement @ | forInStatement )
    -->     Type: reduce
    -->     Reduce: iterationStatement => @ ( doStatement | whileStatement | forStatement | forInStatement )

** [FINAL] State #75: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement @ [ K_ELSE statement ]
    --> __________________
    --> #105: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE @ statement ]
    -->     Type: move
    -->     LA: K_ELSE 
    --> __________________
    --> #106: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement @ | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** [FINAL] State #76: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement @ ]
    --> __________________
    --> #106: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement @ | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** [FINAL] State #77: labelledStatement => #ID# 'T_COLON' statement @
    --> __________________
    --> #107: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement @ | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** [FINAL] State #78: sourceElement => statement @

** [FINAL] State #79: sourceElements => [ sourceElements ] statement @
    --> __________________
    --> #108: functionBody => [ functionBody ] sourceElements @
    -->     Type: reduce
    -->     Reduce: functionBody => [ @ functionBody ] sourceElements
    --> __________________
    --> #108: functionBody => [ functionBody ] sourceElements @
    -->     Type: reduce
    -->     Reduce: functionBody => [ functionBody @ ] sourceElements
    --> __________________
    --> #109: program => sourceElements @
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #110: sourceElements => [ sourceElements @ ] statement
    -->     Type: recursion
    -->     LA: 'T_LBRACE' K_THROW K_FUNCTION K_SWITCH #NUMBER# 
    -->     LA: K_TRY #ID# K_WITH 'T_SEMI' K_CONTINUE 
    -->     LA: 'T_ADD' K_TRUE 'T_LSQUARE' 'T_DEC' #REGEX# 
    -->     LA: K_RETURN K_NULL 'T_SUB' 'T_LPARAN' K_NEW 
    -->     LA: 'T_INC' K_WHILE K_VOID K_DELETE K_SUPER 
    -->     LA: #STRING# K_FALSE K_CLASS 'T_BIT_NOT' K_DO 
    -->     LA: K_THIS K_DEBUGGER K_IF K_VAR 'T_LOG_NOT' 
    -->     LA: K_TYPEOF K_FOR K_BREAK 

** [FINAL] State #80: statementList => [ statementList ] statement @
    --> __________________
    --> #111: block => ('T_LBRACE') [ statementList @ ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: block => ('T_LBRACE') @ [ statementList ] ('T_RBRACE')
    --> __________________
    --> #112: caseClause => K_CASE expressionSequence 'T_COLON' [ statementList @ ]
    -->     Type: reduce
    -->     Reduce: caseClause => K_CASE expressionSequence 'T_COLON' @ [ statementList ]
    --> __________________
    --> #113: defaultClause => K_DEFAULT 'T_COLON' [ statementList @ ]
    -->     Type: reduce
    -->     Reduce: defaultClause => K_DEFAULT 'T_COLON' @ [ statementList ]
    --> __________________
    --> #114: statementList => [ statementList @ ] statement
    -->     Type: recursion
    -->     LA: 'T_LBRACE' K_THROW K_FUNCTION K_SWITCH #NUMBER# 
    -->     LA: K_TRY #ID# K_WITH 'T_SEMI' K_CONTINUE 
    -->     LA: 'T_ADD' K_TRUE 'T_LSQUARE' 'T_DEC' #REGEX# 
    -->     LA: K_RETURN K_NULL 'T_SUB' 'T_LPARAN' K_NEW 
    -->     LA: 'T_INC' K_WHILE K_VOID K_DELETE K_SUPER 
    -->     LA: #STRING# K_FALSE K_CLASS 'T_BIT_NOT' K_DO 
    -->     LA: K_THIS K_DEBUGGER K_IF K_VAR 'T_LOG_NOT' 
    -->     LA: K_TYPEOF K_FOR K_BREAK 

** [FINAL] State #81: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    --> __________________
    --> #115: iterationStatement => ( doStatement | whileStatement @ | forStatement | forInStatement )
    -->     Type: reduce
    -->     Reduce: iterationStatement => @ ( doStatement | whileStatement | forStatement | forInStatement )

** [FINAL] State #82: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    --> __________________
    --> #116: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement @ | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** State #83: classTail => @ ('T_LBRACE') classElements ('T_RBRACE')
    --> __________________
    --> #117: classTail => ('T_LBRACE') @ classElements ('T_RBRACE')
    -->     Type: pass
    -->     LA: 'T_LBRACE' 

** State #84: assignmentExpression => [ @ assignmentExpression 'T_ASSIGN' ] assignmentOperatorExpression
    --> __________________
    --> #118: assignmentOperatorExpression => [ @ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #85: forInStatement => K_FOR ('T_LPARAN') @ [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement
    --> __________________
    --> #119: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN @ expressionSequence ('T_RPARAN') statement
    -->     Type: move
    -->     LA: K_IN 
    --> __________________
    --> #47: singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 
    --> __________________
    --> #120: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR @ variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement
    -->     Type: move
    -->     LA: K_VAR 

** State #86: whileStatement => K_WHILE ('T_LPARAN') @ expressionSequence ('T_RPARAN') statement
    --> __________________
    --> #25: expressionSequence => [ @ expressionSequence ('T_COMMA') ] singleExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #87: forStatement => K_FOR ('T_LPARAN') @ [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
    --> __________________
    --> #121: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' @ [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
    -->     Type: move
    -->     LA: 'T_SEMI' 
    --> __________________
    --> #25: expressionSequence => [ @ expressionSequence ('T_COMMA') ] singleExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 
    --> __________________
    --> #122: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR @ variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
    -->     Type: move
    -->     LA: K_VAR 

** [FINAL] State #88: eos => ( ('T_SEMI') | #END# @ )
    --> __________________
    --> #123: breakStatement => K_BREAK [ (#RULE_NO_LINE#) #ID# ] [ eos @ ]
    -->     Type: reduce
    -->     Reduce: breakStatement => K_BREAK @ [ (#RULE_NO_LINE#) #ID# ] [ eos ]
    --> __________________
    --> #123: breakStatement => K_BREAK [ (#RULE_NO_LINE#) #ID# ] [ eos @ ]
    -->     Type: reduce
    -->     Reduce: breakStatement => K_BREAK [ (#RULE_NO_LINE#) #ID# @ ] [ eos ]
    --> __________________
    --> #124: continueStatement => K_CONTINUE [ (#RULE_NO_LINE#) #ID# ] [ eos @ ]
    -->     Type: reduce
    -->     Reduce: continueStatement => K_CONTINUE @ [ (#RULE_NO_LINE#) #ID# ] [ eos ]
    --> __________________
    --> #124: continueStatement => K_CONTINUE [ (#RULE_NO_LINE#) #ID# ] [ eos @ ]
    -->     Type: reduce
    -->     Reduce: continueStatement => K_CONTINUE [ (#RULE_NO_LINE#) #ID# @ ] [ eos ]
    --> __________________
    --> #125: debuggerStatement => K_DEBUGGER [ eos @ ]
    -->     Type: reduce
    -->     Reduce: debuggerStatement => K_DEBUGGER @ [ eos ]
    --> __________________
    --> #126: doStatement => K_DO statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos @ ]
    -->     Type: reduce
    -->     Reduce: doStatement => K_DO statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ [ eos ]
    --> __________________
    --> #127: expressionStatement => expressionSequence [ eos @ ]
    -->     Type: reduce
    -->     Reduce: expressionStatement => expressionSequence @ [ eos ]
    --> __________________
    --> #128: returnStatement => K_RETURN [ (#RULE_NO_LINE#) expressionSequence ] [ eos @ ]
    -->     Type: reduce
    -->     Reduce: returnStatement => K_RETURN @ [ (#RULE_NO_LINE#) expressionSequence ] [ eos ]
    --> __________________
    --> #128: returnStatement => K_RETURN [ (#RULE_NO_LINE#) expressionSequence ] [ eos @ ]
    -->     Type: reduce
    -->     Reduce: returnStatement => K_RETURN [ (#RULE_NO_LINE#) expressionSequence @ ] [ eos ]
    --> __________________
    --> #129: throwStatement => K_THROW (#RULE_NO_LINE#) expressionSequence [ eos @ ]
    -->     Type: reduce
    -->     Reduce: throwStatement => K_THROW (#RULE_NO_LINE#) expressionSequence @ [ eos ]
    --> __________________
    --> #130: variableStatement => K_VAR variableDeclarationList [ eos @ ]
    -->     Type: reduce
    -->     Reduce: variableStatement => K_VAR variableDeclarationList @ [ eos ]

** [FINAL] State #89: eos => ( ('T_SEMI') @ | #END# )
    --> __________________
    --> #123: breakStatement => K_BREAK [ (#RULE_NO_LINE#) #ID# ] [ eos @ ]
    -->     Type: reduce
    -->     Reduce: breakStatement => K_BREAK @ [ (#RULE_NO_LINE#) #ID# ] [ eos ]
    --> __________________
    --> #123: breakStatement => K_BREAK [ (#RULE_NO_LINE#) #ID# ] [ eos @ ]
    -->     Type: reduce
    -->     Reduce: breakStatement => K_BREAK [ (#RULE_NO_LINE#) #ID# @ ] [ eos ]
    --> __________________
    --> #124: continueStatement => K_CONTINUE [ (#RULE_NO_LINE#) #ID# ] [ eos @ ]
    -->     Type: reduce
    -->     Reduce: continueStatement => K_CONTINUE @ [ (#RULE_NO_LINE#) #ID# ] [ eos ]
    --> __________________
    --> #124: continueStatement => K_CONTINUE [ (#RULE_NO_LINE#) #ID# ] [ eos @ ]
    -->     Type: reduce
    -->     Reduce: continueStatement => K_CONTINUE [ (#RULE_NO_LINE#) #ID# @ ] [ eos ]
    --> __________________
    --> #125: debuggerStatement => K_DEBUGGER [ eos @ ]
    -->     Type: reduce
    -->     Reduce: debuggerStatement => K_DEBUGGER @ [ eos ]
    --> __________________
    --> #126: doStatement => K_DO statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos @ ]
    -->     Type: reduce
    -->     Reduce: doStatement => K_DO statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ [ eos ]
    --> __________________
    --> #127: expressionStatement => expressionSequence [ eos @ ]
    -->     Type: reduce
    -->     Reduce: expressionStatement => expressionSequence @ [ eos ]
    --> __________________
    --> #128: returnStatement => K_RETURN [ (#RULE_NO_LINE#) expressionSequence ] [ eos @ ]
    -->     Type: reduce
    -->     Reduce: returnStatement => K_RETURN @ [ (#RULE_NO_LINE#) expressionSequence ] [ eos ]
    --> __________________
    --> #128: returnStatement => K_RETURN [ (#RULE_NO_LINE#) expressionSequence ] [ eos @ ]
    -->     Type: reduce
    -->     Reduce: returnStatement => K_RETURN [ (#RULE_NO_LINE#) expressionSequence @ ] [ eos ]
    --> __________________
    --> #129: throwStatement => K_THROW (#RULE_NO_LINE#) expressionSequence [ eos @ ]
    -->     Type: reduce
    -->     Reduce: throwStatement => K_THROW (#RULE_NO_LINE#) expressionSequence @ [ eos ]
    --> __________________
    --> #130: variableStatement => K_VAR variableDeclarationList [ eos @ ]
    -->     Type: reduce
    -->     Reduce: variableStatement => K_VAR variableDeclarationList @ [ eos ]

** [FINAL] State #90: continueStatement => K_CONTINUE [ (#RULE_NO_LINE#) #ID# @ ] [ eos ]
    --> __________________
    --> #53: eos => @ ( ('T_SEMI') | #END# )
    -->     Type: shift
    -->     LA: 'T_SEMI' #END# 
    --> __________________
    --> #55: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement @ | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** [FINAL] State #91: breakStatement => K_BREAK [ (#RULE_NO_LINE#) #ID# @ ] [ eos ]
    --> __________________
    --> #53: eos => @ ( ('T_SEMI') | #END# )
    -->     Type: shift
    -->     LA: 'T_SEMI' #END# 
    --> __________________
    --> #57: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement @ | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** State #92: functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') @ ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #131: functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') @ [ functionBody ] ('T_RBRACE')
    -->     Type: pass
    -->     LA: 'T_LBRACE' 

** State #93: formalParameterList => [ @ formalParameterList ('T_COMMA') ] assignable
    --> __________________
    --> #99: assignable => @ ( #ID# | arrayLiteral | objectLiteral )
    -->     Type: shift
    -->     LA: #ID# 'T_LBRACE' 'T_LSQUARE' 

** [FINAL] State #94: tryStatement => K_TRY block ( catchProduction @ [ finallyProduction ] | finallyProduction )
    --> __________________
    --> #97: finallyProduction => @ K_FINALLY block
    -->     Type: shift
    -->     LA: K_FINALLY 
    --> __________________
    --> #132: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement @ | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** [FINAL] State #95: tryStatement => K_TRY block ( catchProduction [ finallyProduction ] | finallyProduction @ )
    --> __________________
    --> #132: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement @ | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** [FINAL] State #96: tryStatement => K_TRY block ( catchProduction [ finallyProduction @ ] | finallyProduction )
    --> __________________
    --> #132: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement @ | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** State #97: finallyProduction => @ K_FINALLY block
    --> __________________
    --> #133: finallyProduction => K_FINALLY @ block
    -->     Type: move
    -->     LA: K_FINALLY 

** State #98: catchProduction => @ K_CATCH [ ('T_LPARAN') [ assignable ] ('T_RPARAN') ] block
    --> __________________
    --> #134: catchProduction => K_CATCH @ [ ('T_LPARAN') [ assignable ] ('T_RPARAN') ] block
    -->     Type: move
    -->     LA: K_CATCH 

** State #99: assignable => @ ( #ID# | arrayLiteral | objectLiteral )
    --> __________________
    --> #135: objectLiteral => @ ('T_LBRACE') [ propertyAssignments ] [ ('T_COMMA') ] ('T_RBRACE')
    -->     Type: shift
    -->     LA: 'T_LBRACE' 
    --> __________________
    --> #136: assignable => ( #ID# @ | arrayLiteral | objectLiteral )
    -->     Type: move
    -->     LA: #ID# 
    --> __________________
    --> #137: arrayLiteral => @ ('T_LSQUARE') [ elementList ] ('T_RSQUARE')
    -->     Type: shift
    -->     LA: 'T_LSQUARE' 

** State #100: classElements => [ classElements @ ('T_COMMA') ] classElement
    --> __________________
    --> #138: classElements => [ classElements ('T_COMMA') @ ] classElement
    -->     Type: pass
    -->     LA: 'T_COMMA' 

** State #101: classTail => ('T_LBRACE') classElements @ ('T_RBRACE')
    --> __________________
    --> #139: classTail => ('T_LBRACE') classElements ('T_RBRACE') @
    -->     Type: pass
    -->     LA: 'T_RBRACE' 

** State #102: doStatement => K_DO statement K_WHILE @ ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #140: doStatement => K_DO statement K_WHILE ('T_LPARAN') @ expressionSequence ('T_RPARAN') [ eos ]
    -->     Type: pass
    -->     LA: 'T_LPARAN' 

** [FINAL] State #103: iterationStatement => ( doStatement | whileStatement | forStatement | forInStatement @ )
    --> __________________
    --> #141: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement @ | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** [FINAL] State #104: iterationStatement => ( doStatement | whileStatement | forStatement @ | forInStatement )
    --> __________________
    --> #141: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement @ | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** State #105: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE @ statement ]
    --> __________________
    --> #2: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: shift
    -->     LA: 'T_LBRACE' K_THROW K_FUNCTION K_SWITCH #NUMBER# 
    -->     LA: K_TRY #ID# K_WITH 'T_SEMI' K_CONTINUE 
    -->     LA: 'T_ADD' K_TRUE 'T_LSQUARE' 'T_DEC' #REGEX# 
    -->     LA: K_RETURN K_NULL 'T_SUB' 'T_LPARAN' K_NEW 
    -->     LA: 'T_INC' K_WHILE K_VOID K_DELETE K_SUPER 
    -->     LA: #STRING# K_FALSE K_CLASS 'T_BIT_NOT' K_DO 
    -->     LA: K_THIS K_DEBUGGER K_IF K_VAR 'T_LOG_NOT' 
    -->     LA: K_TYPEOF K_FOR K_BREAK 

** [FINAL] State #106: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement @ | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    --> __________________
    --> #72: doStatement => K_DO statement @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    -->     Type: reduce
    -->     Reduce: doStatement => K_DO @ statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #73: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #74: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') @ statement
    --> __________________
    --> #75: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement @ [ K_ELSE statement ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement [ K_ELSE statement ]
    --> __________________
    --> #76: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement @ ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE @ statement ]
    --> __________________
    --> #77: labelledStatement => #ID# 'T_COLON' statement @
    -->     Type: reduce
    -->     Reduce: labelledStatement => #ID# 'T_COLON' @ statement
    --> __________________
    --> #78: sourceElement => statement @
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #79: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ @ sourceElements ] statement
    --> __________________
    --> #79: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ sourceElements @ ] statement
    --> __________________
    --> #80: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ @ statementList ] statement
    --> __________________
    --> #80: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ statementList @ ] statement
    --> __________________
    --> #81: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #82: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement

** [FINAL] State #107: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement @ | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    --> __________________
    --> #72: doStatement => K_DO statement @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    -->     Type: reduce
    -->     Reduce: doStatement => K_DO @ statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #73: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #74: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') @ statement
    --> __________________
    --> #75: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement @ [ K_ELSE statement ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement [ K_ELSE statement ]
    --> __________________
    --> #76: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement @ ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE @ statement ]
    --> __________________
    --> #77: labelledStatement => #ID# 'T_COLON' statement @
    -->     Type: reduce
    -->     Reduce: labelledStatement => #ID# 'T_COLON' @ statement
    --> __________________
    --> #78: sourceElement => statement @
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #79: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ @ sourceElements ] statement
    --> __________________
    --> #79: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ sourceElements @ ] statement
    --> __________________
    --> #80: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ @ statementList ] statement
    --> __________________
    --> #80: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ statementList @ ] statement
    --> __________________
    --> #81: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #82: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement

** [FINAL] State #108: functionBody => [ functionBody ] sourceElements @
    --> __________________
    --> #142: anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody @ ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') @ [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #143: arrowFunctionBody => ( singleExpression | 'T_LBRACE' [ functionBody @ ] 'T_RBRACE' )
    -->     Type: reduce
    -->     Reduce: arrowFunctionBody => ( singleExpression | 'T_LBRACE' @ [ functionBody ] 'T_RBRACE' )
    --> __________________
    --> #144: functionBody => [ functionBody @ ] sourceElements
    -->     Type: recursion
    -->     LA: K_BREAK K_FOR K_TYPEOF 'T_LOG_NOT' K_VAR 
    -->     LA: K_IF K_DEBUGGER K_THIS K_DO 'T_BIT_NOT' 
    -->     LA: K_CLASS K_FALSE #STRING# K_RETURN K_SUPER 
    -->     LA: K_DELETE K_VOID K_WHILE 'T_INC' K_NEW 
    -->     LA: K_SWITCH 'T_LPARAN' 'T_SUB' K_NULL #REGEX# 
    -->     LA: 'T_DEC' 'T_LSQUARE' K_TRUE 'T_ADD' K_CONTINUE 
    -->     LA: 'T_SEMI' K_WITH #ID# K_TRY #NUMBER# 
    -->     LA: K_FUNCTION K_THROW 'T_LBRACE' 
    --> __________________
    --> #145: functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody @ ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') @ [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #146: methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody @ ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') @ [ functionBody ] ('T_RBRACE')

** [FINAL] State #109: program => sourceElements @
    --> __________________
    --> #109: program => sourceElements @
    -->     Type: finish

** State #110: sourceElements => [ sourceElements @ ] statement
    --> __________________
    --> #2: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: shift
    -->     LA: 'T_LBRACE' K_THROW K_FUNCTION K_SWITCH #NUMBER# 
    -->     LA: K_TRY #ID# K_WITH 'T_SEMI' K_CONTINUE 
    -->     LA: 'T_ADD' K_TRUE 'T_LSQUARE' 'T_DEC' #REGEX# 
    -->     LA: K_RETURN K_NULL 'T_SUB' 'T_LPARAN' K_NEW 
    -->     LA: 'T_INC' K_WHILE K_VOID K_DELETE K_SUPER 
    -->     LA: #STRING# K_FALSE K_CLASS 'T_BIT_NOT' K_DO 
    -->     LA: K_THIS K_DEBUGGER K_IF K_VAR 'T_LOG_NOT' 
    -->     LA: K_TYPEOF K_FOR K_BREAK 

** State #111: block => ('T_LBRACE') [ statementList @ ] ('T_RBRACE')
    --> __________________
    --> #41: block => ('T_LBRACE') [ statementList ] ('T_RBRACE') @
    -->     Type: pass
    -->     LA: 'T_RBRACE' 

** [FINAL] State #112: caseClause => K_CASE expressionSequence 'T_COLON' [ statementList @ ]
    --> __________________
    --> #147: caseClauses => caseClause @ [ caseClauses ]
    -->     Type: reduce
    -->     Reduce: caseClauses => @ caseClause [ caseClauses ]

** [FINAL] State #113: defaultClause => K_DEFAULT 'T_COLON' [ statementList @ ]
    --> __________________
    --> #148: caseBlock => ('T_LBRACE') [ caseClauses ] [ defaultClause @ [ caseClauses ] ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: caseBlock => ('T_LBRACE') @ [ caseClauses ] [ defaultClause [ caseClauses ] ] ('T_RBRACE')
    --> __________________
    --> #148: caseBlock => ('T_LBRACE') [ caseClauses ] [ defaultClause @ [ caseClauses ] ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: caseBlock => ('T_LBRACE') [ caseClauses @ ] [ defaultClause [ caseClauses ] ] ('T_RBRACE')

** State #114: statementList => [ statementList @ ] statement
    --> __________________
    --> #2: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: shift
    -->     LA: 'T_LBRACE' K_THROW K_FUNCTION K_SWITCH #NUMBER# 
    -->     LA: K_TRY #ID# K_WITH 'T_SEMI' K_CONTINUE 
    -->     LA: 'T_ADD' K_TRUE 'T_LSQUARE' 'T_DEC' #REGEX# 
    -->     LA: K_RETURN K_NULL 'T_SUB' 'T_LPARAN' K_NEW 
    -->     LA: 'T_INC' K_WHILE K_VOID K_DELETE K_SUPER 
    -->     LA: #STRING# K_FALSE K_CLASS 'T_BIT_NOT' K_DO 
    -->     LA: K_THIS K_DEBUGGER K_IF K_VAR 'T_LOG_NOT' 
    -->     LA: K_TYPEOF K_FOR K_BREAK 

** [FINAL] State #115: iterationStatement => ( doStatement | whileStatement @ | forStatement | forInStatement )
    --> __________________
    --> #141: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement @ | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** [FINAL] State #116: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement @ | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    --> __________________
    --> #72: doStatement => K_DO statement @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    -->     Type: reduce
    -->     Reduce: doStatement => K_DO @ statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #73: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #74: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') @ statement
    --> __________________
    --> #75: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement @ [ K_ELSE statement ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement [ K_ELSE statement ]
    --> __________________
    --> #76: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement @ ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE @ statement ]
    --> __________________
    --> #77: labelledStatement => #ID# 'T_COLON' statement @
    -->     Type: reduce
    -->     Reduce: labelledStatement => #ID# 'T_COLON' @ statement
    --> __________________
    --> #78: sourceElement => statement @
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #79: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ @ sourceElements ] statement
    --> __________________
    --> #79: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ sourceElements @ ] statement
    --> __________________
    --> #80: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ @ statementList ] statement
    --> __________________
    --> #80: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ statementList @ ] statement
    --> __________________
    --> #81: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #82: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement

** State #117: classTail => ('T_LBRACE') @ classElements ('T_RBRACE')
    --> __________________
    --> #149: classElements => [ @ classElements ('T_COMMA') ] classElement
    -->     Type: shift
    -->     LA: K_RETURN #NUMBER# K_CASE 'T_LSQUARE' #STRING# 
    -->     LA: K_FALSE K_THIS #ID# K_SWITCH 'T_SHARP' 
    -->     LA: 'T_SEMI' K_CATCH K_NEW K_LET K_INSTANCEOF 
    -->     LA: K_TRUE K_DO K_CLASS K_ELSE K_DEFAULT 
    -->     LA: K_VAR K_FOR K_TYPEOF K_IF K_DEBUGGER 
    -->     LA: K_DELETE K_IN K_THROW K_WHILE K_VOID 
    -->     LA: K_CONTINUE K_FUNCTION K_FINALLY K_WITH K_BREAK 
    -->     LA: K_SUPER K_TRY 

** State #118: assignmentOperatorExpression => [ @ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #150: ternaryExpression => @ logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' singleExpression ]
    -->     Type: shift
    -->     LA: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 
    -->     LA: 'T_LSQUARE' #NUMBER# 'T_DEC' #REGEX# K_NULL 
    -->     LA: 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE 
    -->     LA: K_NEW K_SUPER #STRING# K_TRUE K_CLASS 
    -->     LA: K_FALSE K_FUNCTION K_THIS #ID# 

** State #119: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN @ expressionSequence ('T_RPARAN') statement
    --> __________________
    --> #25: expressionSequence => [ @ expressionSequence ('T_COMMA') ] singleExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #120: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR @ variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement
    --> __________________
    --> #43: variableDeclarationList => [ @ variableDeclarationList ('T_COMMA') ] variableDeclaration
    -->     Type: shift
    -->     LA: 'T_LSQUARE' 'T_LBRACE' #ID# 

** State #121: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' @ [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
    --> __________________
    --> #151: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' @ [ expressionSequence ] ('T_RPARAN') statement
    -->     Type: move
    -->     LA: 'T_SEMI' 
    --> __________________
    --> #25: expressionSequence => [ @ expressionSequence ('T_COMMA') ] singleExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #122: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR @ variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
    --> __________________
    --> #43: variableDeclarationList => [ @ variableDeclarationList ('T_COMMA') ] variableDeclaration
    -->     Type: shift
    -->     LA: 'T_LSQUARE' 'T_LBRACE' #ID# 

** [FINAL] State #123: breakStatement => K_BREAK [ (#RULE_NO_LINE#) #ID# ] [ eos @ ]
    --> __________________
    --> #57: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement @ | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** [FINAL] State #124: continueStatement => K_CONTINUE [ (#RULE_NO_LINE#) #ID# ] [ eos @ ]
    --> __________________
    --> #55: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement @ | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** [FINAL] State #125: debuggerStatement => K_DEBUGGER [ eos @ ]
    --> __________________
    --> #64: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement @ | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** [FINAL] State #126: doStatement => K_DO statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos @ ]
    --> __________________
    --> #152: iterationStatement => ( doStatement @ | whileStatement | forStatement | forInStatement )
    -->     Type: reduce
    -->     Reduce: iterationStatement => @ ( doStatement | whileStatement | forStatement | forInStatement )

** [FINAL] State #127: expressionStatement => expressionSequence [ eos @ ]
    --> __________________
    --> #153: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement @ | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** [FINAL] State #128: returnStatement => K_RETURN [ (#RULE_NO_LINE#) expressionSequence ] [ eos @ ]
    --> __________________
    --> #59: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement @ | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** [FINAL] State #129: throwStatement => K_THROW (#RULE_NO_LINE#) expressionSequence [ eos @ ]
    --> __________________
    --> #154: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement @ | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** [FINAL] State #130: variableStatement => K_VAR variableDeclarationList [ eos @ ]
    --> __________________
    --> #155: statement => ( block | variableStatement @ | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** State #131: functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') @ [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #156: functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE') @
    -->     Type: pass
    -->     LA: 'T_RBRACE' 
    --> __________________
    --> #157: functionBody => [ @ functionBody ] sourceElements
    -->     Type: shift
    -->     LA: K_BREAK K_FOR K_TYPEOF 'T_LOG_NOT' K_VAR 
    -->     LA: K_IF K_DEBUGGER K_THIS K_DO 'T_BIT_NOT' 
    -->     LA: K_CLASS K_FALSE #STRING# K_RETURN K_SUPER 
    -->     LA: K_DELETE K_VOID K_WHILE 'T_INC' K_NEW 
    -->     LA: K_SWITCH 'T_LPARAN' 'T_SUB' K_NULL #REGEX# 
    -->     LA: 'T_DEC' 'T_LSQUARE' K_TRUE 'T_ADD' K_CONTINUE 
    -->     LA: 'T_SEMI' K_WITH #ID# K_TRY #NUMBER# 
    -->     LA: K_FUNCTION K_THROW 'T_LBRACE' 

** [FINAL] State #132: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement @ | debuggerStatement | functionDeclaration )
    --> __________________
    --> #72: doStatement => K_DO statement @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    -->     Type: reduce
    -->     Reduce: doStatement => K_DO @ statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #73: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #74: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') @ statement
    --> __________________
    --> #75: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement @ [ K_ELSE statement ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement [ K_ELSE statement ]
    --> __________________
    --> #76: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement @ ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE @ statement ]
    --> __________________
    --> #77: labelledStatement => #ID# 'T_COLON' statement @
    -->     Type: reduce
    -->     Reduce: labelledStatement => #ID# 'T_COLON' @ statement
    --> __________________
    --> #78: sourceElement => statement @
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #79: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ @ sourceElements ] statement
    --> __________________
    --> #79: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ sourceElements @ ] statement
    --> __________________
    --> #80: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ @ statementList ] statement
    --> __________________
    --> #80: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ statementList @ ] statement
    --> __________________
    --> #81: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #82: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement

** State #133: finallyProduction => K_FINALLY @ block
    --> __________________
    --> #4: block => @ ('T_LBRACE') [ statementList ] ('T_RBRACE')
    -->     Type: shift
    -->     LA: 'T_LBRACE' 

** State #134: catchProduction => K_CATCH @ [ ('T_LPARAN') [ assignable ] ('T_RPARAN') ] block
    --> __________________
    --> #4: block => @ ('T_LBRACE') [ statementList ] ('T_RBRACE')
    -->     Type: shift
    -->     LA: 'T_LBRACE' 
    --> __________________
    --> #158: catchProduction => K_CATCH [ ('T_LPARAN') @ [ assignable ] ('T_RPARAN') ] block
    -->     Type: pass
    -->     LA: 'T_LPARAN' 

** State #135: objectLiteral => @ ('T_LBRACE') [ propertyAssignments ] [ ('T_COMMA') ] ('T_RBRACE')
    --> __________________
    --> #159: objectLiteral => ('T_LBRACE') @ [ propertyAssignments ] [ ('T_COMMA') ] ('T_RBRACE')
    -->     Type: pass
    -->     LA: 'T_LBRACE' 

** [FINAL] State #136: assignable => ( #ID# @ | arrayLiteral | objectLiteral )
    --> __________________
    --> #160: catchProduction => K_CATCH [ ('T_LPARAN') [ assignable @ ] ('T_RPARAN') ] block
    -->     Type: reduce
    -->     Reduce: catchProduction => K_CATCH [ ('T_LPARAN') @ [ assignable ] ('T_RPARAN') ] block
    --> __________________
    --> #161: formalParameterArg => assignable @
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #162: formalParameterList => [ formalParameterList ('T_COMMA') ] assignable @
    -->     Type: reduce
    -->     Reduce: formalParameterList => [ @ formalParameterList ('T_COMMA') ] assignable
    --> __________________
    --> #162: formalParameterList => [ formalParameterList ('T_COMMA') ] assignable @
    -->     Type: reduce
    -->     Reduce: formalParameterList => [ formalParameterList ('T_COMMA') @ ] assignable
    --> __________________
    --> #163: variableDeclaration => assignable @ [ 'T_ASSIGN' singleExpression ]
    -->     Type: reduce
    -->     Reduce: variableDeclaration => @ assignable [ 'T_ASSIGN' singleExpression ]

** State #137: arrayLiteral => @ ('T_LSQUARE') [ elementList ] ('T_RSQUARE')
    --> __________________
    --> #164: arrayLiteral => ('T_LSQUARE') @ [ elementList ] ('T_RSQUARE')
    -->     Type: pass
    -->     LA: 'T_LSQUARE' 

** State #138: classElements => [ classElements ('T_COMMA') @ ] classElement
    --> __________________
    --> #165: classElement => @ ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' singleExpression )
    -->     Type: shift
    -->     LA: K_TRY 'T_SHARP' K_SUPER K_BREAK K_WITH 
    -->     LA: K_FINALLY K_FUNCTION K_CONTINUE K_VOID K_WHILE 
    -->     LA: K_THROW K_IN K_DELETE K_DEBUGGER K_IF 
    -->     LA: K_VAR K_TYPEOF K_FOR K_DEFAULT K_ELSE 
    -->     LA: K_CLASS K_DO K_TRUE K_NEW K_INSTANCEOF 
    -->     LA: K_LET K_CATCH 'T_SEMI' K_SWITCH #ID# 
    -->     LA: K_THIS K_FALSE #STRING# 'T_LSQUARE' K_CASE 
    -->     LA: #NUMBER# K_RETURN 

** [FINAL] State #139: classTail => ('T_LBRACE') classElements ('T_RBRACE') @
    --> __________________
    --> #166: classDeclaration => K_CLASS #ID# classTail @
    -->     Type: reduce
    -->     Reduce: classDeclaration => K_CLASS #ID# @ classTail
    --> __________________
    --> #167: classExpression => K_CLASS (#ID#) classTail @
    -->     Type: reduce
    -->     Reduce(exp): classExpression => K_CLASS (#ID#) @ classTail

** State #140: doStatement => K_DO statement K_WHILE ('T_LPARAN') @ expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #25: expressionSequence => [ @ expressionSequence ('T_COMMA') ] singleExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #141: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement @ | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    --> __________________
    --> #72: doStatement => K_DO statement @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    -->     Type: reduce
    -->     Reduce: doStatement => K_DO @ statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #73: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #74: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') @ statement
    --> __________________
    --> #75: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement @ [ K_ELSE statement ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement [ K_ELSE statement ]
    --> __________________
    --> #76: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement @ ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE @ statement ]
    --> __________________
    --> #77: labelledStatement => #ID# 'T_COLON' statement @
    -->     Type: reduce
    -->     Reduce: labelledStatement => #ID# 'T_COLON' @ statement
    --> __________________
    --> #78: sourceElement => statement @
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #79: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ @ sourceElements ] statement
    --> __________________
    --> #79: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ sourceElements @ ] statement
    --> __________________
    --> #80: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ @ statementList ] statement
    --> __________________
    --> #80: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ statementList @ ] statement
    --> __________________
    --> #81: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #82: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement

** State #142: anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody @ ] ('T_RBRACE')
    --> __________________
    --> #168: anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE') @
    -->     Type: pass
    -->     LA: 'T_RBRACE' 

** State #143: arrowFunctionBody => ( singleExpression | 'T_LBRACE' [ functionBody @ ] 'T_RBRACE' )
    --> __________________
    --> #169: arrowFunctionBody => ( singleExpression | 'T_LBRACE' [ functionBody ] 'T_RBRACE' @ )
    -->     Type: move
    -->     LA: 'T_RBRACE' 

** State #144: functionBody => [ functionBody @ ] sourceElements
    --> __________________
    --> #1: sourceElements => [ @ sourceElements ] statement
    -->     Type: shift
    -->     LA: K_BREAK K_FOR K_TYPEOF 'T_LOG_NOT' K_VAR 
    -->     LA: K_IF K_DEBUGGER K_THIS K_DO 'T_BIT_NOT' 
    -->     LA: K_CLASS K_FALSE #STRING# K_RETURN K_SUPER 
    -->     LA: K_DELETE K_VOID K_WHILE 'T_INC' K_NEW 
    -->     LA: K_SWITCH 'T_LPARAN' 'T_SUB' K_NULL #REGEX# 
    -->     LA: 'T_DEC' 'T_LSQUARE' K_TRUE 'T_ADD' K_CONTINUE 
    -->     LA: 'T_SEMI' K_WITH #ID# K_TRY #NUMBER# 
    -->     LA: K_FUNCTION K_THROW 'T_LBRACE' 

** State #145: functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody @ ] ('T_RBRACE')
    --> __________________
    --> #156: functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE') @
    -->     Type: pass
    -->     LA: 'T_RBRACE' 

** State #146: methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody @ ] ('T_RBRACE')
    --> __________________
    --> #170: methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE') @
    -->     Type: pass
    -->     LA: 'T_RBRACE' 

** [FINAL] State #147: caseClauses => caseClause @ [ caseClauses ]
    --> __________________
    --> #171: caseClauses => @ caseClause [ caseClauses ]
    -->     Type: shift
    -->     LA: K_CASE 
    --> __________________
    --> #172: caseBlock => ('T_LBRACE') [ caseClauses @ ] [ defaultClause [ caseClauses ] ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: caseBlock => ('T_LBRACE') @ [ caseClauses ] [ defaultClause [ caseClauses ] ] ('T_RBRACE')
    --> __________________
    --> #173: caseBlock => ('T_LBRACE') [ caseClauses ] [ defaultClause [ caseClauses @ ] ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: caseBlock => ('T_LBRACE') [ caseClauses ] [ defaultClause @ [ caseClauses ] ] ('T_RBRACE')
    --> __________________
    --> #174: caseClauses => caseClause [ caseClauses @ ]
    -->     Type: reduce
    -->     Reduce: caseClauses => caseClause @ [ caseClauses ]

** State #148: caseBlock => ('T_LBRACE') [ caseClauses ] [ defaultClause @ [ caseClauses ] ] ('T_RBRACE')
    --> __________________
    --> #175: caseBlock => ('T_LBRACE') [ caseClauses ] [ defaultClause [ caseClauses ] ] ('T_RBRACE') @
    -->     Type: pass
    -->     LA: 'T_RBRACE' 
    --> __________________
    --> #171: caseClauses => @ caseClause [ caseClauses ]
    -->     Type: shift
    -->     LA: K_CASE 

** State #149: classElements => [ @ classElements ('T_COMMA') ] classElement
    --> __________________
    --> #165: classElement => @ ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' singleExpression )
    -->     Type: shift
    -->     LA: K_TRY 'T_SHARP' K_SUPER K_BREAK K_WITH 
    -->     LA: K_FINALLY K_FUNCTION K_CONTINUE K_VOID K_WHILE 
    -->     LA: K_THROW K_IN K_DELETE K_DEBUGGER K_IF 
    -->     LA: K_VAR K_TYPEOF K_FOR K_DEFAULT K_ELSE 
    -->     LA: K_CLASS K_DO K_TRUE K_NEW K_INSTANCEOF 
    -->     LA: K_LET K_CATCH 'T_SEMI' K_SWITCH #ID# 
    -->     LA: K_THIS K_FALSE #STRING# 'T_LSQUARE' K_CASE 
    -->     LA: #NUMBER# K_RETURN 

** State #150: ternaryExpression => @ logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' singleExpression ]
    --> __________________
    --> #176: logicalOrExpression => [ @ logicalOrExpression 'T_LOG_OR' ] logicalAndExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #151: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' @ [ expressionSequence ] ('T_RPARAN') statement
    --> __________________
    --> #177: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') @ statement
    -->     Type: pass
    -->     LA: 'T_RPARAN' 
    --> __________________
    --> #25: expressionSequence => [ @ expressionSequence ('T_COMMA') ] singleExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #152: iterationStatement => ( doStatement @ | whileStatement | forStatement | forInStatement )
    --> __________________
    --> #141: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement @ | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** [FINAL] State #153: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement @ | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    --> __________________
    --> #72: doStatement => K_DO statement @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    -->     Type: reduce
    -->     Reduce: doStatement => K_DO @ statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #73: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #74: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') @ statement
    --> __________________
    --> #75: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement @ [ K_ELSE statement ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement [ K_ELSE statement ]
    --> __________________
    --> #76: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement @ ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE @ statement ]
    --> __________________
    --> #77: labelledStatement => #ID# 'T_COLON' statement @
    -->     Type: reduce
    -->     Reduce: labelledStatement => #ID# 'T_COLON' @ statement
    --> __________________
    --> #78: sourceElement => statement @
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #79: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ @ sourceElements ] statement
    --> __________________
    --> #79: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ sourceElements @ ] statement
    --> __________________
    --> #80: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ @ statementList ] statement
    --> __________________
    --> #80: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ statementList @ ] statement
    --> __________________
    --> #81: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #82: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement

** [FINAL] State #154: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement @ | tryStatement | debuggerStatement | functionDeclaration )
    --> __________________
    --> #72: doStatement => K_DO statement @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    -->     Type: reduce
    -->     Reduce: doStatement => K_DO @ statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #73: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #74: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') @ statement
    --> __________________
    --> #75: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement @ [ K_ELSE statement ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement [ K_ELSE statement ]
    --> __________________
    --> #76: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement @ ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE @ statement ]
    --> __________________
    --> #77: labelledStatement => #ID# 'T_COLON' statement @
    -->     Type: reduce
    -->     Reduce: labelledStatement => #ID# 'T_COLON' @ statement
    --> __________________
    --> #78: sourceElement => statement @
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #79: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ @ sourceElements ] statement
    --> __________________
    --> #79: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ sourceElements @ ] statement
    --> __________________
    --> #80: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ @ statementList ] statement
    --> __________________
    --> #80: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ statementList @ ] statement
    --> __________________
    --> #81: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #82: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement

** [FINAL] State #155: statement => ( block | variableStatement @ | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    --> __________________
    --> #72: doStatement => K_DO statement @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    -->     Type: reduce
    -->     Reduce: doStatement => K_DO @ statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #73: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #74: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') @ statement
    --> __________________
    --> #75: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement @ [ K_ELSE statement ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement [ K_ELSE statement ]
    --> __________________
    --> #76: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement @ ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE @ statement ]
    --> __________________
    --> #77: labelledStatement => #ID# 'T_COLON' statement @
    -->     Type: reduce
    -->     Reduce: labelledStatement => #ID# 'T_COLON' @ statement
    --> __________________
    --> #78: sourceElement => statement @
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #79: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ @ sourceElements ] statement
    --> __________________
    --> #79: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ sourceElements @ ] statement
    --> __________________
    --> #80: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ @ statementList ] statement
    --> __________________
    --> #80: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ statementList @ ] statement
    --> __________________
    --> #81: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #82: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement

** [FINAL] State #156: functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE') @
    --> __________________
    --> #178: functionDecl => functionDeclaration @
    -->     Type: reduce
    -->     Reduce: functionDecl => @ functionDeclaration
    --> __________________
    --> #179: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration @ )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** State #157: functionBody => [ @ functionBody ] sourceElements
    --> __________________
    --> #1: sourceElements => [ @ sourceElements ] statement
    -->     Type: shift
    -->     LA: K_BREAK K_FOR K_TYPEOF 'T_LOG_NOT' K_VAR 
    -->     LA: K_IF K_DEBUGGER K_THIS K_DO 'T_BIT_NOT' 
    -->     LA: K_CLASS K_FALSE #STRING# K_RETURN K_SUPER 
    -->     LA: K_DELETE K_VOID K_WHILE 'T_INC' K_NEW 
    -->     LA: K_SWITCH 'T_LPARAN' 'T_SUB' K_NULL #REGEX# 
    -->     LA: 'T_DEC' 'T_LSQUARE' K_TRUE 'T_ADD' K_CONTINUE 
    -->     LA: 'T_SEMI' K_WITH #ID# K_TRY #NUMBER# 
    -->     LA: K_FUNCTION K_THROW 'T_LBRACE' 

** State #158: catchProduction => K_CATCH [ ('T_LPARAN') @ [ assignable ] ('T_RPARAN') ] block
    --> __________________
    --> #180: catchProduction => K_CATCH [ ('T_LPARAN') [ assignable ] ('T_RPARAN') @ ] block
    -->     Type: pass
    -->     LA: 'T_RPARAN' 
    --> __________________
    --> #99: assignable => @ ( #ID# | arrayLiteral | objectLiteral )
    -->     Type: shift
    -->     LA: #ID# 'T_LBRACE' 'T_LSQUARE' 

** State #159: objectLiteral => ('T_LBRACE') @ [ propertyAssignments ] [ ('T_COMMA') ] ('T_RBRACE')
    --> __________________
    --> #181: objectLiteral => ('T_LBRACE') [ propertyAssignments ] [ ('T_COMMA') ] ('T_RBRACE') @
    -->     Type: pass
    -->     LA: 'T_RBRACE' 
    --> __________________
    --> #182: propertyAssignments => [ @ propertyAssignments ('T_COMMA') ] propertyAssignment
    -->     Type: shift
    -->     LA: K_TRY #ID# K_IN 'T_BIT_NOT' K_TRUE 
    -->     LA: K_DEBUGGER K_FINALLY K_ELSE K_BREAK K_WITH 
    -->     LA: K_RETURN #REGEX# 'T_ELLIPSIS' K_CONTINUE K_CASE 
    -->     LA: K_FOR K_VAR K_NULL K_WHILE K_THROW 
    -->     LA: K_FUNCTION #STRING# K_DEFAULT 'T_LOG_NOT' K_LET 
    -->     LA: K_CATCH K_IF K_SWITCH #NUMBER# 'T_DEC' 
    -->     LA: 'T_ADD' 'T_LBRACE' 'T_SUB' 'T_LSQUARE' K_DO 
    -->     LA: K_FALSE K_NEW 'T_LPARAN' 'T_INC' K_TYPEOF 
    -->     LA: K_VOID K_DELETE K_SUPER K_CLASS K_THIS 
    -->     LA: K_INSTANCEOF 
    --> __________________
    --> #183: objectLiteral => ('T_LBRACE') [ propertyAssignments ] [ ('T_COMMA') @ ] ('T_RBRACE')
    -->     Type: pass
    -->     LA: 'T_COMMA' 

** State #160: catchProduction => K_CATCH [ ('T_LPARAN') [ assignable @ ] ('T_RPARAN') ] block
    --> __________________
    --> #180: catchProduction => K_CATCH [ ('T_LPARAN') [ assignable ] ('T_RPARAN') @ ] block
    -->     Type: pass
    -->     LA: 'T_RPARAN' 

** [FINAL] State #161: formalParameterArg => assignable @

** [FINAL] State #162: formalParameterList => [ formalParameterList ('T_COMMA') ] assignable @
    --> __________________
    --> #184: anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') [ formalParameterList @ ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') @ [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #185: arrowFunctionParameters => ( #ID# | ('T_LPARAN') [ formalParameterList @ ] ('T_RPARAN') )
    -->     Type: reduce
    -->     Reduce: arrowFunctionParameters => ( #ID# | ('T_LPARAN') @ [ formalParameterList ] ('T_RPARAN') )
    --> __________________
    --> #186: formalParameterList => [ formalParameterList @ ('T_COMMA') ] assignable
    -->     Type: recursion
    -->     LA: 'T_COMMA' 
    --> __________________
    --> #187: functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList @ ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') @ [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #188: methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList @ ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') @ [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')

** [FINAL] State #163: variableDeclaration => assignable @ [ 'T_ASSIGN' singleExpression ]
    --> __________________
    --> #189: variableDeclaration => assignable [ 'T_ASSIGN' @ singleExpression ]
    -->     Type: move
    -->     LA: 'T_ASSIGN' 
    --> __________________
    --> #190: variableDeclarationList => [ variableDeclarationList ('T_COMMA') ] variableDeclaration @
    -->     Type: reduce
    -->     Reduce: variableDeclarationList => [ @ variableDeclarationList ('T_COMMA') ] variableDeclaration
    --> __________________
    --> #190: variableDeclarationList => [ variableDeclarationList ('T_COMMA') ] variableDeclaration @
    -->     Type: reduce
    -->     Reduce: variableDeclarationList => [ variableDeclarationList ('T_COMMA') @ ] variableDeclaration

** State #164: arrayLiteral => ('T_LSQUARE') @ [ elementList ] ('T_RSQUARE')
    --> __________________
    --> #191: arrayLiteral => ('T_LSQUARE') [ elementList ] ('T_RSQUARE') @
    -->     Type: pass
    -->     LA: 'T_RSQUARE' 
    --> __________________
    --> #192: elementList => [ @ elementList ('T_COMMA') ] arrayElement
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL 'T_LSQUARE' 'T_SUB' 'T_LBRACE' 'T_BIT_NOT' 
    -->     LA: 'T_ADD' 'T_LOG_NOT' #REGEX# 'T_ELLIPSIS' 'T_DEC' 

** State #165: classElement => @ ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' singleExpression )
    --> __________________
    --> #193: propertyName => @ ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') )
    -->     Type: shift
    -->     LA: #NUMBER# 'T_LSQUARE' #STRING# K_THIS K_ELSE 
    -->     LA: #ID# K_SWITCH K_LET K_FALSE K_TRUE 
    -->     LA: K_DO K_IF K_CLASS K_CATCH K_DEFAULT 
    -->     LA: K_FOR K_FUNCTION K_DELETE K_THROW K_WHILE 
    -->     LA: K_CASE K_CONTINUE K_VOID K_RETURN K_INSTANCEOF 
    -->     LA: K_TYPEOF K_WITH K_VAR K_BREAK K_FINALLY 
    -->     LA: K_NEW K_SUPER K_DEBUGGER K_IN K_TRY 
    --> __________________
    --> #194: methodDefinition => [ @ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: shift
    -->     LA: 'T_SHARP' K_RETURN #NUMBER# 'T_LSQUARE' #STRING# 
    -->     LA: K_THIS K_ELSE #ID# K_SWITCH K_LET 
    -->     LA: K_FALSE K_TRUE K_DO K_IF K_CLASS 
    -->     LA: K_CATCH K_DEFAULT K_FOR K_FUNCTION K_DELETE 
    -->     LA: K_THROW K_WHILE K_CASE K_CONTINUE K_VOID 
    -->     LA: K_INSTANCEOF K_TYPEOF K_WITH K_VAR K_BREAK 
    -->     LA: K_FINALLY K_NEW K_SUPER K_DEBUGGER K_IN 
    -->     LA: K_TRY 
    --> __________________
    --> #6: emptyStatement => @ 'T_SEMI'
    -->     Type: shift
    -->     LA: 'T_SEMI' 
    --> __________________
    --> #195: classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' @ ] propertyName 'T_ASSIGN' singleExpression )
    -->     Type: move
    -->     LA: 'T_SHARP' 

** [FINAL] State #166: classDeclaration => K_CLASS #ID# classTail @
    --> __________________
    --> #196: statement => ( block | variableStatement | emptyStatement | classDeclaration @ | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** [FINAL] State #167: classExpression => K_CLASS (#ID#) classTail @
    --> __________________
    --> #197: functionExpression => ( anonymousFunction | classExpression @ | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
    -->     Type: reduce
    -->     Reduce(exp): functionExpression => @ ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )

** [FINAL] State #168: anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE') @
    --> __________________
    --> #198: anonymousFunction => ( functionDecl | anoymousFunctionDecl @ | arrowFunction )
    -->     Type: reduce
    -->     Reduce: anonymousFunction => @ ( functionDecl | anoymousFunctionDecl | arrowFunction )

** [FINAL] State #169: arrowFunctionBody => ( singleExpression | 'T_LBRACE' [ functionBody ] 'T_RBRACE' @ )
    --> __________________
    --> #199: arrowFunction => arrowFunctionParameters ('T_ARROW') arrowFunctionBody @
    -->     Type: reduce
    -->     Reduce: arrowFunction => arrowFunctionParameters ('T_ARROW') @ arrowFunctionBody

** [FINAL] State #170: methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE') @
    --> __________________
    --> #200: classElement => ( methodDefinition @ | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' singleExpression )
    -->     Type: reduce
    -->     Reduce: classElement => @ ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' singleExpression )

** State #171: caseClauses => @ caseClause [ caseClauses ]
    --> __________________
    --> #201: caseClause => @ K_CASE expressionSequence 'T_COLON' [ statementList ]
    -->     Type: shift
    -->     LA: K_CASE 

** State #172: caseBlock => ('T_LBRACE') [ caseClauses @ ] [ defaultClause [ caseClauses ] ] ('T_RBRACE')
    --> __________________
    --> #175: caseBlock => ('T_LBRACE') [ caseClauses ] [ defaultClause [ caseClauses ] ] ('T_RBRACE') @
    -->     Type: pass
    -->     LA: 'T_RBRACE' 
    --> __________________
    --> #202: defaultClause => @ K_DEFAULT 'T_COLON' [ statementList ]
    -->     Type: shift
    -->     LA: K_DEFAULT 

** State #173: caseBlock => ('T_LBRACE') [ caseClauses ] [ defaultClause [ caseClauses @ ] ] ('T_RBRACE')
    --> __________________
    --> #175: caseBlock => ('T_LBRACE') [ caseClauses ] [ defaultClause [ caseClauses ] ] ('T_RBRACE') @
    -->     Type: pass
    -->     LA: 'T_RBRACE' 

** [FINAL] State #174: caseClauses => caseClause [ caseClauses @ ]
    --> __________________
    --> #172: caseBlock => ('T_LBRACE') [ caseClauses @ ] [ defaultClause [ caseClauses ] ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: caseBlock => ('T_LBRACE') @ [ caseClauses ] [ defaultClause [ caseClauses ] ] ('T_RBRACE')
    --> __________________
    --> #173: caseBlock => ('T_LBRACE') [ caseClauses ] [ defaultClause [ caseClauses @ ] ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: caseBlock => ('T_LBRACE') [ caseClauses ] [ defaultClause @ [ caseClauses ] ] ('T_RBRACE')
    --> __________________
    --> #174: caseClauses => caseClause [ caseClauses @ ]
    -->     Type: reduce
    -->     Reduce: caseClauses => caseClause @ [ caseClauses ]

** [FINAL] State #175: caseBlock => ('T_LBRACE') [ caseClauses ] [ defaultClause [ caseClauses ] ] ('T_RBRACE') @
    --> __________________
    --> #203: switchStatement => K_SWITCH ('T_LPARAN') expressionSequence ('T_RPARAN') caseBlock @
    -->     Type: reduce
    -->     Reduce: switchStatement => K_SWITCH ('T_LPARAN') expressionSequence ('T_RPARAN') @ caseBlock

** State #176: logicalOrExpression => [ @ logicalOrExpression 'T_LOG_OR' ] logicalAndExpression
    --> __________________
    --> #204: logicalAndExpression => [ @ logicalAndExpression 'T_LOG_AND' ] bitOrExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #177: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') @ statement
    --> __________________
    --> #2: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: shift
    -->     LA: 'T_LBRACE' K_THROW K_FUNCTION K_SWITCH #NUMBER# 
    -->     LA: K_TRY #ID# K_WITH 'T_SEMI' K_CONTINUE 
    -->     LA: 'T_ADD' K_TRUE 'T_LSQUARE' 'T_DEC' #REGEX# 
    -->     LA: K_RETURN K_NULL 'T_SUB' 'T_LPARAN' K_NEW 
    -->     LA: 'T_INC' K_WHILE K_VOID K_DELETE K_SUPER 
    -->     LA: #STRING# K_FALSE K_CLASS 'T_BIT_NOT' K_DO 
    -->     LA: K_THIS K_DEBUGGER K_IF K_VAR 'T_LOG_NOT' 
    -->     LA: K_TYPEOF K_FOR K_BREAK 

** [FINAL] State #178: functionDecl => functionDeclaration @
    --> __________________
    --> #205: anonymousFunction => ( functionDecl @ | anoymousFunctionDecl | arrowFunction )
    -->     Type: reduce
    -->     Reduce: anonymousFunction => @ ( functionDecl | anoymousFunctionDecl | arrowFunction )

** [FINAL] State #179: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration @ )
    --> __________________
    --> #72: doStatement => K_DO statement @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    -->     Type: reduce
    -->     Reduce: doStatement => K_DO @ statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #73: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #74: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') @ statement
    --> __________________
    --> #75: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement @ [ K_ELSE statement ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement [ K_ELSE statement ]
    --> __________________
    --> #76: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement @ ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE @ statement ]
    --> __________________
    --> #77: labelledStatement => #ID# 'T_COLON' statement @
    -->     Type: reduce
    -->     Reduce: labelledStatement => #ID# 'T_COLON' @ statement
    --> __________________
    --> #78: sourceElement => statement @
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #79: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ @ sourceElements ] statement
    --> __________________
    --> #79: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ sourceElements @ ] statement
    --> __________________
    --> #80: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ @ statementList ] statement
    --> __________________
    --> #80: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ statementList @ ] statement
    --> __________________
    --> #81: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #82: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement

** State #180: catchProduction => K_CATCH [ ('T_LPARAN') [ assignable ] ('T_RPARAN') @ ] block
    --> __________________
    --> #4: block => @ ('T_LBRACE') [ statementList ] ('T_RBRACE')
    -->     Type: shift
    -->     LA: 'T_LBRACE' 

** [FINAL] State #181: objectLiteral => ('T_LBRACE') [ propertyAssignments ] [ ('T_COMMA') ] ('T_RBRACE') @
    --> __________________
    --> #206: assignable => ( #ID# | arrayLiteral | objectLiteral @ )
    -->     Type: reduce
    -->     Reduce: assignable => @ ( #ID# | arrayLiteral | objectLiteral )
    --> __________________
    --> #207: objectLiteralExpression => objectLiteral @
    -->     Type: reduce
    -->     Reduce(exp): objectLiteralExpression => @ objectLiteral

** State #182: propertyAssignments => [ @ propertyAssignments ('T_COMMA') ] propertyAssignment
    --> __________________
    --> #208: propertyAssignment => @ ( propertyExpressionAssignment | computedPropertyExpressionAssignment | propertyShorthand )
    -->     Type: shift
    -->     LA: K_INSTANCEOF K_THIS K_CLASS #STRING# K_SUPER 
    -->     LA: K_DELETE K_VOID K_TYPEOF 'T_INC' K_NEW 
    -->     LA: 'T_LPARAN' K_FALSE K_DO 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_ADD' 'T_DEC' 'T_ELLIPSIS' #NUMBER# 
    -->     LA: K_SWITCH K_IF K_CATCH K_LET 'T_LOG_NOT' 
    -->     LA: K_DEFAULT K_FUNCTION K_THROW K_NULL K_WHILE 
    -->     LA: K_VAR K_FOR K_CASE K_CONTINUE #REGEX# 
    -->     LA: K_RETURN K_WITH K_BREAK K_ELSE K_FINALLY 
    -->     LA: K_DEBUGGER K_TRUE 'T_BIT_NOT' K_IN #ID# 
    -->     LA: K_TRY 

** State #183: objectLiteral => ('T_LBRACE') [ propertyAssignments ] [ ('T_COMMA') @ ] ('T_RBRACE')
    --> __________________
    --> #181: objectLiteral => ('T_LBRACE') [ propertyAssignments ] [ ('T_COMMA') ] ('T_RBRACE') @
    -->     Type: pass
    -->     LA: 'T_RBRACE' 

** State #184: anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') [ formalParameterList @ ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #209: anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') @ ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: pass
    -->     LA: 'T_RPARAN' 

** State #185: arrowFunctionParameters => ( #ID# | ('T_LPARAN') [ formalParameterList @ ] ('T_RPARAN') )
    --> __________________
    --> #210: arrowFunctionParameters => ( #ID# | ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') @ )
    -->     Type: pass
    -->     LA: 'T_RPARAN' 

** State #186: formalParameterList => [ formalParameterList @ ('T_COMMA') ] assignable
    --> __________________
    --> #211: formalParameterList => [ formalParameterList ('T_COMMA') @ ] assignable
    -->     Type: pass
    -->     LA: 'T_COMMA' 

** State #187: functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList @ ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #92: functionDeclaration => K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') @ ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: pass
    -->     LA: 'T_RPARAN' 

** State #188: methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList @ ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #212: methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') @ ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: pass
    -->     LA: 'T_RPARAN' 

** State #189: variableDeclaration => assignable [ 'T_ASSIGN' @ singleExpression ]
    --> __________________
    --> #47: singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #190: variableDeclarationList => [ variableDeclarationList ('T_COMMA') ] variableDeclaration @
    --> __________________
    --> #213: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList @ ) ] K_IN expressionSequence ('T_RPARAN') statement
    -->     Type: reduce
    -->     Reduce: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR @ variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement
    --> __________________
    --> #214: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList @ ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
    -->     Type: reduce
    -->     Reduce: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR @ variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
    --> __________________
    --> #215: variableDeclarationList => [ variableDeclarationList @ ('T_COMMA') ] variableDeclaration
    -->     Type: recursion
    -->     LA: 'T_COMMA' 
    --> __________________
    --> #216: variableStatement => K_VAR variableDeclarationList @ [ eos ]
    -->     Type: reduce
    -->     Reduce: variableStatement => K_VAR @ variableDeclarationList [ eos ]

** [FINAL] State #191: arrayLiteral => ('T_LSQUARE') [ elementList ] ('T_RSQUARE') @
    --> __________________
    --> #217: arrayLiteralExpression => arrayLiteral @
    -->     Type: reduce
    -->     Reduce(exp): arrayLiteralExpression => @ arrayLiteral
    --> __________________
    --> #218: assignable => ( #ID# | arrayLiteral @ | objectLiteral )
    -->     Type: reduce
    -->     Reduce: assignable => @ ( #ID# | arrayLiteral | objectLiteral )

** State #192: elementList => [ @ elementList ('T_COMMA') ] arrayElement
    --> __________________
    --> #219: arrayElement => [ @ 'T_ELLIPSIS' ] singleExpression
    -->     Type: shift
    -->     LA: 'T_ELLIPSIS' 'T_DEC' #REGEX# 'T_LOG_NOT' 'T_ADD' 
    -->     LA: 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_LSQUARE' #NUMBER# 
    -->     LA: K_NULL 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID 
    -->     LA: K_DELETE K_NEW K_SUPER #STRING# K_TRUE 
    -->     LA: K_CLASS K_FALSE K_FUNCTION K_THIS #ID# 

** State #193: propertyName => @ ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') )
    --> __________________
    --> #220: propertyName => ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') @ singleExpression ('T_RSQUARE') )
    -->     Type: pass
    -->     LA: 'T_LSQUARE' 
    --> __________________
    --> #221: identifierName => @ ( #ID# | reservedWord )
    -->     Type: shift
    -->     LA: #ID# K_SWITCH K_LET K_FALSE K_TRUE 
    -->     LA: K_DO K_IF K_CLASS K_CATCH K_DEFAULT 
    -->     LA: K_FOR K_THIS K_ELSE K_FUNCTION K_DELETE 
    -->     LA: K_THROW K_WHILE K_CASE K_CONTINUE K_VOID 
    -->     LA: K_RETURN K_INSTANCEOF K_TYPEOF K_WITH K_VAR 
    -->     LA: K_BREAK K_FINALLY K_NEW K_SUPER K_DEBUGGER 
    -->     LA: K_IN K_TRY 
    --> __________________
    --> #222: propertyName => ( identifierName | #STRING# @ | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') )
    -->     Type: move
    -->     LA: #STRING# 
    --> __________________
    --> #223: numericLiteral => @ #NUMBER#
    -->     Type: shift
    -->     LA: #NUMBER# 

** State #194: methodDefinition => [ @ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #224: methodDefinition => [ 'T_SHARP' @ ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: move
    -->     LA: 'T_SHARP' 
    --> __________________
    --> #193: propertyName => @ ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') )
    -->     Type: shift
    -->     LA: #NUMBER# 'T_LSQUARE' #STRING# K_THIS K_ELSE 
    -->     LA: #ID# K_SWITCH K_LET K_FALSE K_TRUE 
    -->     LA: K_DO K_IF K_CLASS K_CATCH K_DEFAULT 
    -->     LA: K_FOR K_FUNCTION K_DELETE K_THROW K_WHILE 
    -->     LA: K_CASE K_CONTINUE K_VOID K_RETURN K_INSTANCEOF 
    -->     LA: K_TYPEOF K_WITH K_VAR K_BREAK K_FINALLY 
    -->     LA: K_NEW K_SUPER K_DEBUGGER K_IN K_TRY 

** State #195: classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' @ ] propertyName 'T_ASSIGN' singleExpression )
    --> __________________
    --> #193: propertyName => @ ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') )
    -->     Type: shift
    -->     LA: #NUMBER# 'T_LSQUARE' #STRING# K_THIS K_ELSE 
    -->     LA: #ID# K_SWITCH K_LET K_FALSE K_TRUE 
    -->     LA: K_DO K_IF K_CLASS K_CATCH K_DEFAULT 
    -->     LA: K_FOR K_FUNCTION K_DELETE K_THROW K_WHILE 
    -->     LA: K_CASE K_CONTINUE K_VOID K_RETURN K_INSTANCEOF 
    -->     LA: K_TYPEOF K_WITH K_VAR K_BREAK K_FINALLY 
    -->     LA: K_NEW K_SUPER K_DEBUGGER K_IN K_TRY 

** [FINAL] State #196: statement => ( block | variableStatement | emptyStatement | classDeclaration @ | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    --> __________________
    --> #72: doStatement => K_DO statement @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    -->     Type: reduce
    -->     Reduce: doStatement => K_DO @ statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #73: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #74: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') @ statement
    --> __________________
    --> #75: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement @ [ K_ELSE statement ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement [ K_ELSE statement ]
    --> __________________
    --> #76: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement @ ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE @ statement ]
    --> __________________
    --> #77: labelledStatement => #ID# 'T_COLON' statement @
    -->     Type: reduce
    -->     Reduce: labelledStatement => #ID# 'T_COLON' @ statement
    --> __________________
    --> #78: sourceElement => statement @
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #79: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ @ sourceElements ] statement
    --> __________________
    --> #79: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ sourceElements @ ] statement
    --> __________________
    --> #80: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ @ statementList ] statement
    --> __________________
    --> #80: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ statementList @ ] statement
    --> __________________
    --> #81: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #82: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement

** [FINAL] State #197: functionExpression => ( anonymousFunction | classExpression @ | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
    --> __________________
    --> #225: postfixExpression => ( postfixExpression (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): postfixExpression => @ ( postfixExpression (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )

** [FINAL] State #198: anonymousFunction => ( functionDecl | anoymousFunctionDecl @ | arrowFunction )
    --> __________________
    --> #226: functionExpression => ( anonymousFunction @ | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
    -->     Type: reduce
    -->     Reduce(exp): functionExpression => @ ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )

** [FINAL] State #199: arrowFunction => arrowFunctionParameters ('T_ARROW') arrowFunctionBody @
    --> __________________
    --> #227: anonymousFunction => ( functionDecl | anoymousFunctionDecl | arrowFunction @ )
    -->     Type: reduce
    -->     Reduce: anonymousFunction => @ ( functionDecl | anoymousFunctionDecl | arrowFunction )

** [FINAL] State #200: classElement => ( methodDefinition @ | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' singleExpression )
    --> __________________
    --> #71: classElements => [ classElements ('T_COMMA') ] classElement @
    -->     Type: reduce
    -->     Reduce: classElements => [ @ classElements ('T_COMMA') ] classElement
    --> __________________
    --> #71: classElements => [ classElements ('T_COMMA') ] classElement @
    -->     Type: reduce
    -->     Reduce: classElements => [ classElements ('T_COMMA') @ ] classElement

** State #201: caseClause => @ K_CASE expressionSequence 'T_COLON' [ statementList ]
    --> __________________
    --> #228: caseClause => K_CASE @ expressionSequence 'T_COLON' [ statementList ]
    -->     Type: move
    -->     LA: K_CASE 

** State #202: defaultClause => @ K_DEFAULT 'T_COLON' [ statementList ]
    --> __________________
    --> #229: defaultClause => K_DEFAULT @ 'T_COLON' [ statementList ]
    -->     Type: move
    -->     LA: K_DEFAULT 

** [FINAL] State #203: switchStatement => K_SWITCH ('T_LPARAN') expressionSequence ('T_RPARAN') caseBlock @
    --> __________________
    --> #230: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement @ | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** State #204: logicalAndExpression => [ @ logicalAndExpression 'T_LOG_AND' ] bitOrExpression
    --> __________________
    --> #231: bitOrExpression => [ @ bitOrExpression 'T_BIT_OR' ] bitXOrExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #205: anonymousFunction => ( functionDecl @ | anoymousFunctionDecl | arrowFunction )
    --> __________________
    --> #226: functionExpression => ( anonymousFunction @ | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
    -->     Type: reduce
    -->     Reduce(exp): functionExpression => @ ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )

** [FINAL] State #206: assignable => ( #ID# | arrayLiteral | objectLiteral @ )
    --> __________________
    --> #160: catchProduction => K_CATCH [ ('T_LPARAN') [ assignable @ ] ('T_RPARAN') ] block
    -->     Type: reduce
    -->     Reduce: catchProduction => K_CATCH [ ('T_LPARAN') @ [ assignable ] ('T_RPARAN') ] block
    --> __________________
    --> #161: formalParameterArg => assignable @
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #162: formalParameterList => [ formalParameterList ('T_COMMA') ] assignable @
    -->     Type: reduce
    -->     Reduce: formalParameterList => [ @ formalParameterList ('T_COMMA') ] assignable
    --> __________________
    --> #162: formalParameterList => [ formalParameterList ('T_COMMA') ] assignable @
    -->     Type: reduce
    -->     Reduce: formalParameterList => [ formalParameterList ('T_COMMA') @ ] assignable
    --> __________________
    --> #163: variableDeclaration => assignable @ [ 'T_ASSIGN' singleExpression ]
    -->     Type: reduce
    -->     Reduce: variableDeclaration => @ assignable [ 'T_ASSIGN' singleExpression ]

** [FINAL] State #207: objectLiteralExpression => objectLiteral @
    --> __________________
    --> #232: functionExpression => ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression @ | parenthesizedExpression )
    -->     Type: reduce
    -->     Reduce(exp): functionExpression => @ ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )

** State #208: propertyAssignment => @ ( propertyExpressionAssignment | computedPropertyExpressionAssignment | propertyShorthand )
    --> __________________
    --> #233: propertyShorthand => [ @ 'T_ELLIPSIS' ] singleExpression
    -->     Type: shift
    -->     LA: 'T_ELLIPSIS' 'T_DEC' #REGEX# 'T_LOG_NOT' 'T_ADD' 
    -->     LA: 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_LSQUARE' #NUMBER# 
    -->     LA: K_NULL 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID 
    -->     LA: K_DELETE K_NEW K_SUPER #STRING# K_TRUE 
    -->     LA: K_CLASS K_FALSE K_FUNCTION K_THIS #ID# 
    --> __________________
    --> #234: propertyExpressionAssignment => @ propertyName ('T_COLON') singleExpression
    -->     Type: shift
    -->     LA: #NUMBER# 'T_LSQUARE' #STRING# K_THIS K_ELSE 
    -->     LA: #ID# K_SWITCH K_LET K_FALSE K_TRUE 
    -->     LA: K_DO K_IF K_CLASS K_CATCH K_DEFAULT 
    -->     LA: K_FOR K_FUNCTION K_DELETE K_THROW K_WHILE 
    -->     LA: K_CASE K_CONTINUE K_VOID K_RETURN K_INSTANCEOF 
    -->     LA: K_TYPEOF K_WITH K_VAR K_BREAK K_FINALLY 
    -->     LA: K_NEW K_SUPER K_DEBUGGER K_IN K_TRY 
    --> __________________
    --> #235: computedPropertyExpressionAssignment => @ ('T_LPARAN') singleExpression ('T_RPARAN') ('T_COLON') singleExpression
    -->     Type: shift
    -->     LA: 'T_LPARAN' 

** State #209: anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') @ ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #236: anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') @ [ functionBody ] ('T_RBRACE')
    -->     Type: pass
    -->     LA: 'T_LBRACE' 

** [FINAL] State #210: arrowFunctionParameters => ( #ID# | ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') @ )
    --> __________________
    --> #237: arrowFunction => arrowFunctionParameters @ ('T_ARROW') arrowFunctionBody
    -->     Type: reduce
    -->     Reduce: arrowFunction => @ arrowFunctionParameters ('T_ARROW') arrowFunctionBody

** State #211: formalParameterList => [ formalParameterList ('T_COMMA') @ ] assignable
    --> __________________
    --> #99: assignable => @ ( #ID# | arrayLiteral | objectLiteral )
    -->     Type: shift
    -->     LA: #ID# 'T_LBRACE' 'T_LSQUARE' 

** State #212: methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') @ ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #238: methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') @ [ functionBody ] ('T_RBRACE')
    -->     Type: pass
    -->     LA: 'T_LBRACE' 

** State #213: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList @ ) ] K_IN expressionSequence ('T_RPARAN') statement
    --> __________________
    --> #119: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN @ expressionSequence ('T_RPARAN') statement
    -->     Type: move
    -->     LA: K_IN 

** State #214: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList @ ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
    --> __________________
    --> #121: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' @ [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
    -->     Type: move
    -->     LA: 'T_SEMI' 

** State #215: variableDeclarationList => [ variableDeclarationList @ ('T_COMMA') ] variableDeclaration
    --> __________________
    --> #239: variableDeclarationList => [ variableDeclarationList ('T_COMMA') @ ] variableDeclaration
    -->     Type: pass
    -->     LA: 'T_COMMA' 

** [FINAL] State #216: variableStatement => K_VAR variableDeclarationList @ [ eos ]
    --> __________________
    --> #53: eos => @ ( ('T_SEMI') | #END# )
    -->     Type: shift
    -->     LA: 'T_SEMI' #END# 
    --> __________________
    --> #155: statement => ( block | variableStatement @ | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** [FINAL] State #217: arrayLiteralExpression => arrayLiteral @
    --> __________________
    --> #240: functionExpression => ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression @ | objectLiteralExpression | parenthesizedExpression )
    -->     Type: reduce
    -->     Reduce(exp): functionExpression => @ ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )

** [FINAL] State #218: assignable => ( #ID# | arrayLiteral @ | objectLiteral )
    --> __________________
    --> #160: catchProduction => K_CATCH [ ('T_LPARAN') [ assignable @ ] ('T_RPARAN') ] block
    -->     Type: reduce
    -->     Reduce: catchProduction => K_CATCH [ ('T_LPARAN') @ [ assignable ] ('T_RPARAN') ] block
    --> __________________
    --> #161: formalParameterArg => assignable @
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #162: formalParameterList => [ formalParameterList ('T_COMMA') ] assignable @
    -->     Type: reduce
    -->     Reduce: formalParameterList => [ @ formalParameterList ('T_COMMA') ] assignable
    --> __________________
    --> #162: formalParameterList => [ formalParameterList ('T_COMMA') ] assignable @
    -->     Type: reduce
    -->     Reduce: formalParameterList => [ formalParameterList ('T_COMMA') @ ] assignable
    --> __________________
    --> #163: variableDeclaration => assignable @ [ 'T_ASSIGN' singleExpression ]
    -->     Type: reduce
    -->     Reduce: variableDeclaration => @ assignable [ 'T_ASSIGN' singleExpression ]

** State #219: arrayElement => [ @ 'T_ELLIPSIS' ] singleExpression
    --> __________________
    --> #241: arrayElement => [ 'T_ELLIPSIS' @ ] singleExpression
    -->     Type: move
    -->     LA: 'T_ELLIPSIS' 
    --> __________________
    --> #47: singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #220: propertyName => ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') @ singleExpression ('T_RSQUARE') )
    --> __________________
    --> #47: singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #221: identifierName => @ ( #ID# | reservedWord )
    --> __________________
    --> #242: reservedWord => @ ( keyword | K_TRUE | K_FALSE )
    -->     Type: shift
    -->     LA: K_FALSE K_TRUE K_DO K_IF K_CLASS 
    -->     LA: K_CATCH K_DEFAULT K_FOR K_THIS K_ELSE 
    -->     LA: K_FUNCTION K_DELETE K_THROW K_WHILE K_CASE 
    -->     LA: K_SWITCH K_LET K_CONTINUE K_VOID K_RETURN 
    -->     LA: K_INSTANCEOF K_TYPEOF K_WITH K_VAR K_BREAK 
    -->     LA: K_FINALLY K_NEW K_SUPER K_DEBUGGER K_IN 
    -->     LA: K_TRY 
    --> __________________
    --> #243: identifierName => ( #ID# @ | reservedWord )
    -->     Type: move
    -->     LA: #ID# 

** [FINAL] State #222: propertyName => ( identifierName | #STRING# @ | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') )
    --> __________________
    --> #244: classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName @ 'T_ASSIGN' singleExpression )
    -->     Type: reduce
    -->     Reduce: classElement => @ ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' singleExpression )
    --> __________________
    --> #244: classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName @ 'T_ASSIGN' singleExpression )
    -->     Type: reduce
    -->     Reduce: classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' @ ] propertyName 'T_ASSIGN' singleExpression )
    --> __________________
    --> #245: methodDefinition => [ 'T_SHARP' ] propertyName @ ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: methodDefinition => [ @ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #245: methodDefinition => [ 'T_SHARP' ] propertyName @ ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: methodDefinition => [ 'T_SHARP' @ ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #246: propertyExpressionAssignment => propertyName @ ('T_COLON') singleExpression
    -->     Type: reduce
    -->     Reduce: propertyExpressionAssignment => @ propertyName ('T_COLON') singleExpression

** State #223: numericLiteral => @ #NUMBER#
    --> __________________
    --> #247: numericLiteral => #NUMBER# @
    -->     Type: move
    -->     LA: #NUMBER# 

** State #224: methodDefinition => [ 'T_SHARP' @ ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #193: propertyName => @ ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') )
    -->     Type: shift
    -->     LA: #NUMBER# 'T_LSQUARE' #STRING# K_THIS K_ELSE 
    -->     LA: #ID# K_SWITCH K_LET K_FALSE K_TRUE 
    -->     LA: K_DO K_IF K_CLASS K_CATCH K_DEFAULT 
    -->     LA: K_FOR K_FUNCTION K_DELETE K_THROW K_WHILE 
    -->     LA: K_CASE K_CONTINUE K_VOID K_RETURN K_INSTANCEOF 
    -->     LA: K_TYPEOF K_WITH K_VAR K_BREAK K_FINALLY 
    -->     LA: K_NEW K_SUPER K_DEBUGGER K_IN K_TRY 

** [FINAL] State #225: postfixExpression => ( postfixExpression (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression @ )
    --> __________________
    --> #248: newExpression => ( K_NEW singleExpression [ arguments ] | postfixExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): newExpression => @ ( K_NEW singleExpression [ arguments ] | postfixExpression )
    --> __________________
    --> #249: postfixExpression => ( postfixExpression @ (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )
    -->     Type: recursion

** [FINAL] State #226: functionExpression => ( anonymousFunction @ | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
    --> __________________
    --> #225: postfixExpression => ( postfixExpression (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): postfixExpression => @ ( postfixExpression (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )

** [FINAL] State #227: anonymousFunction => ( functionDecl | anoymousFunctionDecl | arrowFunction @ )
    --> __________________
    --> #226: functionExpression => ( anonymousFunction @ | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
    -->     Type: reduce
    -->     Reduce(exp): functionExpression => @ ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )

** State #228: caseClause => K_CASE @ expressionSequence 'T_COLON' [ statementList ]
    --> __________________
    --> #25: expressionSequence => [ @ expressionSequence ('T_COMMA') ] singleExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #229: defaultClause => K_DEFAULT @ 'T_COLON' [ statementList ]
    --> __________________
    --> #250: defaultClause => K_DEFAULT 'T_COLON' @ [ statementList ]
    -->     Type: move
    -->     LA: 'T_COLON' 

** [FINAL] State #230: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement @ | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    --> __________________
    --> #72: doStatement => K_DO statement @ K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    -->     Type: reduce
    -->     Reduce: doStatement => K_DO @ statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #73: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #74: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') @ statement
    --> __________________
    --> #75: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement @ [ K_ELSE statement ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement [ K_ELSE statement ]
    --> __________________
    --> #76: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE statement @ ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') statement [ K_ELSE @ statement ]
    --> __________________
    --> #77: labelledStatement => #ID# 'T_COLON' statement @
    -->     Type: reduce
    -->     Reduce: labelledStatement => #ID# 'T_COLON' @ statement
    --> __________________
    --> #78: sourceElement => statement @
    -->     Type: reduce
    -->     Reduce: program => @ sourceElements
    --> __________________
    --> #79: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ @ sourceElements ] statement
    --> __________________
    --> #79: sourceElements => [ sourceElements ] statement @
    -->     Type: reduce
    -->     Reduce: sourceElements => [ sourceElements @ ] statement
    --> __________________
    --> #80: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ @ statementList ] statement
    --> __________________
    --> #80: statementList => [ statementList ] statement @
    -->     Type: reduce
    -->     Reduce: statementList => [ statementList @ ] statement
    --> __________________
    --> #81: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #82: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') statement @
    -->     Type: reduce
    -->     Reduce: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement

** State #231: bitOrExpression => [ @ bitOrExpression 'T_BIT_OR' ] bitXOrExpression
    --> __________________
    --> #251: bitXOrExpression => [ @ bitXOrExpression 'T_BIT_XOR' ] bitAndExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #232: functionExpression => ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression @ | parenthesizedExpression )
    --> __________________
    --> #225: postfixExpression => ( postfixExpression (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): postfixExpression => @ ( postfixExpression (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )

** State #233: propertyShorthand => [ @ 'T_ELLIPSIS' ] singleExpression
    --> __________________
    --> #252: propertyShorthand => [ 'T_ELLIPSIS' @ ] singleExpression
    -->     Type: move
    -->     LA: 'T_ELLIPSIS' 
    --> __________________
    --> #47: singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #234: propertyExpressionAssignment => @ propertyName ('T_COLON') singleExpression
    --> __________________
    --> #193: propertyName => @ ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') )
    -->     Type: shift
    -->     LA: #NUMBER# 'T_LSQUARE' #STRING# K_THIS K_ELSE 
    -->     LA: #ID# K_SWITCH K_LET K_FALSE K_TRUE 
    -->     LA: K_DO K_IF K_CLASS K_CATCH K_DEFAULT 
    -->     LA: K_FOR K_FUNCTION K_DELETE K_THROW K_WHILE 
    -->     LA: K_CASE K_CONTINUE K_VOID K_RETURN K_INSTANCEOF 
    -->     LA: K_TYPEOF K_WITH K_VAR K_BREAK K_FINALLY 
    -->     LA: K_NEW K_SUPER K_DEBUGGER K_IN K_TRY 

** State #235: computedPropertyExpressionAssignment => @ ('T_LPARAN') singleExpression ('T_RPARAN') ('T_COLON') singleExpression
    --> __________________
    --> #253: computedPropertyExpressionAssignment => ('T_LPARAN') @ singleExpression ('T_RPARAN') ('T_COLON') singleExpression
    -->     Type: pass
    -->     LA: 'T_LPARAN' 

** State #236: anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') @ [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #168: anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE') @
    -->     Type: pass
    -->     LA: 'T_RBRACE' 
    --> __________________
    --> #157: functionBody => [ @ functionBody ] sourceElements
    -->     Type: shift
    -->     LA: K_BREAK K_FOR K_TYPEOF 'T_LOG_NOT' K_VAR 
    -->     LA: K_IF K_DEBUGGER K_THIS K_DO 'T_BIT_NOT' 
    -->     LA: K_CLASS K_FALSE #STRING# K_RETURN K_SUPER 
    -->     LA: K_DELETE K_VOID K_WHILE 'T_INC' K_NEW 
    -->     LA: K_SWITCH 'T_LPARAN' 'T_SUB' K_NULL #REGEX# 
    -->     LA: 'T_DEC' 'T_LSQUARE' K_TRUE 'T_ADD' K_CONTINUE 
    -->     LA: 'T_SEMI' K_WITH #ID# K_TRY #NUMBER# 
    -->     LA: K_FUNCTION K_THROW 'T_LBRACE' 

** State #237: arrowFunction => arrowFunctionParameters @ ('T_ARROW') arrowFunctionBody
    --> __________________
    --> #254: arrowFunction => arrowFunctionParameters ('T_ARROW') @ arrowFunctionBody
    -->     Type: pass
    -->     LA: 'T_ARROW' 

** State #238: methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') @ [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #170: methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE') @
    -->     Type: pass
    -->     LA: 'T_RBRACE' 
    --> __________________
    --> #157: functionBody => [ @ functionBody ] sourceElements
    -->     Type: shift
    -->     LA: K_BREAK K_FOR K_TYPEOF 'T_LOG_NOT' K_VAR 
    -->     LA: K_IF K_DEBUGGER K_THIS K_DO 'T_BIT_NOT' 
    -->     LA: K_CLASS K_FALSE #STRING# K_RETURN K_SUPER 
    -->     LA: K_DELETE K_VOID K_WHILE 'T_INC' K_NEW 
    -->     LA: K_SWITCH 'T_LPARAN' 'T_SUB' K_NULL #REGEX# 
    -->     LA: 'T_DEC' 'T_LSQUARE' K_TRUE 'T_ADD' K_CONTINUE 
    -->     LA: 'T_SEMI' K_WITH #ID# K_TRY #NUMBER# 
    -->     LA: K_FUNCTION K_THROW 'T_LBRACE' 

** State #239: variableDeclarationList => [ variableDeclarationList ('T_COMMA') @ ] variableDeclaration
    --> __________________
    --> #70: variableDeclaration => @ assignable [ 'T_ASSIGN' singleExpression ]
    -->     Type: shift
    -->     LA: #ID# 'T_LBRACE' 'T_LSQUARE' 

** [FINAL] State #240: functionExpression => ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression @ | objectLiteralExpression | parenthesizedExpression )
    --> __________________
    --> #225: postfixExpression => ( postfixExpression (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): postfixExpression => @ ( postfixExpression (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )

** State #241: arrayElement => [ 'T_ELLIPSIS' @ ] singleExpression
    --> __________________
    --> #47: singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #242: reservedWord => @ ( keyword | K_TRUE | K_FALSE )
    --> __________________
    --> #255: reservedWord => ( keyword | K_TRUE | K_FALSE @ )
    -->     Type: move
    -->     LA: K_FALSE 
    --> __________________
    --> #256: keyword => @ ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: shift
    -->     LA: K_IF K_CATCH K_DEFAULT K_THIS K_FUNCTION 
    -->     LA: K_THROW K_WHILE K_SWITCH K_FOR K_CASE 
    -->     LA: K_CONTINUE K_VOID K_RETURN K_INSTANCEOF K_TYPEOF 
    -->     LA: K_WITH K_DO K_BREAK K_ELSE K_FINALLY 
    -->     LA: K_NEW K_DEBUGGER K_LET K_VAR K_DELETE 
    -->     LA: K_IN K_TRY K_CLASS K_SUPER 
    --> __________________
    --> #257: reservedWord => ( keyword | K_TRUE @ | K_FALSE )
    -->     Type: move
    -->     LA: K_TRUE 

** [FINAL] State #243: identifierName => ( #ID# @ | reservedWord )
    --> __________________
    --> #258: memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' [ 'T_SHARP' ] identifierName @
    -->     Type: reduce
    -->     Reduce(exp): memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' @ [ 'T_SHARP' ] identifierName
    --> __________________
    --> #258: memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' [ 'T_SHARP' ] identifierName @
    -->     Type: reduce
    -->     Reduce(exp): memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' [ 'T_SHARP' @ ] identifierName
    --> __________________
    --> #259: propertyName => ( identifierName @ | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') )
    -->     Type: reduce
    -->     Reduce: propertyName => @ ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') )

** State #244: classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName @ 'T_ASSIGN' singleExpression )
    --> __________________
    --> #260: classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' @ singleExpression )
    -->     Type: move
    -->     LA: 'T_ASSIGN' 

** State #245: methodDefinition => [ 'T_SHARP' ] propertyName @ ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #261: methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') @ [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: pass
    -->     LA: 'T_LPARAN' 

** State #246: propertyExpressionAssignment => propertyName @ ('T_COLON') singleExpression
    --> __________________
    --> #262: propertyExpressionAssignment => propertyName ('T_COLON') @ singleExpression
    -->     Type: pass
    -->     LA: 'T_COLON' 

** [FINAL] State #247: numericLiteral => #NUMBER# @
    --> __________________
    --> #263: propertyName => ( identifierName | #STRING# | numericLiteral @ | ('T_LSQUARE') singleExpression ('T_RSQUARE') )
    -->     Type: reduce
    -->     Reduce: propertyName => @ ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') )

** [FINAL] State #248: newExpression => ( K_NEW singleExpression [ arguments ] | postfixExpression @ )
    --> __________________
    --> #264: deleteExpression => ( K_DELETE deleteExpression | newExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): deleteExpression => @ ( K_DELETE deleteExpression | newExpression )

** State #249: postfixExpression => ( postfixExpression @ (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )
    --> __________________
    --> #265: postfixExpression => ( postfixExpression (#RULE_NO_LINE#) @ ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )
    -->     Type: rule
    -->     LA: #RULE_NO_LINE# 

** [FINAL] State #250: defaultClause => K_DEFAULT 'T_COLON' @ [ statementList ]
    --> __________________
    --> #42: statementList => [ @ statementList ] statement
    -->     Type: shift
    -->     LA: K_BREAK K_FOR K_TYPEOF 'T_LOG_NOT' K_VAR 
    -->     LA: K_IF K_DEBUGGER K_THIS K_DO 'T_BIT_NOT' 
    -->     LA: K_CLASS K_FALSE #STRING# K_RETURN K_SUPER 
    -->     LA: K_DELETE K_VOID K_WHILE 'T_INC' K_NEW 
    -->     LA: K_SWITCH 'T_LPARAN' 'T_SUB' K_NULL #REGEX# 
    -->     LA: 'T_DEC' 'T_LSQUARE' K_TRUE 'T_ADD' K_CONTINUE 
    -->     LA: 'T_SEMI' K_WITH #ID# K_TRY #NUMBER# 
    -->     LA: K_FUNCTION K_THROW 'T_LBRACE' 
    --> __________________
    --> #148: caseBlock => ('T_LBRACE') [ caseClauses ] [ defaultClause @ [ caseClauses ] ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: caseBlock => ('T_LBRACE') @ [ caseClauses ] [ defaultClause [ caseClauses ] ] ('T_RBRACE')
    --> __________________
    --> #148: caseBlock => ('T_LBRACE') [ caseClauses ] [ defaultClause @ [ caseClauses ] ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: caseBlock => ('T_LBRACE') [ caseClauses @ ] [ defaultClause [ caseClauses ] ] ('T_RBRACE')

** State #251: bitXOrExpression => [ @ bitXOrExpression 'T_BIT_XOR' ] bitAndExpression
    --> __________________
    --> #266: bitAndExpression => [ @ bitAndExpression 'T_BIT_AND' ] equalityExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #252: propertyShorthand => [ 'T_ELLIPSIS' @ ] singleExpression
    --> __________________
    --> #47: singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #253: computedPropertyExpressionAssignment => ('T_LPARAN') @ singleExpression ('T_RPARAN') ('T_COLON') singleExpression
    --> __________________
    --> #47: singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #254: arrowFunction => arrowFunctionParameters ('T_ARROW') @ arrowFunctionBody
    --> __________________
    --> #267: arrowFunctionBody => @ ( singleExpression | 'T_LBRACE' [ functionBody ] 'T_RBRACE' )
    -->     Type: shift
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_LOG_NOT' 'T_ADD' 'T_SUB' 
    -->     LA: 'T_LSQUARE' #NUMBER# 'T_DEC' #REGEX# K_NULL 
    -->     LA: 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE 
    -->     LA: K_NEW K_SUPER #STRING# K_TRUE K_CLASS 
    -->     LA: K_FALSE K_FUNCTION K_THIS #ID# 

** [FINAL] State #255: reservedWord => ( keyword | K_TRUE | K_FALSE @ )
    --> __________________
    --> #268: identifierName => ( #ID# | reservedWord @ )
    -->     Type: reduce
    -->     Reduce: identifierName => @ ( #ID# | reservedWord )

** State #256: keyword => @ ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #269: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET @ )
    -->     Type: move
    -->     LA: K_LET 
    --> __________________
    --> #270: keyword => ( K_BREAK @ | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_BREAK 
    --> __________________
    --> #271: keyword => ( K_BREAK | K_DO @ | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_DO 
    --> __________________
    --> #272: keyword => ( K_BREAK | K_DO | K_INSTANCEOF @ | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_INSTANCEOF 
    --> __________________
    --> #273: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF @ | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_TYPEOF 
    --> __________________
    --> #274: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE @ | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_CASE 
    --> __________________
    --> #275: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE @ | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_ELSE 
    --> __________________
    --> #276: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW @ | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_NEW 
    --> __________________
    --> #277: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR @ | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_VAR 
    --> __________________
    --> #278: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH @ | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_CATCH 
    --> __________________
    --> #279: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY @ | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_FINALLY 
    --> __________________
    --> #280: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN @ | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_RETURN 
    --> __________________
    --> #281: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID @ | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_VOID 
    --> __________________
    --> #282: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE @ | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_CONTINUE 
    --> __________________
    --> #283: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR @ | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_FOR 
    --> __________________
    --> #284: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH @ | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_SWITCH 
    --> __________________
    --> #285: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE @ | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_WHILE 
    --> __________________
    --> #286: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER @ | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_DEBUGGER 
    --> __________________
    --> #287: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION @ | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_FUNCTION 
    --> __________________
    --> #288: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS @ | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_THIS 
    --> __________________
    --> #289: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH @ | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_WITH 
    --> __________________
    --> #290: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT @ | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_DEFAULT 
    --> __________________
    --> #291: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF @ | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_IF 
    --> __________________
    --> #292: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW @ | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_THROW 
    --> __________________
    --> #293: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE @ | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_DELETE 
    --> __________________
    --> #294: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN @ | K_TRY | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_IN 
    --> __________________
    --> #295: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY @ | K_CLASS | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_TRY 
    --> __________________
    --> #296: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS @ | K_SUPER | K_LET )
    -->     Type: move
    -->     LA: K_CLASS 
    --> __________________
    --> #297: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER @ | K_LET )
    -->     Type: move
    -->     LA: K_SUPER 

** [FINAL] State #257: reservedWord => ( keyword | K_TRUE @ | K_FALSE )
    --> __________________
    --> #268: identifierName => ( #ID# | reservedWord @ )
    -->     Type: reduce
    -->     Reduce: identifierName => @ ( #ID# | reservedWord )

** [FINAL] State #258: memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' [ 'T_SHARP' ] identifierName @
    --> __________________
    --> #298: memberDotExpression => [ memberDotExpression @ ] [ 'T_QUERY' ] 'T_DOT' [ 'T_SHARP' ] identifierName
    -->     Type: recursion
    -->     LA: 'T_QUERY' 'T_DOT' 
    --> __________________
    --> #299: postfixExpression => ( postfixExpression (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression @ | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )
    -->     Type: reduce
    -->     Reduce(exp): postfixExpression => ( postfixExpression (#RULE_NO_LINE#) @ ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )

** [FINAL] State #259: propertyName => ( identifierName @ | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') )
    --> __________________
    --> #244: classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName @ 'T_ASSIGN' singleExpression )
    -->     Type: reduce
    -->     Reduce: classElement => @ ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' singleExpression )
    --> __________________
    --> #244: classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName @ 'T_ASSIGN' singleExpression )
    -->     Type: reduce
    -->     Reduce: classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' @ ] propertyName 'T_ASSIGN' singleExpression )
    --> __________________
    --> #245: methodDefinition => [ 'T_SHARP' ] propertyName @ ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: methodDefinition => [ @ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #245: methodDefinition => [ 'T_SHARP' ] propertyName @ ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: methodDefinition => [ 'T_SHARP' @ ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #246: propertyExpressionAssignment => propertyName @ ('T_COLON') singleExpression
    -->     Type: reduce
    -->     Reduce: propertyExpressionAssignment => @ propertyName ('T_COLON') singleExpression

** State #260: classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' @ singleExpression )
    --> __________________
    --> #47: singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #261: methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') @ [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #212: methodDefinition => [ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') @ ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: pass
    -->     LA: 'T_RPARAN' 
    --> __________________
    --> #93: formalParameterList => [ @ formalParameterList ('T_COMMA') ] assignable
    -->     Type: shift
    -->     LA: 'T_LSQUARE' 'T_LBRACE' #ID# 

** State #262: propertyExpressionAssignment => propertyName ('T_COLON') @ singleExpression
    --> __________________
    --> #47: singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #263: propertyName => ( identifierName | #STRING# | numericLiteral @ | ('T_LSQUARE') singleExpression ('T_RSQUARE') )
    --> __________________
    --> #244: classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName @ 'T_ASSIGN' singleExpression )
    -->     Type: reduce
    -->     Reduce: classElement => @ ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' singleExpression )
    --> __________________
    --> #244: classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName @ 'T_ASSIGN' singleExpression )
    -->     Type: reduce
    -->     Reduce: classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' @ ] propertyName 'T_ASSIGN' singleExpression )
    --> __________________
    --> #245: methodDefinition => [ 'T_SHARP' ] propertyName @ ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: methodDefinition => [ @ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #245: methodDefinition => [ 'T_SHARP' ] propertyName @ ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: methodDefinition => [ 'T_SHARP' @ ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #246: propertyExpressionAssignment => propertyName @ ('T_COLON') singleExpression
    -->     Type: reduce
    -->     Reduce: propertyExpressionAssignment => @ propertyName ('T_COLON') singleExpression

** [FINAL] State #264: deleteExpression => ( K_DELETE deleteExpression | newExpression @ )
    --> __________________
    --> #300: deleteExpression => ( K_DELETE deleteExpression @ | newExpression )
    -->     Type: reduce
    -->     Reduce(exp): deleteExpression => ( K_DELETE @ deleteExpression | newExpression )
    --> __________________
    --> #301: voidExpression => ( K_VOID voidExpression | deleteExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): voidExpression => @ ( K_VOID voidExpression | deleteExpression )

** State #265: postfixExpression => ( postfixExpression (#RULE_NO_LINE#) @ ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )
    --> __________________
    --> #302: postDecreaseExpression => [ @ postDecreaseExpression ] 'T_DEC'
    -->     Type: shift
    -->     LA: 'T_DEC' 
    --> __________________
    --> #303: memberIndexExpression => [ @ memberIndexExpression ] 'T_LSQUARE' expressionSequence 'T_RSQUARE'
    -->     Type: shift
    -->     LA: 'T_LSQUARE' 
    --> __________________
    --> #304: memberDotExpression => [ @ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' [ 'T_SHARP' ] identifierName
    -->     Type: shift
    -->     LA: 'T_QUERY' 'T_DOT' 
    --> __________________
    --> #305: argumentsExpression => [ @ argumentsExpression ] arguments
    -->     Type: shift
    -->     LA: 'T_LPARAN' 
    --> __________________
    --> #306: postIncrementExpression => [ @ postIncrementExpression ] 'T_INC'
    -->     Type: shift
    -->     LA: 'T_INC' 

** State #266: bitAndExpression => [ @ bitAndExpression 'T_BIT_AND' ] equalityExpression
    --> __________________
    --> #307: equalityExpression => [ @ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #267: arrowFunctionBody => @ ( singleExpression | 'T_LBRACE' [ functionBody ] 'T_RBRACE' )
    --> __________________
    --> #308: arrowFunctionBody => ( singleExpression | 'T_LBRACE' @ [ functionBody ] 'T_RBRACE' )
    -->     Type: move
    -->     LA: 'T_LBRACE' 
    --> __________________
    --> #47: singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #268: identifierName => ( #ID# | reservedWord @ )
    --> __________________
    --> #258: memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' [ 'T_SHARP' ] identifierName @
    -->     Type: reduce
    -->     Reduce(exp): memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' @ [ 'T_SHARP' ] identifierName
    --> __________________
    --> #258: memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' [ 'T_SHARP' ] identifierName @
    -->     Type: reduce
    -->     Reduce(exp): memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' [ 'T_SHARP' @ ] identifierName
    --> __________________
    --> #259: propertyName => ( identifierName @ | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') )
    -->     Type: reduce
    -->     Reduce: propertyName => @ ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') )

** [FINAL] State #269: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET @ )
    --> __________________
    --> #309: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #270: keyword => ( K_BREAK @ | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #309: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #271: keyword => ( K_BREAK | K_DO @ | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #309: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #272: keyword => ( K_BREAK | K_DO | K_INSTANCEOF @ | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #309: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #273: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF @ | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #309: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #274: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE @ | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #309: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #275: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE @ | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #309: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #276: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW @ | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #309: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #277: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR @ | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #309: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #278: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH @ | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #309: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #279: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY @ | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #309: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #280: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN @ | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #309: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #281: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID @ | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #309: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #282: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE @ | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #309: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #283: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR @ | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #309: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #284: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH @ | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #309: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #285: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE @ | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #309: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #286: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER @ | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #309: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #287: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION @ | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #309: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #288: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS @ | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #309: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #289: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH @ | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #309: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #290: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT @ | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #309: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #291: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF @ | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #309: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #292: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW @ | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #309: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #293: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE @ | K_IN | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #309: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #294: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN @ | K_TRY | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #309: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #295: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY @ | K_CLASS | K_SUPER | K_LET )
    --> __________________
    --> #309: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #296: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS @ | K_SUPER | K_LET )
    --> __________________
    --> #309: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** [FINAL] State #297: keyword => ( K_BREAK | K_DO | K_INSTANCEOF | K_TYPEOF | K_CASE | K_ELSE | K_NEW | K_VAR | K_CATCH | K_FINALLY | K_RETURN | K_VOID | K_CONTINUE | K_FOR | K_SWITCH | K_WHILE | K_DEBUGGER | K_FUNCTION | K_THIS | K_WITH | K_DEFAULT | K_IF | K_THROW | K_DELETE | K_IN | K_TRY | K_CLASS | K_SUPER @ | K_LET )
    --> __________________
    --> #309: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    -->     Type: reduce
    -->     Reduce: reservedWord => @ ( keyword | K_TRUE | K_FALSE )

** State #298: memberDotExpression => [ memberDotExpression @ ] [ 'T_QUERY' ] 'T_DOT' [ 'T_SHARP' ] identifierName
    --> __________________
    --> #310: memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' @ [ 'T_SHARP' ] identifierName
    -->     Type: move
    -->     LA: 'T_DOT' 
    --> __________________
    --> #311: memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' @ ] 'T_DOT' [ 'T_SHARP' ] identifierName
    -->     Type: move
    -->     LA: 'T_QUERY' 

** [FINAL] State #299: postfixExpression => ( postfixExpression (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression @ | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )
    --> __________________
    --> #248: newExpression => ( K_NEW singleExpression [ arguments ] | postfixExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): newExpression => @ ( K_NEW singleExpression [ arguments ] | postfixExpression )
    --> __________________
    --> #249: postfixExpression => ( postfixExpression @ (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )
    -->     Type: recursion
    -->     LA: #RULE_NO_LINE# 

** [FINAL] State #300: deleteExpression => ( K_DELETE deleteExpression @ | newExpression )
    --> __________________
    --> #300: deleteExpression => ( K_DELETE deleteExpression @ | newExpression )
    -->     Type: reduce
    -->     Reduce(exp): deleteExpression => ( K_DELETE @ deleteExpression | newExpression )
    --> __________________
    --> #301: voidExpression => ( K_VOID voidExpression | deleteExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): voidExpression => @ ( K_VOID voidExpression | deleteExpression )

** [FINAL] State #301: voidExpression => ( K_VOID voidExpression | deleteExpression @ )
    --> __________________
    --> #312: typeofExpression => ( K_TYPEOF typeofExpression | voidExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): typeofExpression => @ ( K_TYPEOF typeofExpression | voidExpression )
    --> __________________
    --> #313: voidExpression => ( K_VOID voidExpression @ | deleteExpression )
    -->     Type: reduce
    -->     Reduce(exp): voidExpression => ( K_VOID @ voidExpression | deleteExpression )

** State #302: postDecreaseExpression => [ @ postDecreaseExpression ] 'T_DEC'
    --> __________________
    --> #314: postDecreaseExpression => [ postDecreaseExpression ] 'T_DEC' @
    -->     Type: move
    -->     LA: 'T_DEC' 

** State #303: memberIndexExpression => [ @ memberIndexExpression ] 'T_LSQUARE' expressionSequence 'T_RSQUARE'
    --> __________________
    --> #315: memberIndexExpression => [ memberIndexExpression ] 'T_LSQUARE' @ expressionSequence 'T_RSQUARE'
    -->     Type: move
    -->     LA: 'T_LSQUARE' 

** State #304: memberDotExpression => [ @ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' [ 'T_SHARP' ] identifierName
    --> __________________
    --> #311: memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' @ ] 'T_DOT' [ 'T_SHARP' ] identifierName
    -->     Type: move
    -->     LA: 'T_QUERY' 
    --> __________________
    --> #310: memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' @ [ 'T_SHARP' ] identifierName
    -->     Type: move
    -->     LA: 'T_DOT' 

** State #305: argumentsExpression => [ @ argumentsExpression ] arguments
    --> __________________
    --> #316: arguments => @ ('T_LPARAN') [ argument ] ('T_RPARAN')
    -->     Type: shift
    -->     LA: 'T_LPARAN' 

** State #306: postIncrementExpression => [ @ postIncrementExpression ] 'T_INC'
    --> __________________
    --> #317: postIncrementExpression => [ postIncrementExpression ] 'T_INC' @
    -->     Type: move
    -->     LA: 'T_INC' 

** State #307: equalityExpression => [ @ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression
    --> __________________
    --> #318: inExpression => [ @ inExpression K_IN ] instanceofExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #308: arrowFunctionBody => ( singleExpression | 'T_LBRACE' @ [ functionBody ] 'T_RBRACE' )
    --> __________________
    --> #169: arrowFunctionBody => ( singleExpression | 'T_LBRACE' [ functionBody ] 'T_RBRACE' @ )
    -->     Type: move
    -->     LA: 'T_RBRACE' 
    --> __________________
    --> #157: functionBody => [ @ functionBody ] sourceElements
    -->     Type: shift
    -->     LA: K_BREAK K_FOR K_TYPEOF 'T_LOG_NOT' K_VAR 
    -->     LA: K_IF K_DEBUGGER K_THIS K_DO 'T_BIT_NOT' 
    -->     LA: K_CLASS K_FALSE #STRING# K_RETURN K_SUPER 
    -->     LA: K_DELETE K_VOID K_WHILE 'T_INC' K_NEW 
    -->     LA: K_SWITCH 'T_LPARAN' 'T_SUB' K_NULL #REGEX# 
    -->     LA: 'T_DEC' 'T_LSQUARE' K_TRUE 'T_ADD' K_CONTINUE 
    -->     LA: 'T_SEMI' K_WITH #ID# K_TRY #NUMBER# 
    -->     LA: K_FUNCTION K_THROW 'T_LBRACE' 

** [FINAL] State #309: reservedWord => ( keyword @ | K_TRUE | K_FALSE )
    --> __________________
    --> #268: identifierName => ( #ID# | reservedWord @ )
    -->     Type: reduce
    -->     Reduce: identifierName => @ ( #ID# | reservedWord )

** State #310: memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' @ [ 'T_SHARP' ] identifierName
    --> __________________
    --> #221: identifierName => @ ( #ID# | reservedWord )
    -->     Type: shift
    -->     LA: #ID# K_SWITCH K_LET K_FALSE K_TRUE 
    -->     LA: K_DO K_IF K_CLASS K_CATCH K_DEFAULT 
    -->     LA: K_FOR K_THIS K_ELSE K_FUNCTION K_DELETE 
    -->     LA: K_THROW K_WHILE K_CASE K_CONTINUE K_VOID 
    -->     LA: K_RETURN K_INSTANCEOF K_TYPEOF K_WITH K_VAR 
    -->     LA: K_BREAK K_FINALLY K_NEW K_SUPER K_DEBUGGER 
    -->     LA: K_IN K_TRY 
    --> __________________
    --> #319: memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' [ 'T_SHARP' @ ] identifierName
    -->     Type: move
    -->     LA: 'T_SHARP' 

** State #311: memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' @ ] 'T_DOT' [ 'T_SHARP' ] identifierName
    --> __________________
    --> #310: memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' @ [ 'T_SHARP' ] identifierName
    -->     Type: move
    -->     LA: 'T_DOT' 

** [FINAL] State #312: typeofExpression => ( K_TYPEOF typeofExpression | voidExpression @ )
    --> __________________
    --> #320: preIncrementExpression => ( 'T_INC' preIncrementExpression | typeofExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): preIncrementExpression => @ ( 'T_INC' preIncrementExpression | typeofExpression )
    --> __________________
    --> #321: typeofExpression => ( K_TYPEOF typeofExpression @ | voidExpression )
    -->     Type: reduce
    -->     Reduce(exp): typeofExpression => ( K_TYPEOF @ typeofExpression | voidExpression )

** [FINAL] State #313: voidExpression => ( K_VOID voidExpression @ | deleteExpression )
    --> __________________
    --> #312: typeofExpression => ( K_TYPEOF typeofExpression | voidExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): typeofExpression => @ ( K_TYPEOF typeofExpression | voidExpression )
    --> __________________
    --> #313: voidExpression => ( K_VOID voidExpression @ | deleteExpression )
    -->     Type: reduce
    -->     Reduce(exp): voidExpression => ( K_VOID @ voidExpression | deleteExpression )

** [FINAL] State #314: postDecreaseExpression => [ postDecreaseExpression ] 'T_DEC' @
    --> __________________
    --> #322: postDecreaseExpression => [ postDecreaseExpression @ ] 'T_DEC'
    -->     Type: recursion
    -->     LA: 'T_DEC' 
    --> __________________
    --> #323: postfixExpression => ( postfixExpression (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression @ ) | functionExpression )
    -->     Type: reduce
    -->     Reduce(exp): postfixExpression => ( postfixExpression (#RULE_NO_LINE#) @ ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )

** State #315: memberIndexExpression => [ memberIndexExpression ] 'T_LSQUARE' @ expressionSequence 'T_RSQUARE'
    --> __________________
    --> #25: expressionSequence => [ @ expressionSequence ('T_COMMA') ] singleExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #316: arguments => @ ('T_LPARAN') [ argument ] ('T_RPARAN')
    --> __________________
    --> #324: arguments => ('T_LPARAN') @ [ argument ] ('T_RPARAN')
    -->     Type: pass
    -->     LA: 'T_LPARAN' 

** [FINAL] State #317: postIncrementExpression => [ postIncrementExpression ] 'T_INC' @
    --> __________________
    --> #325: postIncrementExpression => [ postIncrementExpression @ ] 'T_INC'
    -->     Type: recursion
    -->     LA: 'T_INC' 
    --> __________________
    --> #326: postfixExpression => ( postfixExpression (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression @ | postDecreaseExpression ) | functionExpression )
    -->     Type: reduce
    -->     Reduce(exp): postfixExpression => ( postfixExpression (#RULE_NO_LINE#) @ ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )

** State #318: inExpression => [ @ inExpression K_IN ] instanceofExpression
    --> __________________
    --> #327: instanceofExpression => [ @ instanceofExpression K_INSTANCEOF ] relationalExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #319: memberDotExpression => [ memberDotExpression ] [ 'T_QUERY' ] 'T_DOT' [ 'T_SHARP' @ ] identifierName
    --> __________________
    --> #221: identifierName => @ ( #ID# | reservedWord )
    -->     Type: shift
    -->     LA: #ID# K_SWITCH K_LET K_FALSE K_TRUE 
    -->     LA: K_DO K_IF K_CLASS K_CATCH K_DEFAULT 
    -->     LA: K_FOR K_THIS K_ELSE K_FUNCTION K_DELETE 
    -->     LA: K_THROW K_WHILE K_CASE K_CONTINUE K_VOID 
    -->     LA: K_RETURN K_INSTANCEOF K_TYPEOF K_WITH K_VAR 
    -->     LA: K_BREAK K_FINALLY K_NEW K_SUPER K_DEBUGGER 
    -->     LA: K_IN K_TRY 

** [FINAL] State #320: preIncrementExpression => ( 'T_INC' preIncrementExpression | typeofExpression @ )
    --> __________________
    --> #328: preDecreaseExpression => ( 'T_DEC' preDecreaseExpression | preIncrementExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): preDecreaseExpression => @ ( 'T_DEC' preDecreaseExpression | preIncrementExpression )
    --> __________________
    --> #329: preIncrementExpression => ( 'T_INC' preIncrementExpression @ | typeofExpression )
    -->     Type: reduce
    -->     Reduce(exp): preIncrementExpression => ( 'T_INC' @ preIncrementExpression | typeofExpression )

** [FINAL] State #321: typeofExpression => ( K_TYPEOF typeofExpression @ | voidExpression )
    --> __________________
    --> #320: preIncrementExpression => ( 'T_INC' preIncrementExpression | typeofExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): preIncrementExpression => @ ( 'T_INC' preIncrementExpression | typeofExpression )
    --> __________________
    --> #321: typeofExpression => ( K_TYPEOF typeofExpression @ | voidExpression )
    -->     Type: reduce
    -->     Reduce(exp): typeofExpression => ( K_TYPEOF @ typeofExpression | voidExpression )

** State #322: postDecreaseExpression => [ postDecreaseExpression @ ] 'T_DEC'
    --> __________________
    --> #314: postDecreaseExpression => [ postDecreaseExpression ] 'T_DEC' @
    -->     Type: move
    -->     LA: 'T_DEC' 

** [FINAL] State #323: postfixExpression => ( postfixExpression (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression @ ) | functionExpression )
    --> __________________
    --> #248: newExpression => ( K_NEW singleExpression [ arguments ] | postfixExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): newExpression => @ ( K_NEW singleExpression [ arguments ] | postfixExpression )
    --> __________________
    --> #249: postfixExpression => ( postfixExpression @ (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )
    -->     Type: recursion
    -->     LA: #RULE_NO_LINE# 

** State #324: arguments => ('T_LPARAN') @ [ argument ] ('T_RPARAN')
    --> __________________
    --> #330: arguments => ('T_LPARAN') [ argument ] ('T_RPARAN') @
    -->     Type: pass
    -->     LA: 'T_RPARAN' 
    --> __________________
    --> #331: argument => [ @ argument ('T_COMMA') ] [ ('T_ELLIPSIS') ] ( singleExpression | #ID# )
    -->     Type: shift
    -->     LA: K_THIS K_FUNCTION K_FALSE K_CLASS K_TRUE 
    -->     LA: #STRING# K_SUPER K_NEW #NUMBER# K_DELETE 
    -->     LA: 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' K_NULL 
    -->     LA: 'T_LSQUARE' 'T_SUB' 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 
    -->     LA: 'T_LOG_NOT' #REGEX# 'T_ELLIPSIS' 'T_DEC' #ID# 

** State #325: postIncrementExpression => [ postIncrementExpression @ ] 'T_INC'
    --> __________________
    --> #317: postIncrementExpression => [ postIncrementExpression ] 'T_INC' @
    -->     Type: move
    -->     LA: 'T_INC' 

** [FINAL] State #326: postfixExpression => ( postfixExpression (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression @ | postDecreaseExpression ) | functionExpression )
    --> __________________
    --> #248: newExpression => ( K_NEW singleExpression [ arguments ] | postfixExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): newExpression => @ ( K_NEW singleExpression [ arguments ] | postfixExpression )
    --> __________________
    --> #249: postfixExpression => ( postfixExpression @ (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )
    -->     Type: recursion
    -->     LA: #RULE_NO_LINE# 

** State #327: instanceofExpression => [ @ instanceofExpression K_INSTANCEOF ] relationalExpression
    --> __________________
    --> #332: relationalExpression => [ @ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #328: preDecreaseExpression => ( 'T_DEC' preDecreaseExpression | preIncrementExpression @ )
    --> __________________
    --> #333: preDecreaseExpression => ( 'T_DEC' preDecreaseExpression @ | preIncrementExpression )
    -->     Type: reduce
    -->     Reduce(exp): preDecreaseExpression => ( 'T_DEC' @ preDecreaseExpression | preIncrementExpression )
    --> __________________
    --> #334: unaryPlusExpression => ( 'T_ADD' unaryPlusExpression | preDecreaseExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): unaryPlusExpression => @ ( 'T_ADD' unaryPlusExpression | preDecreaseExpression )

** [FINAL] State #329: preIncrementExpression => ( 'T_INC' preIncrementExpression @ | typeofExpression )
    --> __________________
    --> #328: preDecreaseExpression => ( 'T_DEC' preDecreaseExpression | preIncrementExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): preDecreaseExpression => @ ( 'T_DEC' preDecreaseExpression | preIncrementExpression )
    --> __________________
    --> #329: preIncrementExpression => ( 'T_INC' preIncrementExpression @ | typeofExpression )
    -->     Type: reduce
    -->     Reduce(exp): preIncrementExpression => ( 'T_INC' @ preIncrementExpression | typeofExpression )

** [FINAL] State #330: arguments => ('T_LPARAN') [ argument ] ('T_RPARAN') @
    --> __________________
    --> #335: argumentsExpression => [ argumentsExpression ] arguments @
    -->     Type: reduce
    -->     Reduce(exp): argumentsExpression => [ @ argumentsExpression ] arguments
    --> __________________
    --> #335: argumentsExpression => [ argumentsExpression ] arguments @
    -->     Type: reduce
    -->     Reduce(exp): argumentsExpression => [ argumentsExpression @ ] arguments
    --> __________________
    --> #336: newExpression => ( K_NEW singleExpression [ arguments @ ] | postfixExpression )
    -->     Type: reduce
    -->     Reduce(exp): newExpression => ( K_NEW singleExpression @ [ arguments ] | postfixExpression )

** State #331: argument => [ @ argument ('T_COMMA') ] [ ('T_ELLIPSIS') ] ( singleExpression | #ID# )
    --> __________________
    --> #337: argument => [ argument ('T_COMMA') ] [ ('T_ELLIPSIS') @ ] ( singleExpression | #ID# )
    -->     Type: pass
    -->     LA: 'T_ELLIPSIS' 
    --> __________________
    --> #47: singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 
    --> __________________
    --> #338: argument => [ argument ('T_COMMA') ] [ ('T_ELLIPSIS') ] ( singleExpression | #ID# @ )
    -->     Type: move
    -->     LA: #ID# 

** State #332: relationalExpression => [ @ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression
    --> __________________
    --> #339: bitShiftExpression => [ @ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #333: preDecreaseExpression => ( 'T_DEC' preDecreaseExpression @ | preIncrementExpression )
    --> __________________
    --> #333: preDecreaseExpression => ( 'T_DEC' preDecreaseExpression @ | preIncrementExpression )
    -->     Type: reduce
    -->     Reduce(exp): preDecreaseExpression => ( 'T_DEC' @ preDecreaseExpression | preIncrementExpression )
    --> __________________
    --> #334: unaryPlusExpression => ( 'T_ADD' unaryPlusExpression | preDecreaseExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): unaryPlusExpression => @ ( 'T_ADD' unaryPlusExpression | preDecreaseExpression )

** [FINAL] State #334: unaryPlusExpression => ( 'T_ADD' unaryPlusExpression | preDecreaseExpression @ )
    --> __________________
    --> #340: unaryMinusExpression => ( 'T_SUB' unaryMinusExpression | unaryPlusExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): unaryMinusExpression => @ ( 'T_SUB' unaryMinusExpression | unaryPlusExpression )
    --> __________________
    --> #341: unaryPlusExpression => ( 'T_ADD' unaryPlusExpression @ | preDecreaseExpression )
    -->     Type: reduce
    -->     Reduce(exp): unaryPlusExpression => ( 'T_ADD' @ unaryPlusExpression | preDecreaseExpression )

** [FINAL] State #335: argumentsExpression => [ argumentsExpression ] arguments @
    --> __________________
    --> #342: argumentsExpression => [ argumentsExpression @ ] arguments
    -->     Type: recursion
    -->     LA: 'T_LPARAN' 
    --> __________________
    --> #343: postfixExpression => ( postfixExpression (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression | argumentsExpression @ | postIncrementExpression | postDecreaseExpression ) | functionExpression )
    -->     Type: reduce
    -->     Reduce(exp): postfixExpression => ( postfixExpression (#RULE_NO_LINE#) @ ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )

** [FINAL] State #336: newExpression => ( K_NEW singleExpression [ arguments @ ] | postfixExpression )
    --> __________________
    --> #264: deleteExpression => ( K_DELETE deleteExpression | newExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): deleteExpression => @ ( K_DELETE deleteExpression | newExpression )

** State #337: argument => [ argument ('T_COMMA') ] [ ('T_ELLIPSIS') @ ] ( singleExpression | #ID# )
    --> __________________
    --> #338: argument => [ argument ('T_COMMA') ] [ ('T_ELLIPSIS') ] ( singleExpression | #ID# @ )
    -->     Type: move
    -->     LA: #ID# 
    --> __________________
    --> #47: singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #338: argument => [ argument ('T_COMMA') ] [ ('T_ELLIPSIS') ] ( singleExpression | #ID# @ )
    --> __________________
    --> #344: argument => [ argument @ ('T_COMMA') ] [ ('T_ELLIPSIS') ] ( singleExpression | #ID# )
    -->     Type: recursion
    -->     LA: 'T_COMMA' 
    --> __________________
    --> #345: arguments => ('T_LPARAN') [ argument @ ] ('T_RPARAN')
    -->     Type: reduce
    -->     Reduce: arguments => ('T_LPARAN') @ [ argument ] ('T_RPARAN')

** State #339: bitShiftExpression => [ @ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression
    --> __________________
    --> #346: coalesceExpression => [ @ coalesceExpression 'T_COALESCE' ] additiveExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #340: unaryMinusExpression => ( 'T_SUB' unaryMinusExpression | unaryPlusExpression @ )
    --> __________________
    --> #347: bitNotExpression => ( 'T_BIT_NOT' bitNotExpression | unaryMinusExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): bitNotExpression => @ ( 'T_BIT_NOT' bitNotExpression | unaryMinusExpression )
    --> __________________
    --> #348: unaryMinusExpression => ( 'T_SUB' unaryMinusExpression @ | unaryPlusExpression )
    -->     Type: reduce
    -->     Reduce(exp): unaryMinusExpression => ( 'T_SUB' @ unaryMinusExpression | unaryPlusExpression )

** [FINAL] State #341: unaryPlusExpression => ( 'T_ADD' unaryPlusExpression @ | preDecreaseExpression )
    --> __________________
    --> #340: unaryMinusExpression => ( 'T_SUB' unaryMinusExpression | unaryPlusExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): unaryMinusExpression => @ ( 'T_SUB' unaryMinusExpression | unaryPlusExpression )
    --> __________________
    --> #341: unaryPlusExpression => ( 'T_ADD' unaryPlusExpression @ | preDecreaseExpression )
    -->     Type: reduce
    -->     Reduce(exp): unaryPlusExpression => ( 'T_ADD' @ unaryPlusExpression | preDecreaseExpression )

** State #342: argumentsExpression => [ argumentsExpression @ ] arguments
    --> __________________
    --> #316: arguments => @ ('T_LPARAN') [ argument ] ('T_RPARAN')
    -->     Type: shift
    -->     LA: 'T_LPARAN' 

** [FINAL] State #343: postfixExpression => ( postfixExpression (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression | argumentsExpression @ | postIncrementExpression | postDecreaseExpression ) | functionExpression )
    --> __________________
    --> #248: newExpression => ( K_NEW singleExpression [ arguments ] | postfixExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): newExpression => @ ( K_NEW singleExpression [ arguments ] | postfixExpression )
    --> __________________
    --> #249: postfixExpression => ( postfixExpression @ (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )
    -->     Type: recursion
    -->     LA: #RULE_NO_LINE# 

** State #344: argument => [ argument @ ('T_COMMA') ] [ ('T_ELLIPSIS') ] ( singleExpression | #ID# )
    --> __________________
    --> #349: argument => [ argument ('T_COMMA') @ ] [ ('T_ELLIPSIS') ] ( singleExpression | #ID# )
    -->     Type: pass
    -->     LA: 'T_COMMA' 

** State #345: arguments => ('T_LPARAN') [ argument @ ] ('T_RPARAN')
    --> __________________
    --> #330: arguments => ('T_LPARAN') [ argument ] ('T_RPARAN') @
    -->     Type: pass
    -->     LA: 'T_RPARAN' 

** State #346: coalesceExpression => [ @ coalesceExpression 'T_COALESCE' ] additiveExpression
    --> __________________
    --> #350: additiveExpression => [ @ additiveExpression ( 'T_ADD' | 'T_SUB' ) ] multiplicativeExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #347: bitNotExpression => ( 'T_BIT_NOT' bitNotExpression | unaryMinusExpression @ )
    --> __________________
    --> #351: bitNotExpression => ( 'T_BIT_NOT' bitNotExpression @ | unaryMinusExpression )
    -->     Type: reduce
    -->     Reduce(exp): bitNotExpression => ( 'T_BIT_NOT' @ bitNotExpression | unaryMinusExpression )
    --> __________________
    --> #352: notExpression => ( 'T_LOG_NOT' notExpression | bitNotExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): notExpression => @ ( 'T_LOG_NOT' notExpression | bitNotExpression )

** [FINAL] State #348: unaryMinusExpression => ( 'T_SUB' unaryMinusExpression @ | unaryPlusExpression )
    --> __________________
    --> #347: bitNotExpression => ( 'T_BIT_NOT' bitNotExpression | unaryMinusExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): bitNotExpression => @ ( 'T_BIT_NOT' bitNotExpression | unaryMinusExpression )
    --> __________________
    --> #348: unaryMinusExpression => ( 'T_SUB' unaryMinusExpression @ | unaryPlusExpression )
    -->     Type: reduce
    -->     Reduce(exp): unaryMinusExpression => ( 'T_SUB' @ unaryMinusExpression | unaryPlusExpression )

** State #349: argument => [ argument ('T_COMMA') @ ] [ ('T_ELLIPSIS') ] ( singleExpression | #ID# )
    --> __________________
    --> #338: argument => [ argument ('T_COMMA') ] [ ('T_ELLIPSIS') ] ( singleExpression | #ID# @ )
    -->     Type: move
    -->     LA: #ID# 
    --> __________________
    --> #337: argument => [ argument ('T_COMMA') ] [ ('T_ELLIPSIS') @ ] ( singleExpression | #ID# )
    -->     Type: pass
    -->     LA: 'T_ELLIPSIS' 
    --> __________________
    --> #47: singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #350: additiveExpression => [ @ additiveExpression ( 'T_ADD' | 'T_SUB' ) ] multiplicativeExpression
    --> __________________
    --> #353: multiplicativeExpression => [ @ multiplicativeExpression ( 'T_MUL' | 'T_DIV' | 'T_MOD' ) ] powerExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #351: bitNotExpression => ( 'T_BIT_NOT' bitNotExpression @ | unaryMinusExpression )
    --> __________________
    --> #351: bitNotExpression => ( 'T_BIT_NOT' bitNotExpression @ | unaryMinusExpression )
    -->     Type: reduce
    -->     Reduce(exp): bitNotExpression => ( 'T_BIT_NOT' @ bitNotExpression | unaryMinusExpression )
    --> __________________
    --> #352: notExpression => ( 'T_LOG_NOT' notExpression | bitNotExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): notExpression => @ ( 'T_LOG_NOT' notExpression | bitNotExpression )

** [FINAL] State #352: notExpression => ( 'T_LOG_NOT' notExpression | bitNotExpression @ )
    --> __________________
    --> #354: notExpression => ( 'T_LOG_NOT' notExpression @ | bitNotExpression )
    -->     Type: reduce
    -->     Reduce(exp): notExpression => ( 'T_LOG_NOT' @ notExpression | bitNotExpression )
    --> __________________
    --> #355: powerExpression => [ powerExpression 'T_POWER' ] notExpression @
    -->     Type: reduce
    -->     Reduce(exp): powerExpression => [ @ powerExpression 'T_POWER' ] notExpression
    --> __________________
    --> #355: powerExpression => [ powerExpression 'T_POWER' ] notExpression @
    -->     Type: reduce
    -->     Reduce(exp): powerExpression => [ powerExpression 'T_POWER' @ ] notExpression

** State #353: multiplicativeExpression => [ @ multiplicativeExpression ( 'T_MUL' | 'T_DIV' | 'T_MOD' ) ] powerExpression
    --> __________________
    --> #356: powerExpression => [ @ powerExpression 'T_POWER' ] notExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #354: notExpression => ( 'T_LOG_NOT' notExpression @ | bitNotExpression )
    --> __________________
    --> #354: notExpression => ( 'T_LOG_NOT' notExpression @ | bitNotExpression )
    -->     Type: reduce
    -->     Reduce(exp): notExpression => ( 'T_LOG_NOT' @ notExpression | bitNotExpression )
    --> __________________
    --> #355: powerExpression => [ powerExpression 'T_POWER' ] notExpression @
    -->     Type: reduce
    -->     Reduce(exp): powerExpression => [ @ powerExpression 'T_POWER' ] notExpression
    --> __________________
    --> #355: powerExpression => [ powerExpression 'T_POWER' ] notExpression @
    -->     Type: reduce
    -->     Reduce(exp): powerExpression => [ powerExpression 'T_POWER' @ ] notExpression

** [FINAL] State #355: powerExpression => [ powerExpression 'T_POWER' ] notExpression @
    --> __________________
    --> #357: multiplicativeExpression => [ multiplicativeExpression ( 'T_MUL' | 'T_DIV' | 'T_MOD' ) ] powerExpression @
    -->     Type: reduce
    -->     Reduce(exp): multiplicativeExpression => [ @ multiplicativeExpression ( 'T_MUL' | 'T_DIV' | 'T_MOD' ) ] powerExpression
    --> __________________
    --> #357: multiplicativeExpression => [ multiplicativeExpression ( 'T_MUL' | 'T_DIV' | 'T_MOD' ) ] powerExpression @
    -->     Type: reduce
    -->     Reduce(exp): multiplicativeExpression => [ multiplicativeExpression ( 'T_MUL' | 'T_DIV' | 'T_MOD' @ ) ] powerExpression
    --> __________________
    --> #357: multiplicativeExpression => [ multiplicativeExpression ( 'T_MUL' | 'T_DIV' | 'T_MOD' ) ] powerExpression @
    -->     Type: reduce
    -->     Reduce(exp): multiplicativeExpression => [ multiplicativeExpression ( 'T_MUL' @ | 'T_DIV' | 'T_MOD' ) ] powerExpression
    --> __________________
    --> #357: multiplicativeExpression => [ multiplicativeExpression ( 'T_MUL' | 'T_DIV' | 'T_MOD' ) ] powerExpression @
    -->     Type: reduce
    -->     Reduce(exp): multiplicativeExpression => [ multiplicativeExpression ( 'T_MUL' | 'T_DIV' @ | 'T_MOD' ) ] powerExpression
    --> __________________
    --> #358: powerExpression => [ powerExpression @ 'T_POWER' ] notExpression
    -->     Type: recursion
    -->     LA: 'T_POWER' 

** State #356: powerExpression => [ @ powerExpression 'T_POWER' ] notExpression
    --> __________________
    --> #359: notExpression => @ ( 'T_LOG_NOT' notExpression | bitNotExpression )
    -->     Type: shift
    -->     LA: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 
    -->     LA: 'T_LSQUARE' #NUMBER# 'T_DEC' #REGEX# K_NULL 
    -->     LA: 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE 
    -->     LA: K_NEW K_SUPER #STRING# K_TRUE K_CLASS 
    -->     LA: K_FALSE K_FUNCTION K_THIS #ID# 

** [FINAL] State #357: multiplicativeExpression => [ multiplicativeExpression ( 'T_MUL' | 'T_DIV' | 'T_MOD' ) ] powerExpression @
    --> __________________
    --> #360: additiveExpression => [ additiveExpression ( 'T_ADD' | 'T_SUB' ) ] multiplicativeExpression @
    -->     Type: reduce
    -->     Reduce(exp): additiveExpression => [ @ additiveExpression ( 'T_ADD' | 'T_SUB' ) ] multiplicativeExpression
    --> __________________
    --> #360: additiveExpression => [ additiveExpression ( 'T_ADD' | 'T_SUB' ) ] multiplicativeExpression @
    -->     Type: reduce
    -->     Reduce(exp): additiveExpression => [ additiveExpression ( 'T_ADD' | 'T_SUB' @ ) ] multiplicativeExpression
    --> __________________
    --> #360: additiveExpression => [ additiveExpression ( 'T_ADD' | 'T_SUB' ) ] multiplicativeExpression @
    -->     Type: reduce
    -->     Reduce(exp): additiveExpression => [ additiveExpression ( 'T_ADD' @ | 'T_SUB' ) ] multiplicativeExpression
    --> __________________
    --> #361: multiplicativeExpression => [ multiplicativeExpression @ ( 'T_MUL' | 'T_DIV' | 'T_MOD' ) ] powerExpression
    -->     Type: recursion
    -->     LA: 'T_DIV' 'T_MUL' 'T_MOD' 

** State #358: powerExpression => [ powerExpression @ 'T_POWER' ] notExpression
    --> __________________
    --> #362: powerExpression => [ powerExpression 'T_POWER' @ ] notExpression
    -->     Type: move
    -->     LA: 'T_POWER' 

** State #359: notExpression => @ ( 'T_LOG_NOT' notExpression | bitNotExpression )
    --> __________________
    --> #363: bitNotExpression => @ ( 'T_BIT_NOT' bitNotExpression | unaryMinusExpression )
    -->     Type: shift
    -->     LA: 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_LSQUARE' 'T_ADD' 
    -->     LA: #NUMBER# 'T_DEC' #REGEX# K_NULL 'T_LPARAN' 
    -->     LA: 'T_INC' K_TYPEOF K_VOID K_DELETE K_NEW 
    -->     LA: K_SUPER #STRING# K_TRUE K_CLASS K_FALSE 
    -->     LA: K_FUNCTION K_THIS #ID# 
    --> __________________
    --> #364: notExpression => ( 'T_LOG_NOT' @ notExpression | bitNotExpression )
    -->     Type: move
    -->     LA: 'T_LOG_NOT' 

** [FINAL] State #360: additiveExpression => [ additiveExpression ( 'T_ADD' | 'T_SUB' ) ] multiplicativeExpression @
    --> __________________
    --> #365: additiveExpression => [ additiveExpression @ ( 'T_ADD' | 'T_SUB' ) ] multiplicativeExpression
    -->     Type: recursion
    -->     LA: 'T_ADD' 'T_SUB' 
    --> __________________
    --> #366: coalesceExpression => [ coalesceExpression 'T_COALESCE' ] additiveExpression @
    -->     Type: reduce
    -->     Reduce(exp): coalesceExpression => [ @ coalesceExpression 'T_COALESCE' ] additiveExpression
    --> __________________
    --> #366: coalesceExpression => [ coalesceExpression 'T_COALESCE' ] additiveExpression @
    -->     Type: reduce
    -->     Reduce(exp): coalesceExpression => [ coalesceExpression 'T_COALESCE' @ ] additiveExpression

** State #361: multiplicativeExpression => [ multiplicativeExpression @ ( 'T_MUL' | 'T_DIV' | 'T_MOD' ) ] powerExpression
    --> __________________
    --> #367: multiplicativeExpression => [ multiplicativeExpression ( 'T_MUL' | 'T_DIV' | 'T_MOD' @ ) ] powerExpression
    -->     Type: move
    -->     LA: 'T_MOD' 
    --> __________________
    --> #368: multiplicativeExpression => [ multiplicativeExpression ( 'T_MUL' @ | 'T_DIV' | 'T_MOD' ) ] powerExpression
    -->     Type: move
    -->     LA: 'T_MUL' 
    --> __________________
    --> #369: multiplicativeExpression => [ multiplicativeExpression ( 'T_MUL' | 'T_DIV' @ | 'T_MOD' ) ] powerExpression
    -->     Type: move
    -->     LA: 'T_DIV' 

** State #362: powerExpression => [ powerExpression 'T_POWER' @ ] notExpression
    --> __________________
    --> #359: notExpression => @ ( 'T_LOG_NOT' notExpression | bitNotExpression )
    -->     Type: shift
    -->     LA: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 
    -->     LA: 'T_LSQUARE' #NUMBER# 'T_DEC' #REGEX# K_NULL 
    -->     LA: 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE 
    -->     LA: K_NEW K_SUPER #STRING# K_TRUE K_CLASS 
    -->     LA: K_FALSE K_FUNCTION K_THIS #ID# 

** State #363: bitNotExpression => @ ( 'T_BIT_NOT' bitNotExpression | unaryMinusExpression )
    --> __________________
    --> #370: unaryMinusExpression => @ ( 'T_SUB' unaryMinusExpression | unaryPlusExpression )
    -->     Type: shift
    -->     LA: 'T_SUB' 'T_ADD' #NUMBER# 'T_DEC' K_NULL 
    -->     LA: 'T_LPARAN' 'T_INC' K_TYPEOF 'T_LBRACE' K_VOID 
    -->     LA: K_DELETE #REGEX# K_NEW K_SUPER #STRING# 
    -->     LA: K_TRUE K_CLASS K_FALSE 'T_LSQUARE' K_FUNCTION 
    -->     LA: K_THIS #ID# 
    --> __________________
    --> #371: bitNotExpression => ( 'T_BIT_NOT' @ bitNotExpression | unaryMinusExpression )
    -->     Type: move
    -->     LA: 'T_BIT_NOT' 

** State #364: notExpression => ( 'T_LOG_NOT' @ notExpression | bitNotExpression )
    --> __________________
    --> #359: notExpression => @ ( 'T_LOG_NOT' notExpression | bitNotExpression )
    -->     Type: shift
    -->     LA: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 
    -->     LA: 'T_LSQUARE' #NUMBER# 'T_DEC' #REGEX# K_NULL 
    -->     LA: 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE 
    -->     LA: K_NEW K_SUPER #STRING# K_TRUE K_CLASS 
    -->     LA: K_FALSE K_FUNCTION K_THIS #ID# 

** State #365: additiveExpression => [ additiveExpression @ ( 'T_ADD' | 'T_SUB' ) ] multiplicativeExpression
    --> __________________
    --> #372: additiveExpression => [ additiveExpression ( 'T_ADD' | 'T_SUB' @ ) ] multiplicativeExpression
    -->     Type: move
    -->     LA: 'T_SUB' 
    --> __________________
    --> #373: additiveExpression => [ additiveExpression ( 'T_ADD' @ | 'T_SUB' ) ] multiplicativeExpression
    -->     Type: move
    -->     LA: 'T_ADD' 

** [FINAL] State #366: coalesceExpression => [ coalesceExpression 'T_COALESCE' ] additiveExpression @
    --> __________________
    --> #374: bitShiftExpression => [ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression @
    -->     Type: reduce
    -->     Reduce(exp): bitShiftExpression => [ @ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression
    --> __________________
    --> #374: bitShiftExpression => [ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression @
    -->     Type: reduce
    -->     Reduce(exp): bitShiftExpression => [ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' @ ) ] coalesceExpression
    --> __________________
    --> #374: bitShiftExpression => [ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression @
    -->     Type: reduce
    -->     Reduce(exp): bitShiftExpression => [ bitShiftExpression ( 'T_LSHIFT' @ | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression
    --> __________________
    --> #374: bitShiftExpression => [ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression @
    -->     Type: reduce
    -->     Reduce(exp): bitShiftExpression => [ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' @ | 'T_URSHIFT' ) ] coalesceExpression
    --> __________________
    --> #375: coalesceExpression => [ coalesceExpression @ 'T_COALESCE' ] additiveExpression
    -->     Type: recursion
    -->     LA: 'T_COALESCE' 

** State #367: multiplicativeExpression => [ multiplicativeExpression ( 'T_MUL' | 'T_DIV' | 'T_MOD' @ ) ] powerExpression
    --> __________________
    --> #356: powerExpression => [ @ powerExpression 'T_POWER' ] notExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #368: multiplicativeExpression => [ multiplicativeExpression ( 'T_MUL' @ | 'T_DIV' | 'T_MOD' ) ] powerExpression
    --> __________________
    --> #356: powerExpression => [ @ powerExpression 'T_POWER' ] notExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #369: multiplicativeExpression => [ multiplicativeExpression ( 'T_MUL' | 'T_DIV' @ | 'T_MOD' ) ] powerExpression
    --> __________________
    --> #356: powerExpression => [ @ powerExpression 'T_POWER' ] notExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #370: unaryMinusExpression => @ ( 'T_SUB' unaryMinusExpression | unaryPlusExpression )
    --> __________________
    --> #376: unaryPlusExpression => @ ( 'T_ADD' unaryPlusExpression | preDecreaseExpression )
    -->     Type: shift
    -->     LA: 'T_ADD' #NUMBER# 'T_DEC' K_NULL 'T_LPARAN' 
    -->     LA: 'T_INC' K_TYPEOF 'T_LBRACE' K_VOID K_DELETE 
    -->     LA: #REGEX# K_NEW K_SUPER #STRING# K_TRUE 
    -->     LA: K_CLASS K_FALSE 'T_LSQUARE' K_FUNCTION K_THIS 
    -->     LA: #ID# 
    --> __________________
    --> #377: unaryMinusExpression => ( 'T_SUB' @ unaryMinusExpression | unaryPlusExpression )
    -->     Type: move
    -->     LA: 'T_SUB' 

** State #371: bitNotExpression => ( 'T_BIT_NOT' @ bitNotExpression | unaryMinusExpression )
    --> __________________
    --> #363: bitNotExpression => @ ( 'T_BIT_NOT' bitNotExpression | unaryMinusExpression )
    -->     Type: shift
    -->     LA: 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_LSQUARE' 'T_ADD' 
    -->     LA: #NUMBER# 'T_DEC' #REGEX# K_NULL 'T_LPARAN' 
    -->     LA: 'T_INC' K_TYPEOF K_VOID K_DELETE K_NEW 
    -->     LA: K_SUPER #STRING# K_TRUE K_CLASS K_FALSE 
    -->     LA: K_FUNCTION K_THIS #ID# 

** State #372: additiveExpression => [ additiveExpression ( 'T_ADD' | 'T_SUB' @ ) ] multiplicativeExpression
    --> __________________
    --> #353: multiplicativeExpression => [ @ multiplicativeExpression ( 'T_MUL' | 'T_DIV' | 'T_MOD' ) ] powerExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #373: additiveExpression => [ additiveExpression ( 'T_ADD' @ | 'T_SUB' ) ] multiplicativeExpression
    --> __________________
    --> #353: multiplicativeExpression => [ @ multiplicativeExpression ( 'T_MUL' | 'T_DIV' | 'T_MOD' ) ] powerExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #374: bitShiftExpression => [ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression @
    --> __________________
    --> #378: bitShiftExpression => [ bitShiftExpression @ ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression
    -->     Type: recursion
    -->     LA: 'T_RSHIFT' 'T_LSHIFT' 'T_URSHIFT' 
    --> __________________
    --> #379: relationalExpression => [ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression @
    -->     Type: reduce
    -->     Reduce(exp): relationalExpression => [ @ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression
    --> __________________
    --> #379: relationalExpression => [ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression @
    -->     Type: reduce
    -->     Reduce(exp): relationalExpression => [ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' @ ) ] bitShiftExpression
    --> __________________
    --> #379: relationalExpression => [ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression @
    -->     Type: reduce
    -->     Reduce(exp): relationalExpression => [ relationalExpression ( 'T_LESS' @ | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression
    --> __________________
    --> #379: relationalExpression => [ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression @
    -->     Type: reduce
    -->     Reduce(exp): relationalExpression => [ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' @ | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression
    --> __________________
    --> #379: relationalExpression => [ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression @
    -->     Type: reduce
    -->     Reduce(exp): relationalExpression => [ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' @ | 'T_GREATER_EQUAL' ) ] bitShiftExpression

** State #375: coalesceExpression => [ coalesceExpression @ 'T_COALESCE' ] additiveExpression
    --> __________________
    --> #380: coalesceExpression => [ coalesceExpression 'T_COALESCE' @ ] additiveExpression
    -->     Type: move
    -->     LA: 'T_COALESCE' 

** State #376: unaryPlusExpression => @ ( 'T_ADD' unaryPlusExpression | preDecreaseExpression )
    --> __________________
    --> #381: preDecreaseExpression => @ ( 'T_DEC' preDecreaseExpression | preIncrementExpression )
    -->     Type: shift
    -->     LA: 'T_DEC' K_NULL 'T_LPARAN' 'T_INC' K_TYPEOF 
    -->     LA: 'T_LBRACE' K_VOID K_DELETE #REGEX# K_NEW 
    -->     LA: K_SUPER #STRING# K_TRUE #NUMBER# K_CLASS 
    -->     LA: K_FALSE 'T_LSQUARE' K_FUNCTION K_THIS #ID# 
    --> __________________
    --> #382: unaryPlusExpression => ( 'T_ADD' @ unaryPlusExpression | preDecreaseExpression )
    -->     Type: move
    -->     LA: 'T_ADD' 

** State #377: unaryMinusExpression => ( 'T_SUB' @ unaryMinusExpression | unaryPlusExpression )
    --> __________________
    --> #370: unaryMinusExpression => @ ( 'T_SUB' unaryMinusExpression | unaryPlusExpression )
    -->     Type: shift
    -->     LA: 'T_SUB' 'T_ADD' #NUMBER# 'T_DEC' K_NULL 
    -->     LA: 'T_LPARAN' 'T_INC' K_TYPEOF 'T_LBRACE' K_VOID 
    -->     LA: K_DELETE #REGEX# K_NEW K_SUPER #STRING# 
    -->     LA: K_TRUE K_CLASS K_FALSE 'T_LSQUARE' K_FUNCTION 
    -->     LA: K_THIS #ID# 

** State #378: bitShiftExpression => [ bitShiftExpression @ ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression
    --> __________________
    --> #383: bitShiftExpression => [ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' @ ) ] coalesceExpression
    -->     Type: move
    -->     LA: 'T_URSHIFT' 
    --> __________________
    --> #384: bitShiftExpression => [ bitShiftExpression ( 'T_LSHIFT' @ | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression
    -->     Type: move
    -->     LA: 'T_LSHIFT' 
    --> __________________
    --> #385: bitShiftExpression => [ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' @ | 'T_URSHIFT' ) ] coalesceExpression
    -->     Type: move
    -->     LA: 'T_RSHIFT' 

** [FINAL] State #379: relationalExpression => [ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression @
    --> __________________
    --> #386: instanceofExpression => [ instanceofExpression K_INSTANCEOF ] relationalExpression @
    -->     Type: reduce
    -->     Reduce(exp): instanceofExpression => [ @ instanceofExpression K_INSTANCEOF ] relationalExpression
    --> __________________
    --> #386: instanceofExpression => [ instanceofExpression K_INSTANCEOF ] relationalExpression @
    -->     Type: reduce
    -->     Reduce(exp): instanceofExpression => [ instanceofExpression K_INSTANCEOF @ ] relationalExpression
    --> __________________
    --> #387: relationalExpression => [ relationalExpression @ ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression
    -->     Type: recursion
    -->     LA: 'T_GREATER' 'T_LESS_EQUAL' 'T_LESS' 'T_GREATER_EQUAL' 

** State #380: coalesceExpression => [ coalesceExpression 'T_COALESCE' @ ] additiveExpression
    --> __________________
    --> #350: additiveExpression => [ @ additiveExpression ( 'T_ADD' | 'T_SUB' ) ] multiplicativeExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #381: preDecreaseExpression => @ ( 'T_DEC' preDecreaseExpression | preIncrementExpression )
    --> __________________
    --> #388: preIncrementExpression => @ ( 'T_INC' preIncrementExpression | typeofExpression )
    -->     Type: shift
    -->     LA: 'T_INC' K_TYPEOF 'T_LBRACE' K_VOID K_DELETE 
    -->     LA: #REGEX# K_NEW K_SUPER K_NULL 'T_LPARAN' 
    -->     LA: #STRING# K_TRUE #NUMBER# K_CLASS K_FALSE 
    -->     LA: 'T_LSQUARE' K_FUNCTION K_THIS #ID# 
    --> __________________
    --> #389: preDecreaseExpression => ( 'T_DEC' @ preDecreaseExpression | preIncrementExpression )
    -->     Type: move
    -->     LA: 'T_DEC' 

** State #382: unaryPlusExpression => ( 'T_ADD' @ unaryPlusExpression | preDecreaseExpression )
    --> __________________
    --> #376: unaryPlusExpression => @ ( 'T_ADD' unaryPlusExpression | preDecreaseExpression )
    -->     Type: shift
    -->     LA: 'T_ADD' #NUMBER# 'T_DEC' K_NULL 'T_LPARAN' 
    -->     LA: 'T_INC' K_TYPEOF 'T_LBRACE' K_VOID K_DELETE 
    -->     LA: #REGEX# K_NEW K_SUPER #STRING# K_TRUE 
    -->     LA: K_CLASS K_FALSE 'T_LSQUARE' K_FUNCTION K_THIS 
    -->     LA: #ID# 

** State #383: bitShiftExpression => [ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' @ ) ] coalesceExpression
    --> __________________
    --> #346: coalesceExpression => [ @ coalesceExpression 'T_COALESCE' ] additiveExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #384: bitShiftExpression => [ bitShiftExpression ( 'T_LSHIFT' @ | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression
    --> __________________
    --> #346: coalesceExpression => [ @ coalesceExpression 'T_COALESCE' ] additiveExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #385: bitShiftExpression => [ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' @ | 'T_URSHIFT' ) ] coalesceExpression
    --> __________________
    --> #346: coalesceExpression => [ @ coalesceExpression 'T_COALESCE' ] additiveExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #386: instanceofExpression => [ instanceofExpression K_INSTANCEOF ] relationalExpression @
    --> __________________
    --> #390: inExpression => [ inExpression K_IN ] instanceofExpression @
    -->     Type: reduce
    -->     Reduce(exp): inExpression => [ @ inExpression K_IN ] instanceofExpression
    --> __________________
    --> #390: inExpression => [ inExpression K_IN ] instanceofExpression @
    -->     Type: reduce
    -->     Reduce(exp): inExpression => [ inExpression K_IN @ ] instanceofExpression
    --> __________________
    --> #391: instanceofExpression => [ instanceofExpression @ K_INSTANCEOF ] relationalExpression
    -->     Type: recursion
    -->     LA: K_INSTANCEOF 

** State #387: relationalExpression => [ relationalExpression @ ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression
    --> __________________
    --> #392: relationalExpression => [ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' @ ) ] bitShiftExpression
    -->     Type: move
    -->     LA: 'T_GREATER_EQUAL' 
    --> __________________
    --> #393: relationalExpression => [ relationalExpression ( 'T_LESS' @ | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression
    -->     Type: move
    -->     LA: 'T_LESS' 
    --> __________________
    --> #394: relationalExpression => [ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' @ | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression
    -->     Type: move
    -->     LA: 'T_LESS_EQUAL' 
    --> __________________
    --> #395: relationalExpression => [ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' @ | 'T_GREATER_EQUAL' ) ] bitShiftExpression
    -->     Type: move
    -->     LA: 'T_GREATER' 

** State #388: preIncrementExpression => @ ( 'T_INC' preIncrementExpression | typeofExpression )
    --> __________________
    --> #396: typeofExpression => @ ( K_TYPEOF typeofExpression | voidExpression )
    -->     Type: shift
    -->     LA: K_TYPEOF 'T_LBRACE' K_VOID K_DELETE #REGEX# 
    -->     LA: K_NEW K_SUPER K_NULL 'T_LPARAN' #STRING# 
    -->     LA: K_TRUE #NUMBER# K_CLASS K_FALSE 'T_LSQUARE' 
    -->     LA: K_FUNCTION #ID# K_THIS 
    --> __________________
    --> #397: preIncrementExpression => ( 'T_INC' @ preIncrementExpression | typeofExpression )
    -->     Type: move
    -->     LA: 'T_INC' 

** State #389: preDecreaseExpression => ( 'T_DEC' @ preDecreaseExpression | preIncrementExpression )
    --> __________________
    --> #381: preDecreaseExpression => @ ( 'T_DEC' preDecreaseExpression | preIncrementExpression )
    -->     Type: shift
    -->     LA: 'T_DEC' K_NULL 'T_LPARAN' 'T_INC' K_TYPEOF 
    -->     LA: 'T_LBRACE' K_VOID K_DELETE #REGEX# K_NEW 
    -->     LA: K_SUPER #STRING# K_TRUE #NUMBER# K_CLASS 
    -->     LA: K_FALSE 'T_LSQUARE' K_FUNCTION K_THIS #ID# 

** [FINAL] State #390: inExpression => [ inExpression K_IN ] instanceofExpression @
    --> __________________
    --> #398: equalityExpression => [ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression @
    -->     Type: reduce
    -->     Reduce(exp): equalityExpression => [ @ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression
    --> __________________
    --> #398: equalityExpression => [ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression @
    -->     Type: reduce
    -->     Reduce(exp): equalityExpression => [ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' @ ) ] inExpression
    --> __________________
    --> #398: equalityExpression => [ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression @
    -->     Type: reduce
    -->     Reduce(exp): equalityExpression => [ equalityExpression ( 'T_EQUAL' @ | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression
    --> __________________
    --> #398: equalityExpression => [ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression @
    -->     Type: reduce
    -->     Reduce(exp): equalityExpression => [ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' @ | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression
    --> __________________
    --> #398: equalityExpression => [ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression @
    -->     Type: reduce
    -->     Reduce(exp): equalityExpression => [ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' @ | 'T_FNOT_EQUAL' ) ] inExpression
    --> __________________
    --> #399: inExpression => [ inExpression @ K_IN ] instanceofExpression
    -->     Type: recursion
    -->     LA: K_IN 

** State #391: instanceofExpression => [ instanceofExpression @ K_INSTANCEOF ] relationalExpression
    --> __________________
    --> #400: instanceofExpression => [ instanceofExpression K_INSTANCEOF @ ] relationalExpression
    -->     Type: move
    -->     LA: K_INSTANCEOF 

** State #392: relationalExpression => [ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' @ ) ] bitShiftExpression
    --> __________________
    --> #339: bitShiftExpression => [ @ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #393: relationalExpression => [ relationalExpression ( 'T_LESS' @ | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression
    --> __________________
    --> #339: bitShiftExpression => [ @ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #394: relationalExpression => [ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' @ | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression
    --> __________________
    --> #339: bitShiftExpression => [ @ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #395: relationalExpression => [ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' @ | 'T_GREATER_EQUAL' ) ] bitShiftExpression
    --> __________________
    --> #339: bitShiftExpression => [ @ bitShiftExpression ( 'T_LSHIFT' | 'T_RSHIFT' | 'T_URSHIFT' ) ] coalesceExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #396: typeofExpression => @ ( K_TYPEOF typeofExpression | voidExpression )
    --> __________________
    --> #401: voidExpression => @ ( K_VOID voidExpression | deleteExpression )
    -->     Type: shift
    -->     LA: K_VOID K_DELETE #REGEX# K_NEW K_SUPER 
    -->     LA: K_NULL 'T_LPARAN' #STRING# K_TRUE #NUMBER# 
    -->     LA: K_CLASS K_FALSE 'T_LSQUARE' K_FUNCTION #ID# 
    -->     LA: K_THIS 'T_LBRACE' 
    --> __________________
    --> #402: typeofExpression => ( K_TYPEOF @ typeofExpression | voidExpression )
    -->     Type: move
    -->     LA: K_TYPEOF 

** State #397: preIncrementExpression => ( 'T_INC' @ preIncrementExpression | typeofExpression )
    --> __________________
    --> #388: preIncrementExpression => @ ( 'T_INC' preIncrementExpression | typeofExpression )
    -->     Type: shift
    -->     LA: 'T_INC' K_TYPEOF 'T_LBRACE' K_VOID K_DELETE 
    -->     LA: #REGEX# K_NEW K_SUPER K_NULL 'T_LPARAN' 
    -->     LA: #STRING# K_TRUE #NUMBER# K_CLASS K_FALSE 
    -->     LA: 'T_LSQUARE' K_FUNCTION K_THIS #ID# 

** [FINAL] State #398: equalityExpression => [ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression @
    --> __________________
    --> #403: bitAndExpression => [ bitAndExpression 'T_BIT_AND' ] equalityExpression @
    -->     Type: reduce
    -->     Reduce(exp): bitAndExpression => [ @ bitAndExpression 'T_BIT_AND' ] equalityExpression
    --> __________________
    --> #403: bitAndExpression => [ bitAndExpression 'T_BIT_AND' ] equalityExpression @
    -->     Type: reduce
    -->     Reduce(exp): bitAndExpression => [ bitAndExpression 'T_BIT_AND' @ ] equalityExpression
    --> __________________
    --> #404: equalityExpression => [ equalityExpression @ ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression
    -->     Type: recursion
    -->     LA: 'T_FEQUAL' 'T_NOT_EQUAL' 'T_EQUAL' 'T_FNOT_EQUAL' 

** State #399: inExpression => [ inExpression @ K_IN ] instanceofExpression
    --> __________________
    --> #405: inExpression => [ inExpression K_IN @ ] instanceofExpression
    -->     Type: move
    -->     LA: K_IN 

** State #400: instanceofExpression => [ instanceofExpression K_INSTANCEOF @ ] relationalExpression
    --> __________________
    --> #332: relationalExpression => [ @ relationalExpression ( 'T_LESS' | 'T_LESS_EQUAL' | 'T_GREATER' | 'T_GREATER_EQUAL' ) ] bitShiftExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #401: voidExpression => @ ( K_VOID voidExpression | deleteExpression )
    --> __________________
    --> #406: deleteExpression => @ ( K_DELETE deleteExpression | newExpression )
    -->     Type: shift
    -->     LA: K_DELETE K_NEW K_SUPER #REGEX# K_NULL 
    -->     LA: #STRING# 'T_LPARAN' K_TRUE #NUMBER# K_FALSE 
    -->     LA: 'T_LSQUARE' K_FUNCTION K_THIS #ID# 'T_LBRACE' 
    -->     LA: K_CLASS 
    --> __________________
    --> #407: voidExpression => ( K_VOID @ voidExpression | deleteExpression )
    -->     Type: move
    -->     LA: K_VOID 

** State #402: typeofExpression => ( K_TYPEOF @ typeofExpression | voidExpression )
    --> __________________
    --> #396: typeofExpression => @ ( K_TYPEOF typeofExpression | voidExpression )
    -->     Type: shift
    -->     LA: K_TYPEOF 'T_LBRACE' K_VOID K_DELETE #REGEX# 
    -->     LA: K_NEW K_SUPER K_NULL 'T_LPARAN' #STRING# 
    -->     LA: K_TRUE #NUMBER# K_CLASS K_FALSE 'T_LSQUARE' 
    -->     LA: K_FUNCTION #ID# K_THIS 

** [FINAL] State #403: bitAndExpression => [ bitAndExpression 'T_BIT_AND' ] equalityExpression @
    --> __________________
    --> #408: bitAndExpression => [ bitAndExpression @ 'T_BIT_AND' ] equalityExpression
    -->     Type: recursion
    -->     LA: 'T_BIT_AND' 
    --> __________________
    --> #409: bitXOrExpression => [ bitXOrExpression 'T_BIT_XOR' ] bitAndExpression @
    -->     Type: reduce
    -->     Reduce(exp): bitXOrExpression => [ @ bitXOrExpression 'T_BIT_XOR' ] bitAndExpression
    --> __________________
    --> #409: bitXOrExpression => [ bitXOrExpression 'T_BIT_XOR' ] bitAndExpression @
    -->     Type: reduce
    -->     Reduce(exp): bitXOrExpression => [ bitXOrExpression 'T_BIT_XOR' @ ] bitAndExpression

** State #404: equalityExpression => [ equalityExpression @ ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression
    --> __________________
    --> #410: equalityExpression => [ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' @ ) ] inExpression
    -->     Type: move
    -->     LA: 'T_FNOT_EQUAL' 
    --> __________________
    --> #411: equalityExpression => [ equalityExpression ( 'T_EQUAL' @ | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression
    -->     Type: move
    -->     LA: 'T_EQUAL' 
    --> __________________
    --> #412: equalityExpression => [ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' @ | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression
    -->     Type: move
    -->     LA: 'T_NOT_EQUAL' 
    --> __________________
    --> #413: equalityExpression => [ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' @ | 'T_FNOT_EQUAL' ) ] inExpression
    -->     Type: move
    -->     LA: 'T_FEQUAL' 

** State #405: inExpression => [ inExpression K_IN @ ] instanceofExpression
    --> __________________
    --> #327: instanceofExpression => [ @ instanceofExpression K_INSTANCEOF ] relationalExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #406: deleteExpression => @ ( K_DELETE deleteExpression | newExpression )
    --> __________________
    --> #414: newExpression => @ ( K_NEW singleExpression [ arguments ] | postfixExpression )
    -->     Type: shift
    -->     LA: K_NEW K_SUPER #REGEX# K_NULL #STRING# 
    -->     LA: 'T_LPARAN' K_TRUE #NUMBER# K_FALSE 'T_LSQUARE' 
    -->     LA: K_FUNCTION K_THIS #ID# 'T_LBRACE' K_CLASS 
    --> __________________
    --> #415: deleteExpression => ( K_DELETE @ deleteExpression | newExpression )
    -->     Type: move
    -->     LA: K_DELETE 

** State #407: voidExpression => ( K_VOID @ voidExpression | deleteExpression )
    --> __________________
    --> #401: voidExpression => @ ( K_VOID voidExpression | deleteExpression )
    -->     Type: shift
    -->     LA: K_VOID K_DELETE #REGEX# K_NEW K_SUPER 
    -->     LA: K_NULL 'T_LPARAN' #STRING# K_TRUE #NUMBER# 
    -->     LA: K_CLASS K_FALSE 'T_LSQUARE' K_FUNCTION #ID# 
    -->     LA: K_THIS 'T_LBRACE' 

** State #408: bitAndExpression => [ bitAndExpression @ 'T_BIT_AND' ] equalityExpression
    --> __________________
    --> #416: bitAndExpression => [ bitAndExpression 'T_BIT_AND' @ ] equalityExpression
    -->     Type: move
    -->     LA: 'T_BIT_AND' 

** [FINAL] State #409: bitXOrExpression => [ bitXOrExpression 'T_BIT_XOR' ] bitAndExpression @
    --> __________________
    --> #417: bitOrExpression => [ bitOrExpression 'T_BIT_OR' ] bitXOrExpression @
    -->     Type: reduce
    -->     Reduce(exp): bitOrExpression => [ @ bitOrExpression 'T_BIT_OR' ] bitXOrExpression
    --> __________________
    --> #417: bitOrExpression => [ bitOrExpression 'T_BIT_OR' ] bitXOrExpression @
    -->     Type: reduce
    -->     Reduce(exp): bitOrExpression => [ bitOrExpression 'T_BIT_OR' @ ] bitXOrExpression
    --> __________________
    --> #418: bitXOrExpression => [ bitXOrExpression @ 'T_BIT_XOR' ] bitAndExpression
    -->     Type: recursion
    -->     LA: 'T_BIT_XOR' 

** State #410: equalityExpression => [ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' @ ) ] inExpression
    --> __________________
    --> #318: inExpression => [ @ inExpression K_IN ] instanceofExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #411: equalityExpression => [ equalityExpression ( 'T_EQUAL' @ | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression
    --> __________________
    --> #318: inExpression => [ @ inExpression K_IN ] instanceofExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #412: equalityExpression => [ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' @ | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression
    --> __________________
    --> #318: inExpression => [ @ inExpression K_IN ] instanceofExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #413: equalityExpression => [ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' @ | 'T_FNOT_EQUAL' ) ] inExpression
    --> __________________
    --> #318: inExpression => [ @ inExpression K_IN ] instanceofExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #414: newExpression => @ ( K_NEW singleExpression [ arguments ] | postfixExpression )
    --> __________________
    --> #419: postfixExpression => @ ( postfixExpression (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )
    -->     Type: shift
    -->     LA: K_CLASS 'T_LBRACE' #ID# K_THIS K_FUNCTION 
    -->     LA: 'T_LSQUARE' K_FALSE #NUMBER# K_TRUE #STRING# 
    -->     LA: 'T_LPARAN' K_NULL #REGEX# K_SUPER 
    --> __________________
    --> #420: newExpression => ( K_NEW @ singleExpression [ arguments ] | postfixExpression )
    -->     Type: move
    -->     LA: K_NEW 

** State #415: deleteExpression => ( K_DELETE @ deleteExpression | newExpression )
    --> __________________
    --> #406: deleteExpression => @ ( K_DELETE deleteExpression | newExpression )
    -->     Type: shift
    -->     LA: K_DELETE K_NEW K_SUPER #REGEX# K_NULL 
    -->     LA: #STRING# 'T_LPARAN' K_TRUE #NUMBER# K_FALSE 
    -->     LA: 'T_LSQUARE' K_FUNCTION K_THIS #ID# 'T_LBRACE' 
    -->     LA: K_CLASS 

** State #416: bitAndExpression => [ bitAndExpression 'T_BIT_AND' @ ] equalityExpression
    --> __________________
    --> #307: equalityExpression => [ @ equalityExpression ( 'T_EQUAL' | 'T_NOT_EQUAL' | 'T_FEQUAL' | 'T_FNOT_EQUAL' ) ] inExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #417: bitOrExpression => [ bitOrExpression 'T_BIT_OR' ] bitXOrExpression @
    --> __________________
    --> #421: bitOrExpression => [ bitOrExpression @ 'T_BIT_OR' ] bitXOrExpression
    -->     Type: recursion
    -->     LA: 'T_BIT_OR' 
    --> __________________
    --> #422: logicalAndExpression => [ logicalAndExpression 'T_LOG_AND' ] bitOrExpression @
    -->     Type: reduce
    -->     Reduce(exp): logicalAndExpression => [ @ logicalAndExpression 'T_LOG_AND' ] bitOrExpression
    --> __________________
    --> #422: logicalAndExpression => [ logicalAndExpression 'T_LOG_AND' ] bitOrExpression @
    -->     Type: reduce
    -->     Reduce(exp): logicalAndExpression => [ logicalAndExpression 'T_LOG_AND' @ ] bitOrExpression

** State #418: bitXOrExpression => [ bitXOrExpression @ 'T_BIT_XOR' ] bitAndExpression
    --> __________________
    --> #423: bitXOrExpression => [ bitXOrExpression 'T_BIT_XOR' @ ] bitAndExpression
    -->     Type: move
    -->     LA: 'T_BIT_XOR' 

** State #419: postfixExpression => @ ( postfixExpression (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )
    --> __________________
    --> #424: functionExpression => @ ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
    -->     Type: shift
    -->     LA: K_SUPER #REGEX# K_NULL #STRING# 'T_LPARAN' 
    -->     LA: K_TRUE #NUMBER# K_FALSE 'T_LSQUARE' K_FUNCTION 
    -->     LA: K_THIS #ID# 'T_LBRACE' K_CLASS 

** State #420: newExpression => ( K_NEW @ singleExpression [ arguments ] | postfixExpression )
    --> __________________
    --> #47: singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #421: bitOrExpression => [ bitOrExpression @ 'T_BIT_OR' ] bitXOrExpression
    --> __________________
    --> #425: bitOrExpression => [ bitOrExpression 'T_BIT_OR' @ ] bitXOrExpression
    -->     Type: move
    -->     LA: 'T_BIT_OR' 

** [FINAL] State #422: logicalAndExpression => [ logicalAndExpression 'T_LOG_AND' ] bitOrExpression @
    --> __________________
    --> #426: logicalAndExpression => [ logicalAndExpression @ 'T_LOG_AND' ] bitOrExpression
    -->     Type: recursion
    -->     LA: 'T_LOG_AND' 
    --> __________________
    --> #427: logicalOrExpression => [ logicalOrExpression 'T_LOG_OR' ] logicalAndExpression @
    -->     Type: reduce
    -->     Reduce(exp): logicalOrExpression => [ @ logicalOrExpression 'T_LOG_OR' ] logicalAndExpression
    --> __________________
    --> #427: logicalOrExpression => [ logicalOrExpression 'T_LOG_OR' ] logicalAndExpression @
    -->     Type: reduce
    -->     Reduce(exp): logicalOrExpression => [ logicalOrExpression 'T_LOG_OR' @ ] logicalAndExpression

** State #423: bitXOrExpression => [ bitXOrExpression 'T_BIT_XOR' @ ] bitAndExpression
    --> __________________
    --> #266: bitAndExpression => [ @ bitAndExpression 'T_BIT_AND' ] equalityExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #424: functionExpression => @ ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
    --> __________________
    --> #428: parenthesizedExpression => @ ('T_LPARAN') expressionSequence ('T_RPARAN')
    -->     Type: shift
    -->     LA: 'T_LPARAN' 
    --> __________________
    --> #430: classExpression => @ K_CLASS (#ID#) classTail
    -->     Type: shift
    -->     LA: K_CLASS 
    --> __________________
    --> #431: thisExpression => @ K_THIS
    -->     Type: shift
    -->     LA: K_THIS 
    --> __________________
    --> #432: identifierExpression => @ #ID#
    -->     Type: shift
    -->     LA: #ID# 
    --> __________________
    --> #433: superExpression => @ K_SUPER
    -->     Type: shift
    -->     LA: K_SUPER 
    --> __________________
    --> #434: literalExpression => @ literal
    -->     Type: shift
    -->     LA: K_FALSE #NUMBER# K_NULL #STRING# K_TRUE 
    -->     LA: #REGEX# 
    --> __________________
    --> #435: arrayLiteralExpression => @ arrayLiteral
    -->     Type: shift
    -->     LA: 'T_LSQUARE' 
    --> __________________
    --> #436: objectLiteralExpression => @ objectLiteral
    -->     Type: shift
    -->     LA: 'T_LBRACE' 
    --> __________________
    --> #429: anonymousFunction => @ ( functionDecl | anoymousFunctionDecl | arrowFunction )
    -->     Type: shift
    -->     LA: 'T_LPARAN' K_FUNCTION #ID# 

** State #425: bitOrExpression => [ bitOrExpression 'T_BIT_OR' @ ] bitXOrExpression
    --> __________________
    --> #251: bitXOrExpression => [ @ bitXOrExpression 'T_BIT_XOR' ] bitAndExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #426: logicalAndExpression => [ logicalAndExpression @ 'T_LOG_AND' ] bitOrExpression
    --> __________________
    --> #437: logicalAndExpression => [ logicalAndExpression 'T_LOG_AND' @ ] bitOrExpression
    -->     Type: move
    -->     LA: 'T_LOG_AND' 

** [FINAL] State #427: logicalOrExpression => [ logicalOrExpression 'T_LOG_OR' ] logicalAndExpression @
    --> __________________
    --> #438: logicalOrExpression => [ logicalOrExpression @ 'T_LOG_OR' ] logicalAndExpression
    -->     Type: recursion
    -->     LA: 'T_LOG_OR' 
    --> __________________
    --> #439: ternaryExpression => logicalOrExpression @ [ 'T_QUERY' singleExpression 'T_COLON' singleExpression ]
    -->     Type: reduce
    -->     Reduce(exp): ternaryExpression => @ logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' singleExpression ]

** State #428: parenthesizedExpression => @ ('T_LPARAN') expressionSequence ('T_RPARAN')
    --> __________________
    --> #440: parenthesizedExpression => ('T_LPARAN') @ expressionSequence ('T_RPARAN')
    -->     Type: pass
    -->     LA: 'T_LPARAN' 

** State #429: anonymousFunction => @ ( functionDecl | anoymousFunctionDecl | arrowFunction )
    --> __________________
    --> #441: arrowFunction => @ arrowFunctionParameters ('T_ARROW') arrowFunctionBody
    -->     Type: shift
    -->     LA: #ID# 'T_LPARAN' 
    --> __________________
    --> #442: functionDecl => @ functionDeclaration
    -->     Type: shift
    -->     LA: K_FUNCTION 
    --> __________________
    --> #443: anoymousFunctionDecl => @ K_FUNCTION ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: shift
    -->     LA: K_FUNCTION 

** State #430: classExpression => @ K_CLASS (#ID#) classTail
    --> __________________
    --> #444: classExpression => K_CLASS @ (#ID#) classTail
    -->     Type: move
    -->     LA: K_CLASS 

** State #431: thisExpression => @ K_THIS
    --> __________________
    --> #445: thisExpression => K_THIS @
    -->     Type: move
    -->     LA: K_THIS 

** State #432: identifierExpression => @ #ID#
    --> __________________
    --> #446: identifierExpression => #ID# @
    -->     Type: move
    -->     LA: #ID# 

** State #433: superExpression => @ K_SUPER
    --> __________________
    --> #447: superExpression => K_SUPER @
    -->     Type: move
    -->     LA: K_SUPER 

** State #434: literalExpression => @ literal
    --> __________________
    --> #448: literal => @ ( K_NULL | K_TRUE | K_FALSE | #STRING# | #REGEX# | #NUMBER# )
    -->     Type: shift
    -->     LA: K_FALSE #NUMBER# K_NULL #STRING# K_TRUE 
    -->     LA: #REGEX# 

** State #435: arrayLiteralExpression => @ arrayLiteral
    --> __________________
    --> #137: arrayLiteral => @ ('T_LSQUARE') [ elementList ] ('T_RSQUARE')
    -->     Type: shift
    -->     LA: 'T_LSQUARE' 

** State #436: objectLiteralExpression => @ objectLiteral
    --> __________________
    --> #135: objectLiteral => @ ('T_LBRACE') [ propertyAssignments ] [ ('T_COMMA') ] ('T_RBRACE')
    -->     Type: shift
    -->     LA: 'T_LBRACE' 

** State #437: logicalAndExpression => [ logicalAndExpression 'T_LOG_AND' @ ] bitOrExpression
    --> __________________
    --> #231: bitOrExpression => [ @ bitOrExpression 'T_BIT_OR' ] bitXOrExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #438: logicalOrExpression => [ logicalOrExpression @ 'T_LOG_OR' ] logicalAndExpression
    --> __________________
    --> #449: logicalOrExpression => [ logicalOrExpression 'T_LOG_OR' @ ] logicalAndExpression
    -->     Type: move
    -->     LA: 'T_LOG_OR' 

** [FINAL] State #439: ternaryExpression => logicalOrExpression @ [ 'T_QUERY' singleExpression 'T_COLON' singleExpression ]
    --> __________________
    --> #450: ternaryExpression => logicalOrExpression [ 'T_QUERY' @ singleExpression 'T_COLON' singleExpression ]
    -->     Type: move
    -->     LA: 'T_QUERY' 
    --> __________________
    --> #451: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ @ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #451: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' @ ) ] ternaryExpression
    --> __________________
    --> #451: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' @ | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #451: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' @ | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #451: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' @ | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #451: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' @ | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #451: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' @ | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #451: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' @ | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #451: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' @ | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #451: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' @ | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #451: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' @ | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #451: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' @ | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #451: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' @ | 'T_ASSIGN_POWER' ) ] ternaryExpression

** State #440: parenthesizedExpression => ('T_LPARAN') @ expressionSequence ('T_RPARAN')
    --> __________________
    --> #25: expressionSequence => [ @ expressionSequence ('T_COMMA') ] singleExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #441: arrowFunction => @ arrowFunctionParameters ('T_ARROW') arrowFunctionBody
    --> __________________
    --> #452: arrowFunctionParameters => @ ( #ID# | ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') )
    -->     Type: shift
    -->     LA: #ID# 'T_LPARAN' 

** State #442: functionDecl => @ functionDeclaration
    --> __________________
    --> #3: functionDeclaration => @ K_FUNCTION #ID# ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: shift
    -->     LA: K_FUNCTION 

** State #443: anoymousFunctionDecl => @ K_FUNCTION ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #453: anoymousFunctionDecl => K_FUNCTION @ ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: move
    -->     LA: K_FUNCTION 

** State #444: classExpression => K_CLASS @ (#ID#) classTail
    --> __________________
    --> #454: classExpression => K_CLASS (#ID#) @ classTail
    -->     Type: pass
    -->     LA: #ID# 

** [FINAL] State #445: thisExpression => K_THIS @
    --> __________________
    --> #455: functionExpression => ( anonymousFunction | classExpression | thisExpression @ | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
    -->     Type: reduce
    -->     Reduce(exp): functionExpression => @ ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )

** [FINAL] State #446: identifierExpression => #ID# @
    --> __________________
    --> #456: functionExpression => ( anonymousFunction | classExpression | thisExpression | identifierExpression @ | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
    -->     Type: reduce
    -->     Reduce(exp): functionExpression => @ ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )

** [FINAL] State #447: superExpression => K_SUPER @
    --> __________________
    --> #457: functionExpression => ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression @ | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
    -->     Type: reduce
    -->     Reduce(exp): functionExpression => @ ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )

** State #448: literal => @ ( K_NULL | K_TRUE | K_FALSE | #STRING# | #REGEX# | #NUMBER# )
    --> __________________
    --> #458: literal => ( K_NULL | K_TRUE | K_FALSE | #STRING# | #REGEX# | #NUMBER# @ )
    -->     Type: move
    -->     LA: #NUMBER# 
    --> __________________
    --> #459: literal => ( K_NULL @ | K_TRUE | K_FALSE | #STRING# | #REGEX# | #NUMBER# )
    -->     Type: move
    -->     LA: K_NULL 
    --> __________________
    --> #460: literal => ( K_NULL | K_TRUE @ | K_FALSE | #STRING# | #REGEX# | #NUMBER# )
    -->     Type: move
    -->     LA: K_TRUE 
    --> __________________
    --> #461: literal => ( K_NULL | K_TRUE | K_FALSE @ | #STRING# | #REGEX# | #NUMBER# )
    -->     Type: move
    -->     LA: K_FALSE 
    --> __________________
    --> #462: literal => ( K_NULL | K_TRUE | K_FALSE | #STRING# @ | #REGEX# | #NUMBER# )
    -->     Type: move
    -->     LA: #STRING# 
    --> __________________
    --> #463: literal => ( K_NULL | K_TRUE | K_FALSE | #STRING# | #REGEX# @ | #NUMBER# )
    -->     Type: move
    -->     LA: #REGEX# 

** State #449: logicalOrExpression => [ logicalOrExpression 'T_LOG_OR' @ ] logicalAndExpression
    --> __________________
    --> #204: logicalAndExpression => [ @ logicalAndExpression 'T_LOG_AND' ] bitOrExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #450: ternaryExpression => logicalOrExpression [ 'T_QUERY' @ singleExpression 'T_COLON' singleExpression ]
    --> __________________
    --> #47: singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #451: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    --> __________________
    --> #464: assignmentExpression => [ assignmentExpression 'T_ASSIGN' ] assignmentOperatorExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentExpression => [ @ assignmentExpression 'T_ASSIGN' ] assignmentOperatorExpression
    --> __________________
    --> #464: assignmentExpression => [ assignmentExpression 'T_ASSIGN' ] assignmentOperatorExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentExpression => [ assignmentExpression 'T_ASSIGN' @ ] assignmentOperatorExpression
    --> __________________
    --> #465: assignmentOperatorExpression => [ assignmentOperatorExpression @ ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    -->     Type: recursion
    -->     LA: 'T_ASSIGN_XOR' 'T_ASSIGN_OR' 'T_ASSIGN_MUL' 'T_ASSIGN_ADD' 'T_ASSIGN_POWER' 
    -->     LA: 'T_ASSIGN_SUB' 'T_ASSIGN_DIV' 'T_ASSIGN_MOD' 'T_ASSIGN_LSHIFT' 'T_ASSIGN_RSHIFT' 
    -->     LA: 'T_ASSIGN_URSHIFT' 'T_ASSIGN_AND' 

** State #452: arrowFunctionParameters => @ ( #ID# | ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') )
    --> __________________
    --> #466: arrowFunctionParameters => ( #ID# | ('T_LPARAN') @ [ formalParameterList ] ('T_RPARAN') )
    -->     Type: pass
    -->     LA: 'T_LPARAN' 
    --> __________________
    --> #467: arrowFunctionParameters => ( #ID# @ | ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') )
    -->     Type: move
    -->     LA: #ID# 

** State #453: anoymousFunctionDecl => K_FUNCTION @ ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #468: anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') @ [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: pass
    -->     LA: 'T_LPARAN' 

** State #454: classExpression => K_CLASS (#ID#) @ classTail
    --> __________________
    --> #83: classTail => @ ('T_LBRACE') classElements ('T_RBRACE')
    -->     Type: shift
    -->     LA: 'T_LBRACE' 

** [FINAL] State #455: functionExpression => ( anonymousFunction | classExpression | thisExpression @ | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
    --> __________________
    --> #225: postfixExpression => ( postfixExpression (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): postfixExpression => @ ( postfixExpression (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )

** [FINAL] State #456: functionExpression => ( anonymousFunction | classExpression | thisExpression | identifierExpression @ | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
    --> __________________
    --> #225: postfixExpression => ( postfixExpression (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): postfixExpression => @ ( postfixExpression (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )

** [FINAL] State #457: functionExpression => ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression @ | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
    --> __________________
    --> #225: postfixExpression => ( postfixExpression (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): postfixExpression => @ ( postfixExpression (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )

** [FINAL] State #458: literal => ( K_NULL | K_TRUE | K_FALSE | #STRING# | #REGEX# | #NUMBER# @ )
    --> __________________
    --> #469: literalExpression => literal @
    -->     Type: reduce
    -->     Reduce(exp): literalExpression => @ literal

** [FINAL] State #459: literal => ( K_NULL @ | K_TRUE | K_FALSE | #STRING# | #REGEX# | #NUMBER# )
    --> __________________
    --> #469: literalExpression => literal @
    -->     Type: reduce
    -->     Reduce(exp): literalExpression => @ literal

** [FINAL] State #460: literal => ( K_NULL | K_TRUE @ | K_FALSE | #STRING# | #REGEX# | #NUMBER# )
    --> __________________
    --> #469: literalExpression => literal @
    -->     Type: reduce
    -->     Reduce(exp): literalExpression => @ literal

** [FINAL] State #461: literal => ( K_NULL | K_TRUE | K_FALSE @ | #STRING# | #REGEX# | #NUMBER# )
    --> __________________
    --> #469: literalExpression => literal @
    -->     Type: reduce
    -->     Reduce(exp): literalExpression => @ literal

** [FINAL] State #462: literal => ( K_NULL | K_TRUE | K_FALSE | #STRING# @ | #REGEX# | #NUMBER# )
    --> __________________
    --> #469: literalExpression => literal @
    -->     Type: reduce
    -->     Reduce(exp): literalExpression => @ literal

** [FINAL] State #463: literal => ( K_NULL | K_TRUE | K_FALSE | #STRING# | #REGEX# @ | #NUMBER# )
    --> __________________
    --> #469: literalExpression => literal @
    -->     Type: reduce
    -->     Reduce(exp): literalExpression => @ literal

** [FINAL] State #464: assignmentExpression => [ assignmentExpression 'T_ASSIGN' ] assignmentOperatorExpression @
    --> __________________
    --> #470: assignmentExpression => [ assignmentExpression @ 'T_ASSIGN' ] assignmentOperatorExpression
    -->     Type: recursion
    -->     LA: 'T_ASSIGN' 
    --> __________________
    --> #471: singleExpression => [ singleExpression ('T_COMMA') ] assignmentExpression @
    -->     Type: reduce
    -->     Reduce(exp): singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    --> __________________
    --> #471: singleExpression => [ singleExpression ('T_COMMA') ] assignmentExpression @
    -->     Type: reduce
    -->     Reduce(exp): singleExpression => [ singleExpression ('T_COMMA') @ ] assignmentExpression

** State #465: assignmentOperatorExpression => [ assignmentOperatorExpression @ ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #472: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' @ ) ] ternaryExpression
    -->     Type: move
    -->     LA: 'T_ASSIGN_POWER' 
    --> __________________
    --> #473: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' @ | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    -->     Type: move
    -->     LA: 'T_ASSIGN_ADD' 
    --> __________________
    --> #474: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' @ | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    -->     Type: move
    -->     LA: 'T_ASSIGN_SUB' 
    --> __________________
    --> #475: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' @ | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    -->     Type: move
    -->     LA: 'T_ASSIGN_MUL' 
    --> __________________
    --> #476: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' @ | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    -->     Type: move
    -->     LA: 'T_ASSIGN_DIV' 
    --> __________________
    --> #477: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' @ | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    -->     Type: move
    -->     LA: 'T_ASSIGN_MOD' 
    --> __________________
    --> #478: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' @ | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    -->     Type: move
    -->     LA: 'T_ASSIGN_LSHIFT' 
    --> __________________
    --> #479: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' @ | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    -->     Type: move
    -->     LA: 'T_ASSIGN_RSHIFT' 
    --> __________________
    --> #480: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' @ | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    -->     Type: move
    -->     LA: 'T_ASSIGN_URSHIFT' 
    --> __________________
    --> #481: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' @ | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    -->     Type: move
    -->     LA: 'T_ASSIGN_AND' 
    --> __________________
    --> #482: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' @ | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    -->     Type: move
    -->     LA: 'T_ASSIGN_OR' 
    --> __________________
    --> #483: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' @ | 'T_ASSIGN_POWER' ) ] ternaryExpression
    -->     Type: move
    -->     LA: 'T_ASSIGN_XOR' 

** State #466: arrowFunctionParameters => ( #ID# | ('T_LPARAN') @ [ formalParameterList ] ('T_RPARAN') )
    --> __________________
    --> #210: arrowFunctionParameters => ( #ID# | ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') @ )
    -->     Type: pass
    -->     LA: 'T_RPARAN' 
    --> __________________
    --> #93: formalParameterList => [ @ formalParameterList ('T_COMMA') ] assignable
    -->     Type: shift
    -->     LA: 'T_LSQUARE' 'T_LBRACE' #ID# 

** [FINAL] State #467: arrowFunctionParameters => ( #ID# @ | ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') )
    --> __________________
    --> #237: arrowFunction => arrowFunctionParameters @ ('T_ARROW') arrowFunctionBody
    -->     Type: reduce
    -->     Reduce: arrowFunction => @ arrowFunctionParameters ('T_ARROW') arrowFunctionBody

** State #468: anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') @ [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #209: anoymousFunctionDecl => K_FUNCTION ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') @ ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: pass
    -->     LA: 'T_RPARAN' 
    --> __________________
    --> #93: formalParameterList => [ @ formalParameterList ('T_COMMA') ] assignable
    -->     Type: shift
    -->     LA: 'T_LSQUARE' 'T_LBRACE' #ID# 

** [FINAL] State #469: literalExpression => literal @
    --> __________________
    --> #484: functionExpression => ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression @ | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
    -->     Type: reduce
    -->     Reduce(exp): functionExpression => @ ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )

** State #470: assignmentExpression => [ assignmentExpression @ 'T_ASSIGN' ] assignmentOperatorExpression
    --> __________________
    --> #485: assignmentExpression => [ assignmentExpression 'T_ASSIGN' @ ] assignmentOperatorExpression
    -->     Type: move
    -->     LA: 'T_ASSIGN' 

** [FINAL] State #471: singleExpression => [ singleExpression ('T_COMMA') ] assignmentExpression @
    --> __________________
    --> #486: argument => [ argument ('T_COMMA') ] [ ('T_ELLIPSIS') ] ( singleExpression @ | #ID# )
    -->     Type: reduce
    -->     Reduce: argument => [ @ argument ('T_COMMA') ] [ ('T_ELLIPSIS') ] ( singleExpression | #ID# )
    --> __________________
    --> #486: argument => [ argument ('T_COMMA') ] [ ('T_ELLIPSIS') ] ( singleExpression @ | #ID# )
    -->     Type: reduce
    -->     Reduce: argument => [ argument ('T_COMMA') ] [ ('T_ELLIPSIS') @ ] ( singleExpression | #ID# )
    --> __________________
    --> #486: argument => [ argument ('T_COMMA') ] [ ('T_ELLIPSIS') ] ( singleExpression @ | #ID# )
    -->     Type: reduce
    -->     Reduce: argument => [ argument ('T_COMMA') @ ] [ ('T_ELLIPSIS') ] ( singleExpression | #ID# )
    --> __________________
    --> #487: arrayElement => [ 'T_ELLIPSIS' ] singleExpression @
    -->     Type: reduce
    -->     Reduce: arrayElement => [ @ 'T_ELLIPSIS' ] singleExpression
    --> __________________
    --> #487: arrayElement => [ 'T_ELLIPSIS' ] singleExpression @
    -->     Type: reduce
    -->     Reduce: arrayElement => [ 'T_ELLIPSIS' @ ] singleExpression
    --> __________________
    --> #488: arrowFunctionBody => ( singleExpression @ | 'T_LBRACE' [ functionBody ] 'T_RBRACE' )
    -->     Type: reduce
    -->     Reduce: arrowFunctionBody => @ ( singleExpression | 'T_LBRACE' [ functionBody ] 'T_RBRACE' )
    --> __________________
    --> #489: classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' singleExpression @ )
    -->     Type: reduce
    -->     Reduce: classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' @ singleExpression )
    --> __________________
    --> #490: computedPropertyExpressionAssignment => ('T_LPARAN') singleExpression @ ('T_RPARAN') ('T_COLON') singleExpression
    -->     Type: reduce
    -->     Reduce: computedPropertyExpressionAssignment => ('T_LPARAN') @ singleExpression ('T_RPARAN') ('T_COLON') singleExpression
    --> __________________
    --> #491: computedPropertyExpressionAssignment => ('T_LPARAN') singleExpression ('T_RPARAN') ('T_COLON') singleExpression @
    -->     Type: reduce
    -->     Reduce: computedPropertyExpressionAssignment => ('T_LPARAN') singleExpression ('T_RPARAN') ('T_COLON') @ singleExpression
    --> __________________
    --> #492: expressionSequence => [ expressionSequence ('T_COMMA') ] singleExpression @
    -->     Type: reduce
    -->     Reduce: expressionSequence => [ @ expressionSequence ('T_COMMA') ] singleExpression
    --> __________________
    --> #492: expressionSequence => [ expressionSequence ('T_COMMA') ] singleExpression @
    -->     Type: reduce
    -->     Reduce: expressionSequence => [ expressionSequence ('T_COMMA') @ ] singleExpression
    --> __________________
    --> #493: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression @ | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement
    -->     Type: reduce
    -->     Reduce: forInStatement => K_FOR ('T_LPARAN') @ [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement
    --> __________________
    --> #494: newExpression => ( K_NEW singleExpression @ [ arguments ] | postfixExpression )
    -->     Type: reduce
    -->     Reduce(exp): newExpression => ( K_NEW @ singleExpression [ arguments ] | postfixExpression )
    --> __________________
    --> #495: propertyExpressionAssignment => propertyName ('T_COLON') singleExpression @
    -->     Type: reduce
    -->     Reduce: propertyExpressionAssignment => propertyName ('T_COLON') @ singleExpression
    --> __________________
    --> #496: propertyName => ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression @ ('T_RSQUARE') )
    -->     Type: reduce
    -->     Reduce: propertyName => ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') @ singleExpression ('T_RSQUARE') )
    --> __________________
    --> #497: propertyShorthand => [ 'T_ELLIPSIS' ] singleExpression @
    -->     Type: reduce
    -->     Reduce: propertyShorthand => [ @ 'T_ELLIPSIS' ] singleExpression
    --> __________________
    --> #497: propertyShorthand => [ 'T_ELLIPSIS' ] singleExpression @
    -->     Type: reduce
    -->     Reduce: propertyShorthand => [ 'T_ELLIPSIS' @ ] singleExpression
    --> __________________
    --> #498: singleExpression => [ singleExpression @ ('T_COMMA') ] assignmentExpression
    -->     Type: recursion
    -->     LA: 'T_COMMA' 
    --> __________________
    --> #499: ternaryExpression => logicalOrExpression [ 'T_QUERY' singleExpression @ 'T_COLON' singleExpression ]
    -->     Type: reduce
    -->     Reduce(exp): ternaryExpression => logicalOrExpression [ 'T_QUERY' @ singleExpression 'T_COLON' singleExpression ]
    --> __________________
    --> #500: ternaryExpression => logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' singleExpression @ ]
    -->     Type: reduce
    -->     Reduce(exp): ternaryExpression => logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' @ singleExpression ]
    --> __________________
    --> #501: variableDeclaration => assignable [ 'T_ASSIGN' singleExpression @ ]
    -->     Type: reduce
    -->     Reduce: variableDeclaration => assignable [ 'T_ASSIGN' @ singleExpression ]

** State #472: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' @ ) ] ternaryExpression
    --> __________________
    --> #150: ternaryExpression => @ logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' singleExpression ]
    -->     Type: shift
    -->     LA: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 
    -->     LA: 'T_LSQUARE' #NUMBER# 'T_DEC' #REGEX# K_NULL 
    -->     LA: 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE 
    -->     LA: K_NEW K_SUPER #STRING# K_TRUE K_CLASS 
    -->     LA: K_FALSE K_FUNCTION K_THIS #ID# 

** State #473: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' @ | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #150: ternaryExpression => @ logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' singleExpression ]
    -->     Type: shift
    -->     LA: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 
    -->     LA: 'T_LSQUARE' #NUMBER# 'T_DEC' #REGEX# K_NULL 
    -->     LA: 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE 
    -->     LA: K_NEW K_SUPER #STRING# K_TRUE K_CLASS 
    -->     LA: K_FALSE K_FUNCTION K_THIS #ID# 

** State #474: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' @ | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #150: ternaryExpression => @ logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' singleExpression ]
    -->     Type: shift
    -->     LA: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 
    -->     LA: 'T_LSQUARE' #NUMBER# 'T_DEC' #REGEX# K_NULL 
    -->     LA: 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE 
    -->     LA: K_NEW K_SUPER #STRING# K_TRUE K_CLASS 
    -->     LA: K_FALSE K_FUNCTION K_THIS #ID# 

** State #475: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' @ | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #150: ternaryExpression => @ logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' singleExpression ]
    -->     Type: shift
    -->     LA: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 
    -->     LA: 'T_LSQUARE' #NUMBER# 'T_DEC' #REGEX# K_NULL 
    -->     LA: 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE 
    -->     LA: K_NEW K_SUPER #STRING# K_TRUE K_CLASS 
    -->     LA: K_FALSE K_FUNCTION K_THIS #ID# 

** State #476: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' @ | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #150: ternaryExpression => @ logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' singleExpression ]
    -->     Type: shift
    -->     LA: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 
    -->     LA: 'T_LSQUARE' #NUMBER# 'T_DEC' #REGEX# K_NULL 
    -->     LA: 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE 
    -->     LA: K_NEW K_SUPER #STRING# K_TRUE K_CLASS 
    -->     LA: K_FALSE K_FUNCTION K_THIS #ID# 

** State #477: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' @ | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #150: ternaryExpression => @ logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' singleExpression ]
    -->     Type: shift
    -->     LA: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 
    -->     LA: 'T_LSQUARE' #NUMBER# 'T_DEC' #REGEX# K_NULL 
    -->     LA: 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE 
    -->     LA: K_NEW K_SUPER #STRING# K_TRUE K_CLASS 
    -->     LA: K_FALSE K_FUNCTION K_THIS #ID# 

** State #478: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' @ | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #150: ternaryExpression => @ logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' singleExpression ]
    -->     Type: shift
    -->     LA: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 
    -->     LA: 'T_LSQUARE' #NUMBER# 'T_DEC' #REGEX# K_NULL 
    -->     LA: 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE 
    -->     LA: K_NEW K_SUPER #STRING# K_TRUE K_CLASS 
    -->     LA: K_FALSE K_FUNCTION K_THIS #ID# 

** State #479: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' @ | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #150: ternaryExpression => @ logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' singleExpression ]
    -->     Type: shift
    -->     LA: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 
    -->     LA: 'T_LSQUARE' #NUMBER# 'T_DEC' #REGEX# K_NULL 
    -->     LA: 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE 
    -->     LA: K_NEW K_SUPER #STRING# K_TRUE K_CLASS 
    -->     LA: K_FALSE K_FUNCTION K_THIS #ID# 

** State #480: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' @ | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #150: ternaryExpression => @ logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' singleExpression ]
    -->     Type: shift
    -->     LA: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 
    -->     LA: 'T_LSQUARE' #NUMBER# 'T_DEC' #REGEX# K_NULL 
    -->     LA: 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE 
    -->     LA: K_NEW K_SUPER #STRING# K_TRUE K_CLASS 
    -->     LA: K_FALSE K_FUNCTION K_THIS #ID# 

** State #481: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' @ | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #150: ternaryExpression => @ logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' singleExpression ]
    -->     Type: shift
    -->     LA: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 
    -->     LA: 'T_LSQUARE' #NUMBER# 'T_DEC' #REGEX# K_NULL 
    -->     LA: 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE 
    -->     LA: K_NEW K_SUPER #STRING# K_TRUE K_CLASS 
    -->     LA: K_FALSE K_FUNCTION K_THIS #ID# 

** State #482: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' @ | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #150: ternaryExpression => @ logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' singleExpression ]
    -->     Type: shift
    -->     LA: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 
    -->     LA: 'T_LSQUARE' #NUMBER# 'T_DEC' #REGEX# K_NULL 
    -->     LA: 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE 
    -->     LA: K_NEW K_SUPER #STRING# K_TRUE K_CLASS 
    -->     LA: K_FALSE K_FUNCTION K_THIS #ID# 

** State #483: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' @ | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #150: ternaryExpression => @ logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' singleExpression ]
    -->     Type: shift
    -->     LA: 'T_LOG_NOT' 'T_ADD' 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 
    -->     LA: 'T_LSQUARE' #NUMBER# 'T_DEC' #REGEX# K_NULL 
    -->     LA: 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID K_DELETE 
    -->     LA: K_NEW K_SUPER #STRING# K_TRUE K_CLASS 
    -->     LA: K_FALSE K_FUNCTION K_THIS #ID# 

** [FINAL] State #484: functionExpression => ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression @ | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )
    --> __________________
    --> #225: postfixExpression => ( postfixExpression (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): postfixExpression => @ ( postfixExpression (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )

** State #485: assignmentExpression => [ assignmentExpression 'T_ASSIGN' @ ] assignmentOperatorExpression
    --> __________________
    --> #118: assignmentOperatorExpression => [ @ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #486: argument => [ argument ('T_COMMA') ] [ ('T_ELLIPSIS') ] ( singleExpression @ | #ID# )
    --> __________________
    --> #344: argument => [ argument @ ('T_COMMA') ] [ ('T_ELLIPSIS') ] ( singleExpression | #ID# )
    -->     Type: recursion
    -->     LA: 'T_COMMA' 
    --> __________________
    --> #345: arguments => ('T_LPARAN') [ argument @ ] ('T_RPARAN')
    -->     Type: reduce
    -->     Reduce: arguments => ('T_LPARAN') @ [ argument ] ('T_RPARAN')

** [FINAL] State #487: arrayElement => [ 'T_ELLIPSIS' ] singleExpression @
    --> __________________
    --> #502: elementList => [ elementList ('T_COMMA') ] arrayElement @
    -->     Type: reduce
    -->     Reduce: elementList => [ @ elementList ('T_COMMA') ] arrayElement
    --> __________________
    --> #502: elementList => [ elementList ('T_COMMA') ] arrayElement @
    -->     Type: reduce
    -->     Reduce: elementList => [ elementList ('T_COMMA') @ ] arrayElement

** [FINAL] State #488: arrowFunctionBody => ( singleExpression @ | 'T_LBRACE' [ functionBody ] 'T_RBRACE' )
    --> __________________
    --> #199: arrowFunction => arrowFunctionParameters ('T_ARROW') arrowFunctionBody @
    -->     Type: reduce
    -->     Reduce: arrowFunction => arrowFunctionParameters ('T_ARROW') @ arrowFunctionBody

** [FINAL] State #489: classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' singleExpression @ )
    --> __________________
    --> #71: classElements => [ classElements ('T_COMMA') ] classElement @
    -->     Type: reduce
    -->     Reduce: classElements => [ @ classElements ('T_COMMA') ] classElement
    --> __________________
    --> #71: classElements => [ classElements ('T_COMMA') ] classElement @
    -->     Type: reduce
    -->     Reduce: classElements => [ classElements ('T_COMMA') @ ] classElement

** State #490: computedPropertyExpressionAssignment => ('T_LPARAN') singleExpression @ ('T_RPARAN') ('T_COLON') singleExpression
    --> __________________
    --> #503: computedPropertyExpressionAssignment => ('T_LPARAN') singleExpression ('T_RPARAN') @ ('T_COLON') singleExpression
    -->     Type: pass
    -->     LA: 'T_RPARAN' 

** [FINAL] State #491: computedPropertyExpressionAssignment => ('T_LPARAN') singleExpression ('T_RPARAN') ('T_COLON') singleExpression @
    --> __________________
    --> #504: propertyAssignment => ( propertyExpressionAssignment | computedPropertyExpressionAssignment @ | propertyShorthand )
    -->     Type: reduce
    -->     Reduce: propertyAssignment => @ ( propertyExpressionAssignment | computedPropertyExpressionAssignment | propertyShorthand )

** [FINAL] State #492: expressionSequence => [ expressionSequence ('T_COMMA') ] singleExpression @
    --> __________________
    --> #505: caseClause => K_CASE expressionSequence @ 'T_COLON' [ statementList ]
    -->     Type: reduce
    -->     Reduce: caseClause => K_CASE @ expressionSequence 'T_COLON' [ statementList ]
    --> __________________
    --> #506: doStatement => K_DO statement K_WHILE ('T_LPARAN') expressionSequence @ ('T_RPARAN') [ eos ]
    -->     Type: reduce
    -->     Reduce: doStatement => K_DO statement K_WHILE ('T_LPARAN') @ expressionSequence ('T_RPARAN') [ eos ]
    --> __________________
    --> #507: expressionSequence => [ expressionSequence @ ('T_COMMA') ] singleExpression
    -->     Type: recursion
    -->     LA: 'T_COMMA' 
    --> __________________
    --> #508: expressionStatement => expressionSequence @ [ eos ]
    -->     Type: reduce
    -->     Reduce: expressionStatement => @ expressionSequence [ eos ]
    --> __________________
    --> #509: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence @ ('T_RPARAN') statement
    -->     Type: reduce
    -->     Reduce: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN @ expressionSequence ('T_RPARAN') statement
    --> __________________
    --> #510: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence @ | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
    -->     Type: reduce
    -->     Reduce: forStatement => K_FOR ('T_LPARAN') @ [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
    --> __________________
    --> #511: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence @ ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
    -->     Type: reduce
    -->     Reduce: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' @ [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
    --> __________________
    --> #512: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence @ ] ('T_RPARAN') statement
    -->     Type: reduce
    -->     Reduce: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' @ [ expressionSequence ] ('T_RPARAN') statement
    --> __________________
    --> #513: ifStatement => K_IF ('T_LPARAN') expressionSequence @ ('T_RPARAN') statement [ K_ELSE statement ]
    -->     Type: reduce
    -->     Reduce: ifStatement => K_IF ('T_LPARAN') @ expressionSequence ('T_RPARAN') statement [ K_ELSE statement ]
    --> __________________
    --> #514: memberIndexExpression => [ memberIndexExpression ] 'T_LSQUARE' expressionSequence @ 'T_RSQUARE'
    -->     Type: reduce
    -->     Reduce(exp): memberIndexExpression => [ memberIndexExpression ] 'T_LSQUARE' @ expressionSequence 'T_RSQUARE'
    --> __________________
    --> #515: parenthesizedExpression => ('T_LPARAN') expressionSequence @ ('T_RPARAN')
    -->     Type: reduce
    -->     Reduce(exp): parenthesizedExpression => ('T_LPARAN') @ expressionSequence ('T_RPARAN')
    --> __________________
    --> #516: returnStatement => K_RETURN [ (#RULE_NO_LINE#) expressionSequence @ ] [ eos ]
    -->     Type: reduce
    -->     Reduce: returnStatement => K_RETURN [ (#RULE_NO_LINE#) @ expressionSequence ] [ eos ]
    --> __________________
    --> #517: switchStatement => K_SWITCH ('T_LPARAN') expressionSequence @ ('T_RPARAN') caseBlock
    -->     Type: reduce
    -->     Reduce: switchStatement => K_SWITCH ('T_LPARAN') @ expressionSequence ('T_RPARAN') caseBlock
    --> __________________
    --> #518: throwStatement => K_THROW (#RULE_NO_LINE#) expressionSequence @ [ eos ]
    -->     Type: reduce
    -->     Reduce: throwStatement => K_THROW (#RULE_NO_LINE#) @ expressionSequence [ eos ]
    --> __________________
    --> #519: whileStatement => K_WHILE ('T_LPARAN') expressionSequence @ ('T_RPARAN') statement
    -->     Type: reduce
    -->     Reduce: whileStatement => K_WHILE ('T_LPARAN') @ expressionSequence ('T_RPARAN') statement
    --> __________________
    --> #520: withStatement => K_WITH ('T_LPARAN') expressionSequence @ ('T_RPARAN') statement
    -->     Type: reduce
    -->     Reduce: withStatement => K_WITH ('T_LPARAN') @ expressionSequence ('T_RPARAN') statement

** State #493: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression @ | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') statement
    --> __________________
    --> #119: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN @ expressionSequence ('T_RPARAN') statement
    -->     Type: move
    -->     LA: K_IN 

** [FINAL] State #494: newExpression => ( K_NEW singleExpression @ [ arguments ] | postfixExpression )
    --> __________________
    --> #316: arguments => @ ('T_LPARAN') [ argument ] ('T_RPARAN')
    -->     Type: shift
    -->     LA: 'T_LPARAN' 
    --> __________________
    --> #264: deleteExpression => ( K_DELETE deleteExpression | newExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): deleteExpression => @ ( K_DELETE deleteExpression | newExpression )

** [FINAL] State #495: propertyExpressionAssignment => propertyName ('T_COLON') singleExpression @
    --> __________________
    --> #521: propertyAssignment => ( propertyExpressionAssignment @ | computedPropertyExpressionAssignment | propertyShorthand )
    -->     Type: reduce
    -->     Reduce: propertyAssignment => @ ( propertyExpressionAssignment | computedPropertyExpressionAssignment | propertyShorthand )

** State #496: propertyName => ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression @ ('T_RSQUARE') )
    --> __________________
    --> #522: propertyName => ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') @ )
    -->     Type: pass
    -->     LA: 'T_RSQUARE' 

** [FINAL] State #497: propertyShorthand => [ 'T_ELLIPSIS' ] singleExpression @
    --> __________________
    --> #523: propertyAssignment => ( propertyExpressionAssignment | computedPropertyExpressionAssignment | propertyShorthand @ )
    -->     Type: reduce
    -->     Reduce: propertyAssignment => @ ( propertyExpressionAssignment | computedPropertyExpressionAssignment | propertyShorthand )

** State #498: singleExpression => [ singleExpression @ ('T_COMMA') ] assignmentExpression
    --> __________________
    --> #524: singleExpression => [ singleExpression ('T_COMMA') @ ] assignmentExpression
    -->     Type: pass
    -->     LA: 'T_COMMA' 

** State #499: ternaryExpression => logicalOrExpression [ 'T_QUERY' singleExpression @ 'T_COLON' singleExpression ]
    --> __________________
    --> #525: ternaryExpression => logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' @ singleExpression ]
    -->     Type: move
    -->     LA: 'T_COLON' 

** [FINAL] State #500: ternaryExpression => logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' singleExpression @ ]
    --> __________________
    --> #451: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ @ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #451: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' @ ) ] ternaryExpression
    --> __________________
    --> #451: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' @ | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #451: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' @ | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #451: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' @ | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #451: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' @ | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #451: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' @ | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #451: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' @ | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #451: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' @ | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #451: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' @ | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #451: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' @ | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #451: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' @ | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression
    --> __________________
    --> #451: assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' | 'T_ASSIGN_POWER' ) ] ternaryExpression @
    -->     Type: reduce
    -->     Reduce(exp): assignmentOperatorExpression => [ assignmentOperatorExpression ( 'T_ASSIGN_ADD' | 'T_ASSIGN_SUB' | 'T_ASSIGN_MUL' | 'T_ASSIGN_DIV' | 'T_ASSIGN_MOD' | 'T_ASSIGN_LSHIFT' | 'T_ASSIGN_RSHIFT' | 'T_ASSIGN_URSHIFT' | 'T_ASSIGN_AND' | 'T_ASSIGN_OR' | 'T_ASSIGN_XOR' @ | 'T_ASSIGN_POWER' ) ] ternaryExpression

** [FINAL] State #501: variableDeclaration => assignable [ 'T_ASSIGN' singleExpression @ ]
    --> __________________
    --> #190: variableDeclarationList => [ variableDeclarationList ('T_COMMA') ] variableDeclaration @
    -->     Type: reduce
    -->     Reduce: variableDeclarationList => [ @ variableDeclarationList ('T_COMMA') ] variableDeclaration
    --> __________________
    --> #190: variableDeclarationList => [ variableDeclarationList ('T_COMMA') ] variableDeclaration @
    -->     Type: reduce
    -->     Reduce: variableDeclarationList => [ variableDeclarationList ('T_COMMA') @ ] variableDeclaration

** [FINAL] State #502: elementList => [ elementList ('T_COMMA') ] arrayElement @
    --> __________________
    --> #526: arrayLiteral => ('T_LSQUARE') [ elementList @ ] ('T_RSQUARE')
    -->     Type: reduce
    -->     Reduce: arrayLiteral => ('T_LSQUARE') @ [ elementList ] ('T_RSQUARE')
    --> __________________
    --> #527: elementList => [ elementList @ ('T_COMMA') ] arrayElement
    -->     Type: recursion
    -->     LA: 'T_COMMA' 

** State #503: computedPropertyExpressionAssignment => ('T_LPARAN') singleExpression ('T_RPARAN') @ ('T_COLON') singleExpression
    --> __________________
    --> #528: computedPropertyExpressionAssignment => ('T_LPARAN') singleExpression ('T_RPARAN') ('T_COLON') @ singleExpression
    -->     Type: pass
    -->     LA: 'T_COLON' 

** [FINAL] State #504: propertyAssignment => ( propertyExpressionAssignment | computedPropertyExpressionAssignment @ | propertyShorthand )
    --> __________________
    --> #529: propertyAssignments => [ propertyAssignments ('T_COMMA') ] propertyAssignment @
    -->     Type: reduce
    -->     Reduce: propertyAssignments => [ @ propertyAssignments ('T_COMMA') ] propertyAssignment
    --> __________________
    --> #529: propertyAssignments => [ propertyAssignments ('T_COMMA') ] propertyAssignment @
    -->     Type: reduce
    -->     Reduce: propertyAssignments => [ propertyAssignments ('T_COMMA') @ ] propertyAssignment

** State #505: caseClause => K_CASE expressionSequence @ 'T_COLON' [ statementList ]
    --> __________________
    --> #530: caseClause => K_CASE expressionSequence 'T_COLON' @ [ statementList ]
    -->     Type: move
    -->     LA: 'T_COLON' 

** State #506: doStatement => K_DO statement K_WHILE ('T_LPARAN') expressionSequence @ ('T_RPARAN') [ eos ]
    --> __________________
    --> #531: doStatement => K_DO statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ [ eos ]
    -->     Type: pass
    -->     LA: 'T_RPARAN' 

** State #507: expressionSequence => [ expressionSequence @ ('T_COMMA') ] singleExpression
    --> __________________
    --> #532: expressionSequence => [ expressionSequence ('T_COMMA') @ ] singleExpression
    -->     Type: pass
    -->     LA: 'T_COMMA' 

** [FINAL] State #508: expressionStatement => expressionSequence @ [ eos ]
    --> __________________
    --> #53: eos => @ ( ('T_SEMI') | #END# )
    -->     Type: shift
    -->     LA: 'T_SEMI' #END# 
    --> __________________
    --> #153: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement @ | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** State #509: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence @ ('T_RPARAN') statement
    --> __________________
    --> #533: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') @ statement
    -->     Type: pass
    -->     LA: 'T_RPARAN' 

** State #510: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence @ | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
    --> __________________
    --> #121: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' @ [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
    -->     Type: move
    -->     LA: 'T_SEMI' 

** State #511: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence @ ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') statement
    --> __________________
    --> #151: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' @ [ expressionSequence ] ('T_RPARAN') statement
    -->     Type: move
    -->     LA: 'T_SEMI' 

** State #512: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence @ ] ('T_RPARAN') statement
    --> __________________
    --> #177: forStatement => K_FOR ('T_LPARAN') [ ( expressionSequence | K_VAR variableDeclarationList ) ] 'T_SEMI' [ expressionSequence ] 'T_SEMI' [ expressionSequence ] ('T_RPARAN') @ statement
    -->     Type: pass
    -->     LA: 'T_RPARAN' 

** State #513: ifStatement => K_IF ('T_LPARAN') expressionSequence @ ('T_RPARAN') statement [ K_ELSE statement ]
    --> __________________
    --> #534: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement [ K_ELSE statement ]
    -->     Type: pass
    -->     LA: 'T_RPARAN' 

** State #514: memberIndexExpression => [ memberIndexExpression ] 'T_LSQUARE' expressionSequence @ 'T_RSQUARE'
    --> __________________
    --> #535: memberIndexExpression => [ memberIndexExpression ] 'T_LSQUARE' expressionSequence 'T_RSQUARE' @
    -->     Type: move
    -->     LA: 'T_RSQUARE' 

** State #515: parenthesizedExpression => ('T_LPARAN') expressionSequence @ ('T_RPARAN')
    --> __________________
    --> #536: parenthesizedExpression => ('T_LPARAN') expressionSequence ('T_RPARAN') @
    -->     Type: pass
    -->     LA: 'T_RPARAN' 

** [FINAL] State #516: returnStatement => K_RETURN [ (#RULE_NO_LINE#) expressionSequence @ ] [ eos ]
    --> __________________
    --> #53: eos => @ ( ('T_SEMI') | #END# )
    -->     Type: shift
    -->     LA: 'T_SEMI' #END# 
    --> __________________
    --> #59: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement @ | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** State #517: switchStatement => K_SWITCH ('T_LPARAN') expressionSequence @ ('T_RPARAN') caseBlock
    --> __________________
    --> #537: switchStatement => K_SWITCH ('T_LPARAN') expressionSequence ('T_RPARAN') @ caseBlock
    -->     Type: pass
    -->     LA: 'T_RPARAN' 

** [FINAL] State #518: throwStatement => K_THROW (#RULE_NO_LINE#) expressionSequence @ [ eos ]
    --> __________________
    --> #53: eos => @ ( ('T_SEMI') | #END# )
    -->     Type: shift
    -->     LA: 'T_SEMI' #END# 
    --> __________________
    --> #154: statement => ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement @ | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: reduce
    -->     Reduce: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )

** State #519: whileStatement => K_WHILE ('T_LPARAN') expressionSequence @ ('T_RPARAN') statement
    --> __________________
    --> #538: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
    -->     Type: pass
    -->     LA: 'T_RPARAN' 

** State #520: withStatement => K_WITH ('T_LPARAN') expressionSequence @ ('T_RPARAN') statement
    --> __________________
    --> #539: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
    -->     Type: pass
    -->     LA: 'T_RPARAN' 

** [FINAL] State #521: propertyAssignment => ( propertyExpressionAssignment @ | computedPropertyExpressionAssignment | propertyShorthand )
    --> __________________
    --> #529: propertyAssignments => [ propertyAssignments ('T_COMMA') ] propertyAssignment @
    -->     Type: reduce
    -->     Reduce: propertyAssignments => [ @ propertyAssignments ('T_COMMA') ] propertyAssignment
    --> __________________
    --> #529: propertyAssignments => [ propertyAssignments ('T_COMMA') ] propertyAssignment @
    -->     Type: reduce
    -->     Reduce: propertyAssignments => [ propertyAssignments ('T_COMMA') @ ] propertyAssignment

** [FINAL] State #522: propertyName => ( identifierName | #STRING# | numericLiteral | ('T_LSQUARE') singleExpression ('T_RSQUARE') @ )
    --> __________________
    --> #244: classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName @ 'T_ASSIGN' singleExpression )
    -->     Type: reduce
    -->     Reduce: classElement => @ ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName 'T_ASSIGN' singleExpression )
    --> __________________
    --> #244: classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' ] propertyName @ 'T_ASSIGN' singleExpression )
    -->     Type: reduce
    -->     Reduce: classElement => ( methodDefinition | emptyStatement | [ 'T_SHARP' @ ] propertyName 'T_ASSIGN' singleExpression )
    --> __________________
    --> #245: methodDefinition => [ 'T_SHARP' ] propertyName @ ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: methodDefinition => [ @ 'T_SHARP' ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #245: methodDefinition => [ 'T_SHARP' ] propertyName @ ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: methodDefinition => [ 'T_SHARP' @ ] propertyName ('T_LPARAN') [ formalParameterList ] ('T_RPARAN') ('T_LBRACE') [ functionBody ] ('T_RBRACE')
    --> __________________
    --> #246: propertyExpressionAssignment => propertyName @ ('T_COLON') singleExpression
    -->     Type: reduce
    -->     Reduce: propertyExpressionAssignment => @ propertyName ('T_COLON') singleExpression

** [FINAL] State #523: propertyAssignment => ( propertyExpressionAssignment | computedPropertyExpressionAssignment | propertyShorthand @ )
    --> __________________
    --> #529: propertyAssignments => [ propertyAssignments ('T_COMMA') ] propertyAssignment @
    -->     Type: reduce
    -->     Reduce: propertyAssignments => [ @ propertyAssignments ('T_COMMA') ] propertyAssignment
    --> __________________
    --> #529: propertyAssignments => [ propertyAssignments ('T_COMMA') ] propertyAssignment @
    -->     Type: reduce
    -->     Reduce: propertyAssignments => [ propertyAssignments ('T_COMMA') @ ] propertyAssignment

** State #524: singleExpression => [ singleExpression ('T_COMMA') @ ] assignmentExpression
    --> __________________
    --> #84: assignmentExpression => [ @ assignmentExpression 'T_ASSIGN' ] assignmentOperatorExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #525: ternaryExpression => logicalOrExpression [ 'T_QUERY' singleExpression 'T_COLON' @ singleExpression ]
    --> __________________
    --> #47: singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #526: arrayLiteral => ('T_LSQUARE') [ elementList @ ] ('T_RSQUARE')
    --> __________________
    --> #191: arrayLiteral => ('T_LSQUARE') [ elementList ] ('T_RSQUARE') @
    -->     Type: pass
    -->     LA: 'T_RSQUARE' 

** State #527: elementList => [ elementList @ ('T_COMMA') ] arrayElement
    --> __________________
    --> #540: elementList => [ elementList ('T_COMMA') @ ] arrayElement
    -->     Type: pass
    -->     LA: 'T_COMMA' 

** State #528: computedPropertyExpressionAssignment => ('T_LPARAN') singleExpression ('T_RPARAN') ('T_COLON') @ singleExpression
    --> __________________
    --> #47: singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** [FINAL] State #529: propertyAssignments => [ propertyAssignments ('T_COMMA') ] propertyAssignment @
    --> __________________
    --> #541: objectLiteral => ('T_LBRACE') [ propertyAssignments @ ] [ ('T_COMMA') ] ('T_RBRACE')
    -->     Type: reduce
    -->     Reduce: objectLiteral => ('T_LBRACE') @ [ propertyAssignments ] [ ('T_COMMA') ] ('T_RBRACE')
    --> __________________
    --> #542: propertyAssignments => [ propertyAssignments @ ('T_COMMA') ] propertyAssignment
    -->     Type: recursion
    -->     LA: 'T_COMMA' 

** [FINAL] State #530: caseClause => K_CASE expressionSequence 'T_COLON' @ [ statementList ]
    --> __________________
    --> #42: statementList => [ @ statementList ] statement
    -->     Type: shift
    -->     LA: K_BREAK K_FOR K_TYPEOF 'T_LOG_NOT' K_VAR 
    -->     LA: K_IF K_DEBUGGER K_THIS K_DO 'T_BIT_NOT' 
    -->     LA: K_CLASS K_FALSE #STRING# K_RETURN K_SUPER 
    -->     LA: K_DELETE K_VOID K_WHILE 'T_INC' K_NEW 
    -->     LA: K_SWITCH 'T_LPARAN' 'T_SUB' K_NULL #REGEX# 
    -->     LA: 'T_DEC' 'T_LSQUARE' K_TRUE 'T_ADD' K_CONTINUE 
    -->     LA: 'T_SEMI' K_WITH #ID# K_TRY #NUMBER# 
    -->     LA: K_FUNCTION K_THROW 'T_LBRACE' 
    --> __________________
    --> #147: caseClauses => caseClause @ [ caseClauses ]
    -->     Type: reduce
    -->     Reduce: caseClauses => @ caseClause [ caseClauses ]

** [FINAL] State #531: doStatement => K_DO statement K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ [ eos ]
    --> __________________
    --> #53: eos => @ ( ('T_SEMI') | #END# )
    -->     Type: shift
    -->     LA: 'T_SEMI' #END# 
    --> __________________
    --> #152: iterationStatement => ( doStatement @ | whileStatement | forStatement | forInStatement )
    -->     Type: reduce
    -->     Reduce: iterationStatement => @ ( doStatement | whileStatement | forStatement | forInStatement )

** State #532: expressionSequence => [ expressionSequence ('T_COMMA') @ ] singleExpression
    --> __________________
    --> #47: singleExpression => [ @ singleExpression ('T_COMMA') ] assignmentExpression
    -->     Type: shift
    -->     LA: #ID# K_THIS K_FUNCTION K_FALSE K_CLASS 
    -->     LA: K_TRUE #STRING# K_SUPER K_NEW #NUMBER# 
    -->     LA: K_DELETE 'T_LPARAN' K_VOID K_TYPEOF 'T_INC' 
    -->     LA: K_NULL #REGEX# 'T_DEC' 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_BIT_NOT' 'T_ADD' 'T_LOG_NOT' 

** State #533: forInStatement => K_FOR ('T_LPARAN') [ ( singleExpression | K_VAR variableDeclarationList ) ] K_IN expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #2: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: shift
    -->     LA: 'T_LBRACE' K_THROW K_FUNCTION K_SWITCH #NUMBER# 
    -->     LA: K_TRY #ID# K_WITH 'T_SEMI' K_CONTINUE 
    -->     LA: 'T_ADD' K_TRUE 'T_LSQUARE' 'T_DEC' #REGEX# 
    -->     LA: K_RETURN K_NULL 'T_SUB' 'T_LPARAN' K_NEW 
    -->     LA: 'T_INC' K_WHILE K_VOID K_DELETE K_SUPER 
    -->     LA: #STRING# K_FALSE K_CLASS 'T_BIT_NOT' K_DO 
    -->     LA: K_THIS K_DEBUGGER K_IF K_VAR 'T_LOG_NOT' 
    -->     LA: K_TYPEOF K_FOR K_BREAK 

** State #534: ifStatement => K_IF ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement [ K_ELSE statement ]
    --> __________________
    --> #2: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: shift
    -->     LA: 'T_LBRACE' K_THROW K_FUNCTION K_SWITCH #NUMBER# 
    -->     LA: K_TRY #ID# K_WITH 'T_SEMI' K_CONTINUE 
    -->     LA: 'T_ADD' K_TRUE 'T_LSQUARE' 'T_DEC' #REGEX# 
    -->     LA: K_RETURN K_NULL 'T_SUB' 'T_LPARAN' K_NEW 
    -->     LA: 'T_INC' K_WHILE K_VOID K_DELETE K_SUPER 
    -->     LA: #STRING# K_FALSE K_CLASS 'T_BIT_NOT' K_DO 
    -->     LA: K_THIS K_DEBUGGER K_IF K_VAR 'T_LOG_NOT' 
    -->     LA: K_TYPEOF K_FOR K_BREAK 

** [FINAL] State #535: memberIndexExpression => [ memberIndexExpression ] 'T_LSQUARE' expressionSequence 'T_RSQUARE' @
    --> __________________
    --> #543: memberIndexExpression => [ memberIndexExpression @ ] 'T_LSQUARE' expressionSequence 'T_RSQUARE'
    -->     Type: recursion
    -->     LA: 'T_LSQUARE' 
    --> __________________
    --> #544: postfixExpression => ( postfixExpression (#RULE_NO_LINE#) ( memberIndexExpression @ | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )
    -->     Type: reduce
    -->     Reduce(exp): postfixExpression => ( postfixExpression (#RULE_NO_LINE#) @ ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )

** [FINAL] State #536: parenthesizedExpression => ('T_LPARAN') expressionSequence ('T_RPARAN') @
    --> __________________
    --> #545: functionExpression => ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): functionExpression => @ ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression )

** State #537: switchStatement => K_SWITCH ('T_LPARAN') expressionSequence ('T_RPARAN') @ caseBlock
    --> __________________
    --> #546: caseBlock => @ ('T_LBRACE') [ caseClauses ] [ defaultClause [ caseClauses ] ] ('T_RBRACE')
    -->     Type: shift
    -->     LA: 'T_LBRACE' 

** State #538: whileStatement => K_WHILE ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #2: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: shift
    -->     LA: 'T_LBRACE' K_THROW K_FUNCTION K_SWITCH #NUMBER# 
    -->     LA: K_TRY #ID# K_WITH 'T_SEMI' K_CONTINUE 
    -->     LA: 'T_ADD' K_TRUE 'T_LSQUARE' 'T_DEC' #REGEX# 
    -->     LA: K_RETURN K_NULL 'T_SUB' 'T_LPARAN' K_NEW 
    -->     LA: 'T_INC' K_WHILE K_VOID K_DELETE K_SUPER 
    -->     LA: #STRING# K_FALSE K_CLASS 'T_BIT_NOT' K_DO 
    -->     LA: K_THIS K_DEBUGGER K_IF K_VAR 'T_LOG_NOT' 
    -->     LA: K_TYPEOF K_FOR K_BREAK 

** State #539: withStatement => K_WITH ('T_LPARAN') expressionSequence ('T_RPARAN') @ statement
    --> __________________
    --> #2: statement => @ ( block | variableStatement | emptyStatement | classDeclaration | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement | debuggerStatement | functionDeclaration )
    -->     Type: shift
    -->     LA: 'T_LBRACE' K_THROW K_FUNCTION K_SWITCH #NUMBER# 
    -->     LA: K_TRY #ID# K_WITH 'T_SEMI' K_CONTINUE 
    -->     LA: 'T_ADD' K_TRUE 'T_LSQUARE' 'T_DEC' #REGEX# 
    -->     LA: K_RETURN K_NULL 'T_SUB' 'T_LPARAN' K_NEW 
    -->     LA: 'T_INC' K_WHILE K_VOID K_DELETE K_SUPER 
    -->     LA: #STRING# K_FALSE K_CLASS 'T_BIT_NOT' K_DO 
    -->     LA: K_THIS K_DEBUGGER K_IF K_VAR 'T_LOG_NOT' 
    -->     LA: K_TYPEOF K_FOR K_BREAK 

** State #540: elementList => [ elementList ('T_COMMA') @ ] arrayElement
    --> __________________
    --> #219: arrayElement => [ @ 'T_ELLIPSIS' ] singleExpression
    -->     Type: shift
    -->     LA: 'T_ELLIPSIS' 'T_DEC' #REGEX# 'T_LOG_NOT' 'T_ADD' 
    -->     LA: 'T_BIT_NOT' 'T_LBRACE' 'T_SUB' 'T_LSQUARE' #NUMBER# 
    -->     LA: K_NULL 'T_LPARAN' 'T_INC' K_TYPEOF K_VOID 
    -->     LA: K_DELETE K_NEW K_SUPER #STRING# K_TRUE 
    -->     LA: K_CLASS K_FALSE K_FUNCTION K_THIS #ID# 

** State #541: objectLiteral => ('T_LBRACE') [ propertyAssignments @ ] [ ('T_COMMA') ] ('T_RBRACE')
    --> __________________
    --> #181: objectLiteral => ('T_LBRACE') [ propertyAssignments ] [ ('T_COMMA') ] ('T_RBRACE') @
    -->     Type: pass
    -->     LA: 'T_RBRACE' 
    --> __________________
    --> #183: objectLiteral => ('T_LBRACE') [ propertyAssignments ] [ ('T_COMMA') @ ] ('T_RBRACE')
    -->     Type: pass
    -->     LA: 'T_COMMA' 

** State #542: propertyAssignments => [ propertyAssignments @ ('T_COMMA') ] propertyAssignment
    --> __________________
    --> #547: propertyAssignments => [ propertyAssignments ('T_COMMA') @ ] propertyAssignment
    -->     Type: pass
    -->     LA: 'T_COMMA' 

** State #543: memberIndexExpression => [ memberIndexExpression @ ] 'T_LSQUARE' expressionSequence 'T_RSQUARE'
    --> __________________
    --> #315: memberIndexExpression => [ memberIndexExpression ] 'T_LSQUARE' @ expressionSequence 'T_RSQUARE'
    -->     Type: move
    -->     LA: 'T_LSQUARE' 

** [FINAL] State #544: postfixExpression => ( postfixExpression (#RULE_NO_LINE#) ( memberIndexExpression @ | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )
    --> __________________
    --> #248: newExpression => ( K_NEW singleExpression [ arguments ] | postfixExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): newExpression => @ ( K_NEW singleExpression [ arguments ] | postfixExpression )
    --> __________________
    --> #249: postfixExpression => ( postfixExpression @ (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )
    -->     Type: recursion
    -->     LA: #RULE_NO_LINE# 

** [FINAL] State #545: functionExpression => ( anonymousFunction | classExpression | thisExpression | identifierExpression | superExpression | literalExpression | arrayLiteralExpression | objectLiteralExpression | parenthesizedExpression @ )
    --> __________________
    --> #225: postfixExpression => ( postfixExpression (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression @ )
    -->     Type: reduce
    -->     Reduce(exp): postfixExpression => @ ( postfixExpression (#RULE_NO_LINE#) ( memberIndexExpression | memberDotExpression | argumentsExpression | postIncrementExpression | postDecreaseExpression ) | functionExpression )

** State #546: caseBlock => @ ('T_LBRACE') [ caseClauses ] [ defaultClause [ caseClauses ] ] ('T_RBRACE')
    --> __________________
    --> #548: caseBlock => ('T_LBRACE') @ [ caseClauses ] [ defaultClause [ caseClauses ] ] ('T_RBRACE')
    -->     Type: pass
    -->     LA: 'T_LBRACE' 

** State #547: propertyAssignments => [ propertyAssignments ('T_COMMA') @ ] propertyAssignment
    --> __________________
    --> #208: propertyAssignment => @ ( propertyExpressionAssignment | computedPropertyExpressionAssignment | propertyShorthand )
    -->     Type: shift
    -->     LA: K_INSTANCEOF K_THIS K_CLASS #STRING# K_SUPER 
    -->     LA: K_DELETE K_VOID K_TYPEOF 'T_INC' K_NEW 
    -->     LA: 'T_LPARAN' K_FALSE K_DO 'T_LSQUARE' 'T_SUB' 
    -->     LA: 'T_LBRACE' 'T_ADD' 'T_DEC' 'T_ELLIPSIS' #NUMBER# 
    -->     LA: K_SWITCH K_IF K_CATCH K_LET 'T_LOG_NOT' 
    -->     LA: K_DEFAULT K_FUNCTION K_THROW K_NULL K_WHILE 
    -->     LA: K_VAR K_FOR K_CASE K_CONTINUE #REGEX# 
    -->     LA: K_RETURN K_WITH K_BREAK K_ELSE K_FINALLY 
    -->     LA: K_DEBUGGER K_TRUE 'T_BIT_NOT' K_IN #ID# 
    -->     LA: K_TRY 

** State #548: caseBlock => ('T_LBRACE') @ [ caseClauses ] [ defaultClause [ caseClauses ] ] ('T_RBRACE')
    --> __________________
    --> #175: caseBlock => ('T_LBRACE') [ caseClauses ] [ defaultClause [ caseClauses ] ] ('T_RBRACE') @
    -->     Type: pass
    -->     LA: 'T_RBRACE' 
    --> __________________
    --> #171: caseClauses => @ caseClause [ caseClauses ]
    -->     Type: shift
    -->     LA: K_CASE 
    --> __________________
    --> #202: defaultClause => @ K_DEFAULT 'T_COLON' [ statementList ]
    -->     Type: shift
    -->     LA: K_DEFAULT 

